--
-- Test partitioning planner code
--
create table lp (a char) partition by list (a);
create table lp_default partition of lp default;
create table lp_ef partition of lp for values in ('e', 'f');
create table lp_ad partition of lp for values in ('a', 'd');
create table lp_bc partition of lp for values in ('b', 'c');
create table lp_g partition of lp for values in ('g');
create table lp_null partition of lp for values in (null);
explain (costs off) select * from lp;
          QUERY PLAN          
------------------------------
 Append
   ->  Seq Scan on lp_ad
   ->  Seq Scan on lp_bc
   ->  Seq Scan on lp_ef
   ->  Seq Scan on lp_g
   ->  Seq Scan on lp_null
   ->  Seq Scan on lp_default
(7 rows)

explain (costs off) select * from lp where a > 'a' and a < 'd';
                        QUERY PLAN                         
-----------------------------------------------------------
 Append
   ->  Seq Scan on lp_bc
         Filter: ((a > 'a'::bpchar) AND (a < 'd'::bpchar))
   ->  Seq Scan on lp_default
         Filter: ((a > 'a'::bpchar) AND (a < 'd'::bpchar))
(5 rows)

explain (costs off) select * from lp where a > 'a' and a <= 'd';
                         QUERY PLAN                         
------------------------------------------------------------
 Append
   ->  Seq Scan on lp_ad
         Filter: ((a > 'a'::bpchar) AND (a <= 'd'::bpchar))
   ->  Seq Scan on lp_bc
         Filter: ((a > 'a'::bpchar) AND (a <= 'd'::bpchar))
   ->  Seq Scan on lp_default
         Filter: ((a > 'a'::bpchar) AND (a <= 'd'::bpchar))
(7 rows)

explain (costs off) select * from lp where a = 'a';
            QUERY PLAN             
-----------------------------------
 Append
   ->  Seq Scan on lp_ad
         Filter: (a = 'a'::bpchar)
(3 rows)

explain (costs off) select * from lp where 'a' = a;	/* commuted */
            QUERY PLAN             
-----------------------------------
 Append
   ->  Seq Scan on lp_ad
         Filter: ('a'::bpchar = a)
(3 rows)

explain (costs off) select * from lp where a is not null;
           QUERY PLAN            
---------------------------------
 Append
   ->  Seq Scan on lp_ad
         Filter: (a IS NOT NULL)
   ->  Seq Scan on lp_bc
         Filter: (a IS NOT NULL)
   ->  Seq Scan on lp_ef
         Filter: (a IS NOT NULL)
   ->  Seq Scan on lp_g
         Filter: (a IS NOT NULL)
   ->  Seq Scan on lp_default
         Filter: (a IS NOT NULL)
(11 rows)

explain (costs off) select * from lp where a is null;
         QUERY PLAN          
-----------------------------
 Append
   ->  Seq Scan on lp_null
         Filter: (a IS NULL)
(3 rows)

explain (costs off) select * from lp where a = 'a' or a = 'c';
                        QUERY PLAN                        
----------------------------------------------------------
 Append
   ->  Seq Scan on lp_ad
         Filter: ((a = 'a'::bpchar) OR (a = 'c'::bpchar))
   ->  Seq Scan on lp_bc
         Filter: ((a = 'a'::bpchar) OR (a = 'c'::bpchar))
(5 rows)

explain (costs off) select * from lp where a is not null and (a = 'a' or a = 'c');
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Append
   ->  Seq Scan on lp_ad
         Filter: ((a IS NOT NULL) AND ((a = 'a'::bpchar) OR (a = 'c'::bpchar)))
   ->  Seq Scan on lp_bc
         Filter: ((a IS NOT NULL) AND ((a = 'a'::bpchar) OR (a = 'c'::bpchar)))
(5 rows)

explain (costs off) select * from lp where a <> 'g';
             QUERY PLAN             
------------------------------------
 Append
   ->  Seq Scan on lp_ad
         Filter: (a <> 'g'::bpchar)
   ->  Seq Scan on lp_bc
         Filter: (a <> 'g'::bpchar)
   ->  Seq Scan on lp_ef
         Filter: (a <> 'g'::bpchar)
   ->  Seq Scan on lp_default
         Filter: (a <> 'g'::bpchar)
(9 rows)

explain (costs off) select * from lp where a <> 'a' and a <> 'd';
                         QUERY PLAN                          
-------------------------------------------------------------
 Append
   ->  Seq Scan on lp_bc
         Filter: ((a <> 'a'::bpchar) AND (a <> 'd'::bpchar))
   ->  Seq Scan on lp_ef
         Filter: ((a <> 'a'::bpchar) AND (a <> 'd'::bpchar))
   ->  Seq Scan on lp_g
         Filter: ((a <> 'a'::bpchar) AND (a <> 'd'::bpchar))
   ->  Seq Scan on lp_default
         Filter: ((a <> 'a'::bpchar) AND (a <> 'd'::bpchar))
(9 rows)

explain (costs off) select * from lp where a not in ('a', 'd');
                   QUERY PLAN                   
------------------------------------------------
 Append
   ->  Seq Scan on lp_bc
         Filter: (a <> ALL ('{a,d}'::bpchar[]))
   ->  Seq Scan on lp_ef
         Filter: (a <> ALL ('{a,d}'::bpchar[]))
   ->  Seq Scan on lp_g
         Filter: (a <> ALL ('{a,d}'::bpchar[]))
   ->  Seq Scan on lp_default
         Filter: (a <> ALL ('{a,d}'::bpchar[]))
(9 rows)

-- collation matches the partitioning collation, pruning works
create table coll_pruning (a text collate "C") partition by list (a);
create table coll_pruning_a partition of coll_pruning for values in ('a');
create table coll_pruning_b partition of coll_pruning for values in ('b');
create table coll_pruning_def partition of coll_pruning default;
explain (costs off) select * from coll_pruning where a collate "C" = 'a' collate "C";
                 QUERY PLAN                  
---------------------------------------------
 Append
   ->  Seq Scan on coll_pruning_a
         Filter: (a = 'a'::text COLLATE "C")
(3 rows)

-- collation doesn't match the partitioning collation, no pruning occurs
explain (costs off) select * from coll_pruning where a collate "POSIX" = 'a' collate "POSIX";
                       QUERY PLAN                        
---------------------------------------------------------
 Append
   ->  Seq Scan on coll_pruning_a
         Filter: ((a)::text = 'a'::text COLLATE "POSIX")
   ->  Seq Scan on coll_pruning_b
         Filter: ((a)::text = 'a'::text COLLATE "POSIX")
   ->  Seq Scan on coll_pruning_def
         Filter: ((a)::text = 'a'::text COLLATE "POSIX")
(7 rows)

create table rlp (a int, b varchar) partition by range (a);
create table rlp_default partition of rlp default partition by list (a);
create table rlp_default_default partition of rlp_default default;
create table rlp_default_10 partition of rlp_default for values in (10);
create table rlp_default_30 partition of rlp_default for values in (30);
create table rlp_default_null partition of rlp_default for values in (null);
create table rlp1 partition of rlp for values from (minvalue) to (1);
create table rlp2 partition of rlp for values from (1) to (10);
create table rlp3 (b varchar, a int) partition by list (b varchar_ops);
create table rlp3_default partition of rlp3 default;
create table rlp3abcd partition of rlp3 for values in ('ab', 'cd');
create table rlp3efgh partition of rlp3 for values in ('ef', 'gh');
create table rlp3nullxy partition of rlp3 for values in (null, 'xy');
alter table rlp attach partition rlp3 for values from (15) to (20);
create table rlp4 partition of rlp for values from (20) to (30) partition by range (a);
create table rlp4_default partition of rlp4 default;
create table rlp4_1 partition of rlp4 for values from (20) to (25);
create table rlp4_2 partition of rlp4 for values from (25) to (29);
create table rlp5 partition of rlp for values from (31) to (maxvalue) partition by range (a);
create table rlp5_default partition of rlp5 default;
create table rlp5_1 partition of rlp5 for values from (31) to (40);
explain (costs off) select * from rlp where a < 1;
       QUERY PLAN        
-------------------------
 Append
   ->  Seq Scan on rlp1
         Filter: (a < 1)
(3 rows)

explain (costs off) select * from rlp where 1 > a;	/* commuted */
       QUERY PLAN        
-------------------------
 Append
   ->  Seq Scan on rlp1
         Filter: (1 > a)
(3 rows)

explain (costs off) select * from rlp where a <= 1;
        QUERY PLAN        
--------------------------
 Append
   ->  Seq Scan on rlp1
         Filter: (a <= 1)
   ->  Seq Scan on rlp2
         Filter: (a <= 1)
(5 rows)

explain (costs off) select * from rlp where a = 1;
       QUERY PLAN        
-------------------------
 Append
   ->  Seq Scan on rlp2
         Filter: (a = 1)
(3 rows)

explain (costs off) select * from rlp where a = 1::bigint;		/* same as above */
            QUERY PLAN             
-----------------------------------
 Append
   ->  Seq Scan on rlp2
         Filter: (a = '1'::bigint)
(3 rows)

explain (costs off) select * from rlp where a = 1::numeric;		/* no pruning */
                  QUERY PLAN                   
-----------------------------------------------
 Append
   ->  Seq Scan on rlp1
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp2
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp3abcd
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp3efgh
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp3nullxy
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp3_default
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp4_1
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp4_2
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp4_default
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp5_1
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp5_default
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp_default_10
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp_default_30
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp_default_null
         Filter: ((a)::numeric = '1'::numeric)
   ->  Seq Scan on rlp_default_default
         Filter: ((a)::numeric = '1'::numeric)
(31 rows)

explain (costs off) select * from rlp where a <= 10;
              QUERY PLAN               
---------------------------------------
 Append
   ->  Seq Scan on rlp1
         Filter: (a <= 10)
   ->  Seq Scan on rlp2
         Filter: (a <= 10)
   ->  Seq Scan on rlp_default_10
         Filter: (a <= 10)
   ->  Seq Scan on rlp_default_default
         Filter: (a <= 10)
(9 rows)

explain (costs off) select * from rlp where a > 10;
              QUERY PLAN               
---------------------------------------
 Append
   ->  Seq Scan on rlp3abcd
         Filter: (a > 10)
   ->  Seq Scan on rlp3efgh
         Filter: (a > 10)
   ->  Seq Scan on rlp3nullxy
         Filter: (a > 10)
   ->  Seq Scan on rlp3_default
         Filter: (a > 10)
   ->  Seq Scan on rlp4_1
         Filter: (a > 10)
   ->  Seq Scan on rlp4_2
         Filter: (a > 10)
   ->  Seq Scan on rlp4_default
         Filter: (a > 10)
   ->  Seq Scan on rlp5_1
         Filter: (a > 10)
   ->  Seq Scan on rlp5_default
         Filter: (a > 10)
   ->  Seq Scan on rlp_default_30
         Filter: (a > 10)
   ->  Seq Scan on rlp_default_default
         Filter: (a > 10)
(23 rows)

explain (costs off) select * from rlp where a < 15;
              QUERY PLAN               
---------------------------------------
 Append
   ->  Seq Scan on rlp1
         Filter: (a < 15)
   ->  Seq Scan on rlp2
         Filter: (a < 15)
   ->  Seq Scan on rlp_default_10
         Filter: (a < 15)
   ->  Seq Scan on rlp_default_default
         Filter: (a < 15)
(9 rows)

explain (costs off) select * from rlp where a <= 15;
              QUERY PLAN               
---------------------------------------
 Append
   ->  Seq Scan on rlp1
         Filter: (a <= 15)
   ->  Seq Scan on rlp2
         Filter: (a <= 15)
   ->  Seq Scan on rlp3abcd
         Filter: (a <= 15)
   ->  Seq Scan on rlp3efgh
         Filter: (a <= 15)
   ->  Seq Scan on rlp3nullxy
         Filter: (a <= 15)
   ->  Seq Scan on rlp3_default
         Filter: (a <= 15)
   ->  Seq Scan on rlp_default_10
         Filter: (a <= 15)
   ->  Seq Scan on rlp_default_default
         Filter: (a <= 15)
(17 rows)

explain (costs off) select * from rlp where a > 15 and b = 'ab';
                       QUERY PLAN                        
---------------------------------------------------------
 Append
   ->  Seq Scan on rlp3abcd
         Filter: ((a > 15) AND ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp4_1
         Filter: ((a > 15) AND ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp4_2
         Filter: ((a > 15) AND ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp4_default
         Filter: ((a > 15) AND ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp5_1
         Filter: ((a > 15) AND ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp5_default
         Filter: ((a > 15) AND ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp_default_30
         Filter: ((a > 15) AND ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp_default_default
         Filter: ((a > 15) AND ((b)::text = 'ab'::text))
(17 rows)

explain (costs off) select * from rlp where a = 16;
           QUERY PLAN           
--------------------------------
 Append
   ->  Seq Scan on rlp3abcd
         Filter: (a = 16)
   ->  Seq Scan on rlp3efgh
         Filter: (a = 16)
   ->  Seq Scan on rlp3nullxy
         Filter: (a = 16)
   ->  Seq Scan on rlp3_default
         Filter: (a = 16)
(9 rows)

explain (costs off) select * from rlp where a = 16 and b in ('not', 'in', 'here');
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Append
   ->  Seq Scan on rlp3_default
         Filter: ((a = 16) AND ((b)::text = ANY ('{not,in,here}'::text[])))
(3 rows)

explain (costs off) select * from rlp where a = 16 and b < 'ab';
                       QUERY PLAN                        
---------------------------------------------------------
 Append
   ->  Seq Scan on rlp3_default
         Filter: (((b)::text < 'ab'::text) AND (a = 16))
(3 rows)

explain (costs off) select * from rlp where a = 16 and b <= 'ab';
                        QUERY PLAN                        
----------------------------------------------------------
 Append
   ->  Seq Scan on rlp3abcd
         Filter: (((b)::text <= 'ab'::text) AND (a = 16))
   ->  Seq Scan on rlp3_default
         Filter: (((b)::text <= 'ab'::text) AND (a = 16))
(5 rows)

explain (costs off) select * from rlp where a = 16 and b is null;
                 QUERY PLAN                 
--------------------------------------------
 Append
   ->  Seq Scan on rlp3nullxy
         Filter: ((b IS NULL) AND (a = 16))
(3 rows)

explain (costs off) select * from rlp where a = 16 and b is not null;
                   QUERY PLAN                   
------------------------------------------------
 Append
   ->  Seq Scan on rlp3abcd
         Filter: ((b IS NOT NULL) AND (a = 16))
   ->  Seq Scan on rlp3efgh
         Filter: ((b IS NOT NULL) AND (a = 16))
   ->  Seq Scan on rlp3nullxy
         Filter: ((b IS NOT NULL) AND (a = 16))
   ->  Seq Scan on rlp3_default
         Filter: ((b IS NOT NULL) AND (a = 16))
(9 rows)

explain (costs off) select * from rlp where a is null;
             QUERY PLAN             
------------------------------------
 Append
   ->  Seq Scan on rlp_default_null
         Filter: (a IS NULL)
(3 rows)

explain (costs off) select * from rlp where a is not null;
              QUERY PLAN               
---------------------------------------
 Append
   ->  Seq Scan on rlp1
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp2
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp3abcd
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp3efgh
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp3nullxy
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp3_default
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp4_1
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp4_2
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp4_default
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp5_1
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp5_default
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp_default_10
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp_default_30
         Filter: (a IS NOT NULL)
   ->  Seq Scan on rlp_default_default
         Filter: (a IS NOT NULL)
(29 rows)

explain (costs off) select * from rlp where a > 30;
              QUERY PLAN               
---------------------------------------
 Append
   ->  Seq Scan on rlp5_1
         Filter: (a > 30)
   ->  Seq Scan on rlp5_default
         Filter: (a > 30)
   ->  Seq Scan on rlp_default_default
         Filter: (a > 30)
(7 rows)

explain (costs off) select * from rlp where a = 30;	/* only default is scanned */
            QUERY PLAN            
----------------------------------
 Append
   ->  Seq Scan on rlp_default_30
         Filter: (a = 30)
(3 rows)

explain (costs off) select * from rlp where a <= 31;
              QUERY PLAN               
---------------------------------------
 Append
   ->  Seq Scan on rlp1
         Filter: (a <= 31)
   ->  Seq Scan on rlp2
         Filter: (a <= 31)
   ->  Seq Scan on rlp3abcd
         Filter: (a <= 31)
   ->  Seq Scan on rlp3efgh
         Filter: (a <= 31)
   ->  Seq Scan on rlp3nullxy
         Filter: (a <= 31)
   ->  Seq Scan on rlp3_default
         Filter: (a <= 31)
   ->  Seq Scan on rlp4_1
         Filter: (a <= 31)
   ->  Seq Scan on rlp4_2
         Filter: (a <= 31)
   ->  Seq Scan on rlp4_default
         Filter: (a <= 31)
   ->  Seq Scan on rlp5_1
         Filter: (a <= 31)
   ->  Seq Scan on rlp5_default
         Filter: (a <= 31)
   ->  Seq Scan on rlp_default_10
         Filter: (a <= 31)
   ->  Seq Scan on rlp_default_30
         Filter: (a <= 31)
   ->  Seq Scan on rlp_default_default
         Filter: (a <= 31)
(29 rows)

explain (costs off) select * from rlp where a = 1 or a = 7;
              QUERY PLAN              
--------------------------------------
 Append
   ->  Seq Scan on rlp2
         Filter: ((a = 1) OR (a = 7))
(3 rows)

explain (costs off) select * from rlp where a = 1 or b = 'ab';
                      QUERY PLAN                       
-------------------------------------------------------
 Append
   ->  Seq Scan on rlp1
         Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp2
         Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp3abcd
         Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp4_1
         Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp4_2
         Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp4_default
         Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp5_1
         Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp5_default
         Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp_default_10
         Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp_default_30
         Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp_default_null
         Filter: ((a = 1) OR ((b)::text = 'ab'::text))
   ->  Seq Scan on rlp_default_default
         Filter: ((a = 1) OR ((b)::text = 'ab'::text))
(25 rows)

explain (costs off) select * from rlp where a > 20 and a < 27;
               QUERY PLAN                
-----------------------------------------
 Append
   ->  Seq Scan on rlp4_1
         Filter: ((a > 20) AND (a < 27))
   ->  Seq Scan on rlp4_2
         Filter: ((a > 20) AND (a < 27))
   ->  Seq Scan on rlp4_default
         Filter: ((a > 20) AND (a < 27))
   ->  Seq Scan on rlp_default_default
         Filter: ((a > 20) AND (a < 27))
(9 rows)

explain (costs off) select * from rlp where a = 29;
           QUERY PLAN           
--------------------------------
 Append
   ->  Seq Scan on rlp4_default
         Filter: (a = 29)
(3 rows)

explain (costs off) select * from rlp where a >= 29;
              QUERY PLAN               
---------------------------------------
 Append
   ->  Seq Scan on rlp4_default
         Filter: (a >= 29)
   ->  Seq Scan on rlp5_1
         Filter: (a >= 29)
   ->  Seq Scan on rlp5_default
         Filter: (a >= 29)
   ->  Seq Scan on rlp_default_30
         Filter: (a >= 29)
   ->  Seq Scan on rlp_default_default
         Filter: (a >= 29)
(11 rows)

-- redundant clauses are eliminated
explain (costs off) select * from rlp where a > 1 and a = 10;	/* only default */
               QUERY PLAN               
----------------------------------------
 Append
   ->  Seq Scan on rlp_default_10
         Filter: ((a > 1) AND (a = 10))
(3 rows)

explain (costs off) select * from rlp where a > 1 and a >=15;	/* rlp3 onwards, including default */
               QUERY PLAN                
-----------------------------------------
 Append
   ->  Seq Scan on rlp3abcd
         Filter: ((a > 1) AND (a >= 15))
   ->  Seq Scan on rlp3efgh
         Filter: ((a > 1) AND (a >= 15))
   ->  Seq Scan on rlp3nullxy
         Filter: ((a > 1) AND (a >= 15))
   ->  Seq Scan on rlp3_default
         Filter: ((a > 1) AND (a >= 15))
   ->  Seq Scan on rlp4_1
         Filter: ((a > 1) AND (a >= 15))
   ->  Seq Scan on rlp4_2
         Filter: ((a > 1) AND (a >= 15))
   ->  Seq Scan on rlp4_default
         Filter: ((a > 1) AND (a >= 15))
   ->  Seq Scan on rlp5_1
         Filter: ((a > 1) AND (a >= 15))
   ->  Seq Scan on rlp5_default
         Filter: ((a > 1) AND (a >= 15))
   ->  Seq Scan on rlp_default_30
         Filter: ((a > 1) AND (a >= 15))
   ->  Seq Scan on rlp_default_default
         Filter: ((a > 1) AND (a >= 15))
(23 rows)

explain (costs off) select * from rlp where a = 1 and a = 3;	/* empty */
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

explain (costs off) select * from rlp where (a = 1 and a = 3) or (a > 1 and a = 15);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Append
   ->  Seq Scan on rlp2
         Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))
   ->  Seq Scan on rlp3abcd
         Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))
   ->  Seq Scan on rlp3efgh
         Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))
   ->  Seq Scan on rlp3nullxy
         Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))
   ->  Seq Scan on rlp3_default
         Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))
(11 rows)

-- multi-column keys
create table mc3p (a int, b int, c int) partition by range (a, abs(b), c);
create table mc3p_default partition of mc3p default;
create table mc3p0 partition of mc3p for values from (minvalue, minvalue, minvalue) to (1, 1, 1);
create table mc3p1 partition of mc3p for values from (1, 1, 1) to (10, 5, 10);
create table mc3p2 partition of mc3p for values from (10, 5, 10) to (10, 10, 10);
create table mc3p3 partition of mc3p for values from (10, 10, 10) to (10, 10, 20);
create table mc3p4 partition of mc3p for values from (10, 10, 20) to (10, maxvalue, maxvalue);
create table mc3p5 partition of mc3p for values from (11, 1, 1) to (20, 10, 10);
create table mc3p6 partition of mc3p for values from (20, 10, 10) to (20, 20, 20);
create table mc3p7 partition of mc3p for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue);
explain (costs off) select * from mc3p where a = 1;
           QUERY PLAN           
--------------------------------
 Append
   ->  Seq Scan on mc3p0
         Filter: (a = 1)
   ->  Seq Scan on mc3p1
         Filter: (a = 1)
   ->  Seq Scan on mc3p_default
         Filter: (a = 1)
(7 rows)

explain (costs off) select * from mc3p where a = 1 and abs(b) < 1;
                 QUERY PLAN                 
--------------------------------------------
 Append
   ->  Seq Scan on mc3p0
         Filter: ((a = 1) AND (abs(b) < 1))
   ->  Seq Scan on mc3p_default
         Filter: ((a = 1) AND (abs(b) < 1))
(5 rows)

explain (costs off) select * from mc3p where a = 1 and abs(b) = 1;
                 QUERY PLAN                 
--------------------------------------------
 Append
   ->  Seq Scan on mc3p0
         Filter: ((a = 1) AND (abs(b) = 1))
   ->  Seq Scan on mc3p1
         Filter: ((a = 1) AND (abs(b) = 1))
   ->  Seq Scan on mc3p_default
         Filter: ((a = 1) AND (abs(b) = 1))
(7 rows)

explain (costs off) select * from mc3p where a = 1 and abs(b) = 1 and c < 8;
                       QUERY PLAN                       
--------------------------------------------------------
 Append
   ->  Seq Scan on mc3p0
         Filter: ((c < 8) AND (a = 1) AND (abs(b) = 1))
   ->  Seq Scan on mc3p1
         Filter: ((c < 8) AND (a = 1) AND (abs(b) = 1))
(5 rows)

explain (costs off) select * from mc3p where a = 10 and abs(b) between 5 and 35;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Append
   ->  Seq Scan on mc3p1
         Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))
   ->  Seq Scan on mc3p2
         Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))
   ->  Seq Scan on mc3p3
         Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))
   ->  Seq Scan on mc3p4
         Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))
   ->  Seq Scan on mc3p_default
         Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))
(11 rows)

explain (costs off) select * from mc3p where a > 10;
           QUERY PLAN           
--------------------------------
 Append
   ->  Seq Scan on mc3p5
         Filter: (a > 10)
   ->  Seq Scan on mc3p6
         Filter: (a > 10)
   ->  Seq Scan on mc3p7
         Filter: (a > 10)
   ->  Seq Scan on mc3p_default
         Filter: (a > 10)
(9 rows)

explain (costs off) select * from mc3p where a >= 10;
           QUERY PLAN           
--------------------------------
 Append
   ->  Seq Scan on mc3p1
         Filter: (a >= 10)
   ->  Seq Scan on mc3p2
         Filter: (a >= 10)
   ->  Seq Scan on mc3p3
         Filter: (a >= 10)
   ->  Seq Scan on mc3p4
         Filter: (a >= 10)
   ->  Seq Scan on mc3p5
         Filter: (a >= 10)
   ->  Seq Scan on mc3p6
         Filter: (a >= 10)
   ->  Seq Scan on mc3p7
         Filter: (a >= 10)
   ->  Seq Scan on mc3p_default
         Filter: (a >= 10)
(17 rows)

explain (costs off) select * from mc3p where a < 10;
           QUERY PLAN           
--------------------------------
 Append
   ->  Seq Scan on mc3p0
         Filter: (a < 10)
   ->  Seq Scan on mc3p1
         Filter: (a < 10)
   ->  Seq Scan on mc3p_default
         Filter: (a < 10)
(7 rows)

explain (costs off) select * from mc3p where a <= 10 and abs(b) < 10;
                  QUERY PLAN                   
-----------------------------------------------
 Append
   ->  Seq Scan on mc3p0
         Filter: ((a <= 10) AND (abs(b) < 10))
   ->  Seq Scan on mc3p1
         Filter: ((a <= 10) AND (abs(b) < 10))
   ->  Seq Scan on mc3p2
         Filter: ((a <= 10) AND (abs(b) < 10))
   ->  Seq Scan on mc3p_default
         Filter: ((a <= 10) AND (abs(b) < 10))
(9 rows)

explain (costs off) select * from mc3p where a = 11 and abs(b) = 0;
                 QUERY PLAN                  
---------------------------------------------
 Append
   ->  Seq Scan on mc3p_default
         Filter: ((a = 11) AND (abs(b) = 0))
(3 rows)

explain (costs off) select * from mc3p where a = 20 and abs(b) = 10 and c = 100;
                         QUERY PLAN                         
------------------------------------------------------------
 Append
   ->  Seq Scan on mc3p6
         Filter: ((a = 20) AND (c = 100) AND (abs(b) = 10))
(3 rows)

explain (costs off) select * from mc3p where a > 20;
           QUERY PLAN           
--------------------------------
 Append
   ->  Seq Scan on mc3p7
         Filter: (a > 20)
   ->  Seq Scan on mc3p_default
         Filter: (a > 20)
(5 rows)

explain (costs off) select * from mc3p where a >= 20;
           QUERY PLAN           
--------------------------------
 Append
   ->  Seq Scan on mc3p5
         Filter: (a >= 20)
   ->  Seq Scan on mc3p6
         Filter: (a >= 20)
   ->  Seq Scan on mc3p7
         Filter: (a >= 20)
   ->  Seq Scan on mc3p_default
         Filter: (a >= 20)
(9 rows)

explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20);
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on mc3p1
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)))
   ->  Seq Scan on mc3p2
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)))
   ->  Seq Scan on mc3p5
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)))
   ->  Seq Scan on mc3p_default
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)))
(9 rows)

explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20) or a < 1;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on mc3p0
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))
   ->  Seq Scan on mc3p1
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))
   ->  Seq Scan on mc3p2
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))
   ->  Seq Scan on mc3p5
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))
   ->  Seq Scan on mc3p_default
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))
(11 rows)

explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20) or a < 1 or a = 1;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on mc3p0
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))
   ->  Seq Scan on mc3p1
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))
   ->  Seq Scan on mc3p2
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))
   ->  Seq Scan on mc3p5
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))
   ->  Seq Scan on mc3p_default
         Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))
(11 rows)

explain (costs off) select * from mc3p where a = 1 or abs(b) = 1 or c = 1;
                      QUERY PLAN                      
------------------------------------------------------
 Append
   ->  Seq Scan on mc3p0
         Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
   ->  Seq Scan on mc3p1
         Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
   ->  Seq Scan on mc3p2
         Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
   ->  Seq Scan on mc3p3
         Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
   ->  Seq Scan on mc3p4
         Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
   ->  Seq Scan on mc3p5
         Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
   ->  Seq Scan on mc3p6
         Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
   ->  Seq Scan on mc3p7
         Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
   ->  Seq Scan on mc3p_default
         Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
(19 rows)

explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1) or (a = 10 and abs(b) = 10);
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Append
   ->  Seq Scan on mc3p0
         Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))
   ->  Seq Scan on mc3p1
         Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))
   ->  Seq Scan on mc3p2
         Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))
   ->  Seq Scan on mc3p3
         Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))
   ->  Seq Scan on mc3p4
         Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))
   ->  Seq Scan on mc3p_default
         Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))
(13 rows)

explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1) or (a = 10 and abs(b) = 9);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Append
   ->  Seq Scan on mc3p0
         Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 9)))
   ->  Seq Scan on mc3p1
         Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 9)))
   ->  Seq Scan on mc3p2
         Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 9)))
   ->  Seq Scan on mc3p_default
         Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 9)))
(9 rows)

-- a simpler multi-column keys case
create table mc2p (a int, b int) partition by range (a, b);
create table mc2p_default partition of mc2p default;
create table mc2p0 partition of mc2p for values from (minvalue, minvalue) to (1, minvalue);
create table mc2p1 partition of mc2p for values from (1, minvalue) to (1, 1);
create table mc2p2 partition of mc2p for values from (1, 1) to (2, minvalue);
create table mc2p3 partition of mc2p for values from (2, minvalue) to (2, 1);
create table mc2p4 partition of mc2p for values from (2, 1) to (2, maxvalue);
create table mc2p5 partition of mc2p for values from (2, maxvalue) to (maxvalue, maxvalue);
explain (costs off) select * from mc2p where a < 2;
           QUERY PLAN           
--------------------------------
 Append
   ->  Seq Scan on mc2p0
         Filter: (a < 2)
   ->  Seq Scan on mc2p1
         Filter: (a < 2)
   ->  Seq Scan on mc2p2
         Filter: (a < 2)
   ->  Seq Scan on mc2p_default
         Filter: (a < 2)
(9 rows)

explain (costs off) select * from mc2p where a = 2 and b < 1;
              QUERY PLAN               
---------------------------------------
 Append
   ->  Seq Scan on mc2p3
         Filter: ((b < 1) AND (a = 2))
(3 rows)

explain (costs off) select * from mc2p where a > 1;
           QUERY PLAN           
--------------------------------
 Append
   ->  Seq Scan on mc2p2
         Filter: (a > 1)
   ->  Seq Scan on mc2p3
         Filter: (a > 1)
   ->  Seq Scan on mc2p4
         Filter: (a > 1)
   ->  Seq Scan on mc2p5
         Filter: (a > 1)
   ->  Seq Scan on mc2p_default
         Filter: (a > 1)
(11 rows)

explain (costs off) select * from mc2p where a = 1 and b > 1;
              QUERY PLAN               
---------------------------------------
 Append
   ->  Seq Scan on mc2p2
         Filter: ((b > 1) AND (a = 1))
(3 rows)

-- boolean partitioning
create table boolpart (a bool) partition by list (a);
create table boolpart_default partition of boolpart default;
create table boolpart_t partition of boolpart for values in ('true');
create table boolpart_f partition of boolpart for values in ('false');
explain (costs off) select * from boolpart where a in (true, false);
                   QUERY PLAN                   
------------------------------------------------
 Append
   ->  Seq Scan on boolpart_f
         Filter: (a = ANY ('{t,f}'::boolean[]))
   ->  Seq Scan on boolpart_t
         Filter: (a = ANY ('{t,f}'::boolean[]))
(5 rows)

explain (costs off) select * from boolpart where a = false;
          QUERY PLAN          
------------------------------
 Append
   ->  Seq Scan on boolpart_f
         Filter: (NOT a)
(3 rows)

explain (costs off) select * from boolpart where not a = false;
          QUERY PLAN          
------------------------------
 Append
   ->  Seq Scan on boolpart_t
         Filter: a
(3 rows)

explain (costs off) select * from boolpart where a is true or a is not true;
                    QUERY PLAN                    
--------------------------------------------------
 Append
   ->  Seq Scan on boolpart_f
         Filter: ((a IS TRUE) OR (a IS NOT TRUE))
   ->  Seq Scan on boolpart_t
         Filter: ((a IS TRUE) OR (a IS NOT TRUE))
(5 rows)

explain (costs off) select * from boolpart where a is not true;
           QUERY PLAN            
---------------------------------
 Append
   ->  Seq Scan on boolpart_f
         Filter: (a IS NOT TRUE)
(3 rows)

explain (costs off) select * from boolpart where a is not true and a is not false;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

explain (costs off) select * from boolpart where a is unknown;
             QUERY PLAN             
------------------------------------
 Append
   ->  Seq Scan on boolpart_f
         Filter: (a IS UNKNOWN)
   ->  Seq Scan on boolpart_t
         Filter: (a IS UNKNOWN)
   ->  Seq Scan on boolpart_default
         Filter: (a IS UNKNOWN)
(7 rows)

explain (costs off) select * from boolpart where a is not unknown;
             QUERY PLAN             
------------------------------------
 Append
   ->  Seq Scan on boolpart_f
         Filter: (a IS NOT UNKNOWN)
   ->  Seq Scan on boolpart_t
         Filter: (a IS NOT UNKNOWN)
   ->  Seq Scan on boolpart_default
         Filter: (a IS NOT UNKNOWN)
(7 rows)

--
-- some more cases
--
--
-- pruning for partitioned table appearing inside a sub-query
--
-- pruning won't work for mc3p, because some keys are Params
explain (costs off) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.a = t1.b and abs(t2.b) = 1 and t2.c = 1) s where t1.a = 1;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on mc2p1 t1
               Filter: (a = 1)
         ->  Seq Scan on mc2p2 t1_1
               Filter: (a = 1)
         ->  Seq Scan on mc2p_default t1_2
               Filter: (a = 1)
   ->  Aggregate
         ->  Append
               ->  Seq Scan on mc3p0 t2
                     Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))
               ->  Seq Scan on mc3p1 t2_1
                     Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))
               ->  Seq Scan on mc3p2 t2_2
                     Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))
               ->  Seq Scan on mc3p3 t2_3
                     Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))
               ->  Seq Scan on mc3p4 t2_4
                     Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))
               ->  Seq Scan on mc3p5 t2_5
                     Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))
               ->  Seq Scan on mc3p6 t2_6
                     Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))
               ->  Seq Scan on mc3p7 t2_7
                     Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))
               ->  Seq Scan on mc3p_default t2_8
                     Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))
(28 rows)

-- pruning should work fine, because values for a prefix of keys (a, b) are
-- available
explain (costs off) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.c = t1.b and abs(t2.b) = 1 and t2.a = 1) s where t1.a = 1;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Nested Loop
   ->  Append
         ->  Seq Scan on mc2p1 t1
               Filter: (a = 1)
         ->  Seq Scan on mc2p2 t1_1
               Filter: (a = 1)
         ->  Seq Scan on mc2p_default t1_2
               Filter: (a = 1)
   ->  Aggregate
         ->  Append
               ->  Seq Scan on mc3p0 t2
                     Filter: ((c = t1.b) AND (a = 1) AND (abs(b) = 1))
               ->  Seq Scan on mc3p1 t2_1
                     Filter: ((c = t1.b) AND (a = 1) AND (abs(b) = 1))
               ->  Seq Scan on mc3p_default t2_2
                     Filter: ((c = t1.b) AND (a = 1) AND (abs(b) = 1))
(16 rows)

-- also here, because values for all keys are provided
explain (costs off) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.a = 1 and abs(t2.b) = 1 and t2.c = 1) s where t1.a = 1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Nested Loop
   ->  Aggregate
         ->  Append
               ->  Seq Scan on mc3p1 t2
                     Filter: ((a = 1) AND (c = 1) AND (abs(b) = 1))
   ->  Append
         ->  Seq Scan on mc2p1 t1
               Filter: (a = 1)
         ->  Seq Scan on mc2p2 t1_1
               Filter: (a = 1)
         ->  Seq Scan on mc2p_default t1_2
               Filter: (a = 1)
(12 rows)

--
-- pruning with clauses containing <> operator
--
-- doesn't prune range partitions
create table rp (a int) partition by range (a);
create table rp0 partition of rp for values from (minvalue) to (1);
create table rp1 partition of rp for values from (1) to (2);
create table rp2 partition of rp for values from (2) to (maxvalue);
explain (costs off) select * from rp where a <> 1;
        QUERY PLAN        
--------------------------
 Append
   ->  Seq Scan on rp0
         Filter: (a <> 1)
   ->  Seq Scan on rp1
         Filter: (a <> 1)
   ->  Seq Scan on rp2
         Filter: (a <> 1)
(7 rows)

explain (costs off) select * from rp where a <> 1 and a <> 2;
               QUERY PLAN                
-----------------------------------------
 Append
   ->  Seq Scan on rp0
         Filter: ((a <> 1) AND (a <> 2))
   ->  Seq Scan on rp1
         Filter: ((a <> 1) AND (a <> 2))
   ->  Seq Scan on rp2
         Filter: ((a <> 1) AND (a <> 2))
(7 rows)

-- null partition should be eliminated due to strict <> clause.
explain (costs off) select * from lp where a <> 'a';
             QUERY PLAN             
------------------------------------
 Append
   ->  Seq Scan on lp_ad
         Filter: (a <> 'a'::bpchar)
   ->  Seq Scan on lp_bc
         Filter: (a <> 'a'::bpchar)
   ->  Seq Scan on lp_ef
         Filter: (a <> 'a'::bpchar)
   ->  Seq Scan on lp_g
         Filter: (a <> 'a'::bpchar)
   ->  Seq Scan on lp_default
         Filter: (a <> 'a'::bpchar)
(11 rows)

-- ensure we detect contradictions in clauses; a can't be NULL and NOT NULL.
explain (costs off) select * from lp where a <> 'a' and a is null;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

explain (costs off) select * from lp where (a <> 'a' and a <> 'd') or a is null;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Append
   ->  Seq Scan on lp_bc
         Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))
   ->  Seq Scan on lp_ef
         Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))
   ->  Seq Scan on lp_g
         Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))
   ->  Seq Scan on lp_null
         Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))
   ->  Seq Scan on lp_default
         Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))
(11 rows)

-- check that it also works for a partitioned table that's not root,
-- which in this case are partitions of rlp that are themselves
-- list-partitioned on b
explain (costs off) select * from rlp where a = 15 and b <> 'ab' and b <> 'cd' and b <> 'xy' and b is not null;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on rlp3efgh
         Filter: ((b IS NOT NULL) AND ((b)::text <> 'ab'::text) AND ((b)::text <> 'cd'::text) AND ((b)::text <> 'xy'::text) AND (a = 15))
   ->  Seq Scan on rlp3_default
         Filter: ((b IS NOT NULL) AND ((b)::text <> 'ab'::text) AND ((b)::text <> 'cd'::text) AND ((b)::text <> 'xy'::text) AND (a = 15))
(5 rows)

--
-- different collations for different keys with same expression
--
create table coll_pruning_multi (a text) partition by range (substr(a, 1) collate "POSIX", substr(a, 1) collate "C");
create table coll_pruning_multi1 partition of coll_pruning_multi for values from ('a', 'a') to ('a', 'e');
create table coll_pruning_multi2 partition of coll_pruning_multi for values from ('a', 'e') to ('a', 'z');
create table coll_pruning_multi3 partition of coll_pruning_multi for values from ('b', 'a') to ('b', 'e');
-- no pruning, because no value for the leading key
explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'e' collate "C";
                       QUERY PLAN                       
--------------------------------------------------------
 Append
   ->  Seq Scan on coll_pruning_multi1
         Filter: (substr(a, 1) = 'e'::text COLLATE "C")
   ->  Seq Scan on coll_pruning_multi2
         Filter: (substr(a, 1) = 'e'::text COLLATE "C")
   ->  Seq Scan on coll_pruning_multi3
         Filter: (substr(a, 1) = 'e'::text COLLATE "C")
(7 rows)

-- pruning, with a value provided for the leading key
explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'a' collate "POSIX";
                         QUERY PLAN                         
------------------------------------------------------------
 Append
   ->  Seq Scan on coll_pruning_multi1
         Filter: (substr(a, 1) = 'a'::text COLLATE "POSIX")
   ->  Seq Scan on coll_pruning_multi2
         Filter: (substr(a, 1) = 'a'::text COLLATE "POSIX")
(5 rows)

-- pruning, with values provided for both keys
explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'e' collate "C" and substr(a, 1) = 'a' collate "POSIX";
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on coll_pruning_multi2
         Filter: ((substr(a, 1) = 'e'::text COLLATE "C") AND (substr(a, 1) = 'a'::text COLLATE "POSIX"))
(3 rows)

--
-- LIKE operators don't prune
--
create table like_op_noprune (a text) partition by list (a);
create table like_op_noprune1 partition of like_op_noprune for values in ('ABC');
create table like_op_noprune2 partition of like_op_noprune for values in ('BCD');
explain (costs off) select * from like_op_noprune where a like '%BC';
             QUERY PLAN             
------------------------------------
 Append
   ->  Seq Scan on like_op_noprune1
         Filter: (a ~~ '%BC'::text)
   ->  Seq Scan on like_op_noprune2
         Filter: (a ~~ '%BC'::text)
(5 rows)

--
-- tests wherein clause value requires a cross-type comparison function
--
create table lparted_by_int2 (a smallint) partition by list (a);
create table lparted_by_int2_1 partition of lparted_by_int2 for values in (1);
create table lparted_by_int2_16384 partition of lparted_by_int2 for values in (16384);
explain (costs off) select * from lparted_by_int2 where a = 100000000000000;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

create table rparted_by_int2 (a smallint) partition by range (a);
create table rparted_by_int2_1 partition of rparted_by_int2 for values from (1) to (10);
create table rparted_by_int2_16384 partition of rparted_by_int2 for values from (10) to (16384);
-- all partitions pruned
explain (costs off) select * from rparted_by_int2 where a > 100000000000000;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

create table rparted_by_int2_maxvalue partition of rparted_by_int2 for values from (16384) to (maxvalue);
-- all partitions but rparted_by_int2_maxvalue pruned
explain (costs off) select * from rparted_by_int2 where a > 100000000000000;
                   QUERY PLAN                    
-------------------------------------------------
 Append
   ->  Seq Scan on rparted_by_int2_maxvalue
         Filter: (a > '100000000000000'::bigint)
(3 rows)

drop table lp, coll_pruning, rlp, mc3p, mc2p, boolpart, rp, coll_pruning_multi, like_op_noprune, lparted_by_int2, rparted_by_int2;
-- hash partitioning
create table hp (a int, b text) partition by hash (a, b);
create table hp0 partition of hp for values with (modulus 4, remainder 0);
create table hp3 partition of hp for values with (modulus 4, remainder 3);
create table hp1 partition of hp for values with (modulus 4, remainder 1);
create table hp2 partition of hp for values with (modulus 4, remainder 2);
insert into hp values (null, null);
insert into hp values (1, null);
insert into hp values (1, 'xxx');
insert into hp values (null, 'xxx');
insert into hp values (10, 'xxx');
insert into hp values (10, 'yyy');
select tableoid::regclass, * from hp order by 1;
 tableoid | a  |  b  
----------+----+-----
 hp0      |    | 
 hp0      |  1 | 
 hp0      |  1 | xxx
 hp3      | 10 | yyy
 hp1      |    | xxx
 hp2      | 10 | xxx
(6 rows)

-- partial keys won't prune, nor would non-equality conditions
explain (costs off) select * from hp where a = 1;
       QUERY PLAN        
-------------------------
 Append
   ->  Seq Scan on hp0
         Filter: (a = 1)
   ->  Seq Scan on hp1
         Filter: (a = 1)
   ->  Seq Scan on hp2
         Filter: (a = 1)
   ->  Seq Scan on hp3
         Filter: (a = 1)
(9 rows)

explain (costs off) select * from hp where b = 'xxx';
            QUERY PLAN             
-----------------------------------
 Append
   ->  Seq Scan on hp0
         Filter: (b = 'xxx'::text)
   ->  Seq Scan on hp1
         Filter: (b = 'xxx'::text)
   ->  Seq Scan on hp2
         Filter: (b = 'xxx'::text)
   ->  Seq Scan on hp3
         Filter: (b = 'xxx'::text)
(9 rows)

explain (costs off) select * from hp where a is null;
         QUERY PLAN          
-----------------------------
 Append
   ->  Seq Scan on hp0
         Filter: (a IS NULL)
   ->  Seq Scan on hp1
         Filter: (a IS NULL)
   ->  Seq Scan on hp2
         Filter: (a IS NULL)
   ->  Seq Scan on hp3
         Filter: (a IS NULL)
(9 rows)

explain (costs off) select * from hp where b is null;
         QUERY PLAN          
-----------------------------
 Append
   ->  Seq Scan on hp0
         Filter: (b IS NULL)
   ->  Seq Scan on hp1
         Filter: (b IS NULL)
   ->  Seq Scan on hp2
         Filter: (b IS NULL)
   ->  Seq Scan on hp3
         Filter: (b IS NULL)
(9 rows)

explain (costs off) select * from hp where a < 1 and b = 'xxx';
                   QUERY PLAN                    
-------------------------------------------------
 Append
   ->  Seq Scan on hp0
         Filter: ((a < 1) AND (b = 'xxx'::text))
   ->  Seq Scan on hp1
         Filter: ((a < 1) AND (b = 'xxx'::text))
   ->  Seq Scan on hp2
         Filter: ((a < 1) AND (b = 'xxx'::text))
   ->  Seq Scan on hp3
         Filter: ((a < 1) AND (b = 'xxx'::text))
(9 rows)

explain (costs off) select * from hp where a <> 1 and b = 'yyy';
                    QUERY PLAN                    
--------------------------------------------------
 Append
   ->  Seq Scan on hp0
         Filter: ((a <> 1) AND (b = 'yyy'::text))
   ->  Seq Scan on hp1
         Filter: ((a <> 1) AND (b = 'yyy'::text))
   ->  Seq Scan on hp2
         Filter: ((a <> 1) AND (b = 'yyy'::text))
   ->  Seq Scan on hp3
         Filter: ((a <> 1) AND (b = 'yyy'::text))
(9 rows)

-- pruning should work if non-null values are provided for all the keys
explain (costs off) select * from hp where a is null and b is null;
                  QUERY PLAN                   
-----------------------------------------------
 Append
   ->  Seq Scan on hp0
         Filter: ((a IS NULL) AND (b IS NULL))
(3 rows)

explain (costs off) select * from hp where a = 1 and b is null;
                QUERY PLAN                 
-------------------------------------------
 Append
   ->  Seq Scan on hp0
         Filter: ((b IS NULL) AND (a = 1))
(3 rows)

explain (costs off) select * from hp where a = 1 and b = 'xxx';
                   QUERY PLAN                    
-------------------------------------------------
 Append
   ->  Seq Scan on hp0
         Filter: ((a = 1) AND (b = 'xxx'::text))
(3 rows)

explain (costs off) select * from hp where a is null and b = 'xxx';
                     QUERY PLAN                      
-----------------------------------------------------
 Append
   ->  Seq Scan on hp1
         Filter: ((a IS NULL) AND (b = 'xxx'::text))
(3 rows)

explain (costs off) select * from hp where a = 10 and b = 'xxx';
                    QUERY PLAN                    
--------------------------------------------------
 Append
   ->  Seq Scan on hp2
         Filter: ((a = 10) AND (b = 'xxx'::text))
(3 rows)

explain (costs off) select * from hp where a = 10 and b = 'yyy';
                    QUERY PLAN                    
--------------------------------------------------
 Append
   ->  Seq Scan on hp3
         Filter: ((a = 10) AND (b = 'yyy'::text))
(3 rows)

explain (costs off) select * from hp where (a = 10 and b = 'yyy') or (a = 10 and b = 'xxx') or (a is null and b is null);
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on hp0
         Filter: (((a = 10) AND (b = 'yyy'::text)) OR ((a = 10) AND (b = 'xxx'::text)) OR ((a IS NULL) AND (b IS NULL)))
   ->  Seq Scan on hp2
         Filter: (((a = 10) AND (b = 'yyy'::text)) OR ((a = 10) AND (b = 'xxx'::text)) OR ((a IS NULL) AND (b IS NULL)))
   ->  Seq Scan on hp3
         Filter: (((a = 10) AND (b = 'yyy'::text)) OR ((a = 10) AND (b = 'xxx'::text)) OR ((a IS NULL) AND (b IS NULL)))
(7 rows)

-- hash partitiong pruning doesn't occur with <> operator clauses
explain (costs off) select * from hp where a <> 1 and b <> 'xxx';
                    QUERY PLAN                     
---------------------------------------------------
 Append
   ->  Seq Scan on hp0
         Filter: ((a <> 1) AND (b <> 'xxx'::text))
   ->  Seq Scan on hp1
         Filter: ((a <> 1) AND (b <> 'xxx'::text))
   ->  Seq Scan on hp2
         Filter: ((a <> 1) AND (b <> 'xxx'::text))
   ->  Seq Scan on hp3
         Filter: ((a <> 1) AND (b <> 'xxx'::text))
(9 rows)

drop table hp;
