--
-- Tests for PL/pgSQL handling of composite (record) variables
--
create type two_int4s as (f1 int4, f2 int4);
create type two_int8s as (q1 int8, q2 int8);
create type nested_int8s as (c1 two_int8s, c2 two_int8s);
-- base-case return of a composite type
create function retc(int) returns two_int8s language plpgsql as
$$ begin return row($1,1)::two_int8s; end $$;
select retc(42);
  retc  
--------
 (42,1)
(1 row)

-- ok to return a matching record type
create or replace function retc(int) returns two_int8s language plpgsql as
$$ begin return row($1::int8, 1::int8); end $$;
select retc(42);
  retc  
--------
 (42,1)
(1 row)

-- we don't currently support implicit casting
create or replace function retc(int) returns two_int8s language plpgsql as
$$ begin return row($1,1); end $$;
select retc(42);
ERROR:  returned record type does not match expected record type
DETAIL:  Returned type integer does not match expected type bigint in column 1.
CONTEXT:  PL/pgSQL function retc(integer) while casting return value to function's return type
-- nor extra columns
create or replace function retc(int) returns two_int8s language plpgsql as
$$ begin return row($1::int8, 1::int8, 42); end $$;
select retc(42);
ERROR:  returned record type does not match expected record type
DETAIL:  Number of returned columns (3) does not match expected column count (2).
CONTEXT:  PL/pgSQL function retc(integer) while casting return value to function's return type
-- same cases with an intermediate "record" variable
create or replace function retc(int) returns two_int8s language plpgsql as
$$ declare r record; begin r := row($1::int8, 1::int8); return r; end $$;
select retc(42);
  retc  
--------
 (42,1)
(1 row)

create or replace function retc(int) returns two_int8s language plpgsql as
$$ declare r record; begin r := row($1,1); return r; end $$;
select retc(42);
ERROR:  returned record type does not match expected record type
DETAIL:  Returned type integer does not match expected type bigint in column 1.
CONTEXT:  PL/pgSQL function retc(integer) while casting return value to function's return type
create or replace function retc(int) returns two_int8s language plpgsql as
$$ declare r record; begin r := row($1::int8, 1::int8, 42); return r; end $$;
select retc(42);
ERROR:  returned record type does not match expected record type
DETAIL:  Number of returned columns (3) does not match expected column count (2).
CONTEXT:  PL/pgSQL function retc(integer) while casting return value to function's return type
-- but, for mostly historical reasons, we do convert when assigning
-- to a named-composite-type variable
create or replace function retc(int) returns two_int8s language plpgsql as
$$ declare r two_int8s; begin r := row($1::int8, 1::int8, 42); return r; end $$;
select retc(42);
  retc  
--------
 (42,1)
(1 row)

do $$ declare c two_int8s;
begin c := row(1,2); raise notice 'c = %', c; end$$;
NOTICE:  c = (1,2)
do $$ declare c two_int8s;
begin for c in select 1,2 loop raise notice 'c = %', c; end loop; end$$;
NOTICE:  c = (1,2)
do $$ declare c4 two_int4s; c8 two_int8s;
begin
  c8 := row(1,2);
  c4 := c8;
  c8 := c4;
  raise notice 'c4 = %', c4;
  raise notice 'c8 = %', c8;
end$$;
NOTICE:  c4 = (1,2)
NOTICE:  c8 = (1,2)
do $$ declare c two_int8s; d nested_int8s;
begin
  c := row(1,2);
  d := row(c, row(c.q1, c.q2+1));
  raise notice 'c = %, d = %', c, d;
  c.q1 := 10;
  d.c1 := row(11,12);
  d.c2.q2 := 42;
  raise notice 'c = %, d = %', c, d;
  raise notice 'c.q1 = %, d.c2 = %', c.q1, d.c2;
  raise notice '(d).c2.q2 = %', (d).c2.q2;  -- doesn't work without parens
  raise notice '(d.c2).q2 = %', (d.c2).q2;  -- doesn't work without parens
end$$;
NOTICE:  c = (1,2), d = ("(1,2)","(1,3)")
NOTICE:  c = (10,2), d = ("(11,12)","(1,42)")
NOTICE:  c.q1 = 10, d.c2 = (1,42)
NOTICE:  (d).c2.q2 = 42
NOTICE:  (d.c2).q2 = 42
-- block-qualified naming
do $$ <<b>> declare c two_int8s; d nested_int8s;
begin
  b.c := row(1,2);
  b.d := row(b.c, row(b.c.q1, b.c.q2+1));
  raise notice 'b.c = %, b.d = %', b.c, b.d;
  b.c.q1 := 10;
  b.d.c1 := row(11,12);
  b.d.c2.q2 := 42;
  raise notice 'b.c = %, b.d = %', b.c, b.d;
  raise notice 'b.c.q1 = %, b.d.c2 = %', b.c.q1, b.d.c2;
  raise notice '(b.d).c2.q2 = %', (b.d).c2.q2;  -- doesn't work without parens
  raise notice '(b.d.c2).q2 = %', (b.d.c2).q2;  -- doesn't work without parens
end$$;
NOTICE:  b.c = (1,2), b.d = ("(1,2)","(1,3)")
NOTICE:  b.c = (10,2), b.d = ("(11,12)","(1,42)")
NOTICE:  b.c.q1 = 10, b.d.c2 = (1,42)
NOTICE:  (b.d).c2.q2 = 42
NOTICE:  (b.d.c2).q2 = 42
-- error cases
do $$ declare c two_int8s; begin c.x = 1; end $$;
ERROR:  record "c" has no field "x"
CONTEXT:  PL/pgSQL assignment "c.x = 1"
PL/pgSQL function inline_code_block line 1 at assignment
do $$ declare c nested_int8s; begin c.x = 1; end $$;
ERROR:  record "c" has no field "x"
CONTEXT:  PL/pgSQL assignment "c.x = 1"
PL/pgSQL function inline_code_block line 1 at assignment
do $$ declare c nested_int8s; begin c.x.q1 = 1; end $$;
ERROR:  record "c" has no field "x"
CONTEXT:  PL/pgSQL assignment "c.x.q1 = 1"
PL/pgSQL function inline_code_block line 1 at assignment
do $$ declare c nested_int8s; begin c.c2.x = 1; end $$;
ERROR:  cannot assign to field "x" of column "c" because there is no such column in data type two_int8s
LINE 1: c.c2.x = 1
        ^
QUERY:  c.c2.x = 1
CONTEXT:  PL/pgSQL function inline_code_block line 1 at assignment
do $$ declare c nested_int8s; begin d.c2.x = 1; end $$;
ERROR:  "d.c2.x" is not a known variable
LINE 1: do $$ declare c nested_int8s; begin d.c2.x = 1; end $$;
                                            ^
do $$ <<b>> declare c two_int8s; begin b.c.x = 1; end $$;
ERROR:  record "c" has no field "x"
CONTEXT:  PL/pgSQL assignment "b.c.x = 1"
PL/pgSQL function inline_code_block line 1 at assignment
do $$ <<b>> declare c nested_int8s; begin b.c.x = 1; end $$;
ERROR:  record "c" has no field "x"
CONTEXT:  PL/pgSQL assignment "b.c.x = 1"
PL/pgSQL function inline_code_block line 1 at assignment
do $$ <<b>> declare c nested_int8s; begin b.c.x.q1 = 1; end $$;
ERROR:  record "c" has no field "x"
CONTEXT:  PL/pgSQL assignment "b.c.x.q1 = 1"
PL/pgSQL function inline_code_block line 1 at assignment
do $$ <<b>> declare c nested_int8s; begin b.c.c2.x = 1; end $$;
ERROR:  cannot assign to field "x" of column "b" because there is no such column in data type two_int8s
LINE 1: b.c.c2.x = 1
        ^
QUERY:  b.c.c2.x = 1
CONTEXT:  PL/pgSQL function inline_code_block line 1 at assignment
do $$ <<b>> declare c nested_int8s; begin b.d.c2.x = 1; end $$;
ERROR:  "b.d.c2" is not a known variable
LINE 1: do $$ <<b>> declare c nested_int8s; begin b.d.c2.x = 1; end ...
                                                  ^
-- check passing composite result to another function
create function getq1(two_int8s) returns int8 language plpgsql as $$
declare r two_int8s; begin r := $1; return r.q1; end $$;
select getq1(retc(344));
 getq1 
-------
   344
(1 row)

select getq1(row(1,2));
 getq1 
-------
     1
(1 row)

do $$
declare r1 two_int8s; r2 record; x int8;
begin
  r1 := retc(345);
  perform getq1(r1);
  x := getq1(r1);
  raise notice 'x = %', x;
  r2 := retc(346);
  perform getq1(r2);
  x := getq1(r2);
  raise notice 'x = %', x;
end$$;
NOTICE:  x = 345
NOTICE:  x = 346
-- check assignments of composites
do $$
declare r1 two_int8s; r2 two_int8s; r3 record; r4 record;
begin
  r1 := row(1,2);
  raise notice 'r1 = %', r1;
  r1 := r1;  -- shouldn't do anything
  raise notice 'r1 = %', r1;
  r2 := r1;
  raise notice 'r1 = %', r1;
  raise notice 'r2 = %', r2;
  r2.q2 = r1.q1 + 3;  -- check that r2 has distinct storage
  raise notice 'r1 = %', r1;
  raise notice 'r2 = %', r2;
  r1 := null;
  raise notice 'r1 = %', r1;
  raise notice 'r2 = %', r2;
  r1 := row(7,11)::two_int8s;
  r2 := r1;
  raise notice 'r1 = %', r1;
  raise notice 'r2 = %', r2;
  r3 := row(1,2);
  r4 := r3;
  raise notice 'r3 = %', r3;
  raise notice 'r4 = %', r4;
  r4.f1 := r4.f1 + 3;  -- check that r4 has distinct storage
  raise notice 'r3 = %', r3;
  raise notice 'r4 = %', r4;
  r1 := r3;
  raise notice 'r1 = %', r1;
  r4 := r1;
  raise notice 'r4 = %', r4;
  r4.q2 := r4.q2 + 1;  -- r4's field names have changed
  raise notice 'r4 = %', r4;
end$$;
NOTICE:  r1 = (1,2)
NOTICE:  r1 = (1,2)
NOTICE:  r1 = (1,2)
NOTICE:  r2 = (1,2)
NOTICE:  r1 = (1,2)
NOTICE:  r2 = (1,4)
NOTICE:  r1 = <NULL>
NOTICE:  r2 = (1,4)
NOTICE:  r1 = (7,11)
NOTICE:  r2 = (7,11)
NOTICE:  r3 = (1,2)
NOTICE:  r4 = (1,2)
NOTICE:  r3 = (1,2)
NOTICE:  r4 = (4,2)
NOTICE:  r1 = (1,2)
NOTICE:  r4 = (1,2)
NOTICE:  r4 = (1,3)
-- fields of named-type vars read as null if uninitialized
do $$
declare r1 two_int8s;
begin
  raise notice 'r1 = %', r1;
  raise notice 'r1.q1 = %', r1.q1;
  raise notice 'r1.q2 = %', r1.q2;
  raise notice 'r1 = %', r1;
end$$;
NOTICE:  r1 = <NULL>
NOTICE:  r1.q1 = <NULL>
NOTICE:  r1.q2 = <NULL>
NOTICE:  r1 = <NULL>
do $$
declare r1 two_int8s;
begin
  raise notice 'r1.q1 = %', r1.q1;
  raise notice 'r1.q2 = %', r1.q2;
  raise notice 'r1 = %', r1;
  raise notice 'r1.nosuchfield = %', r1.nosuchfield;
end$$;
NOTICE:  r1.q1 = <NULL>
NOTICE:  r1.q2 = <NULL>
NOTICE:  r1 = <NULL>
ERROR:  record "r1" has no field "nosuchfield"
CONTEXT:  SQL expression "r1.nosuchfield"
PL/pgSQL function inline_code_block line 7 at RAISE
-- records, not so much
do $$
declare r1 record;
begin
  raise notice 'r1 = %', r1;
  raise notice 'r1.f1 = %', r1.f1;
  raise notice 'r1.f2 = %', r1.f2;
  raise notice 'r1 = %', r1;
end$$;
NOTICE:  r1 = <NULL>
ERROR:  record "r1" is not assigned yet
DETAIL:  The tuple structure of a not-yet-assigned record is indeterminate.
CONTEXT:  SQL expression "r1.f1"
PL/pgSQL function inline_code_block line 5 at RAISE
-- but OK if you assign first
do $$
declare r1 record;
begin
  raise notice 'r1 = %', r1;
  r1 := row(1,2);
  raise notice 'r1.f1 = %', r1.f1;
  raise notice 'r1.f2 = %', r1.f2;
  raise notice 'r1 = %', r1;
  raise notice 'r1.nosuchfield = %', r1.nosuchfield;
end$$;
NOTICE:  r1 = <NULL>
NOTICE:  r1.f1 = 1
NOTICE:  r1.f2 = 2
NOTICE:  r1 = (1,2)
ERROR:  record "r1" has no field "nosuchfield"
CONTEXT:  SQL expression "r1.nosuchfield"
PL/pgSQL function inline_code_block line 9 at RAISE
-- check repeated assignments to composite fields
create table some_table (id int, data text);
do $$
declare r some_table;
begin
  r := (23, 'skidoo');
  for i in 1 .. 10 loop
    r.id := r.id + i;
    r.data := r.data || ' ' || i;
  end loop;
  raise notice 'r = %', r;
end$$;
NOTICE:  r = (78,"skidoo 1 2 3 4 5 6 7 8 9 10")
-- check behavior of function declared to return "record"
create function returnsrecord(int) returns record language plpgsql as
$$ begin return row($1,$1+1); end $$;
select returnsrecord(42);
 returnsrecord 
---------------
 (42,43)
(1 row)

select * from returnsrecord(42) as r(x int, y int);
 x  | y  
----+----
 42 | 43
(1 row)

select * from returnsrecord(42) as r(x int, y int, z int);  -- fail
ERROR:  returned record type does not match expected record type
DETAIL:  Number of returned columns (2) does not match expected column count (3).
CONTEXT:  PL/pgSQL function returnsrecord(integer) while casting return value to function's return type
select * from returnsrecord(42) as r(x int, y bigint);  -- fail
ERROR:  returned record type does not match expected record type
DETAIL:  Returned type integer does not match expected type bigint in column 2.
CONTEXT:  PL/pgSQL function returnsrecord(integer) while casting return value to function's return type
-- same with an intermediate record variable
create or replace function returnsrecord(int) returns record language plpgsql as
$$ declare r record; begin r := row($1,$1+1); return r; end $$;
select returnsrecord(42);
 returnsrecord 
---------------
 (42,43)
(1 row)

select * from returnsrecord(42) as r(x int, y int);
 x  | y  
----+----
 42 | 43
(1 row)

select * from returnsrecord(42) as r(x int, y int, z int);  -- fail
ERROR:  returned record type does not match expected record type
DETAIL:  Number of returned columns (2) does not match expected column count (3).
CONTEXT:  PL/pgSQL function returnsrecord(integer) while casting return value to function's return type
select * from returnsrecord(42) as r(x int, y bigint);  -- fail
ERROR:  returned record type does not match expected record type
DETAIL:  Returned type integer does not match expected type bigint in column 2.
CONTEXT:  PL/pgSQL function returnsrecord(integer) while casting return value to function's return type
-- should work the same with a missing column in the actual result value
create table has_hole(f1 int, f2 int, f3 int);
alter table has_hole drop column f2;
create or replace function returnsrecord(int) returns record language plpgsql as
$$ begin return row($1,$1+1)::has_hole; end $$;
select returnsrecord(42);
 returnsrecord 
---------------
 (42,43)
(1 row)

select * from returnsrecord(42) as r(x int, y int);
 x  | y  
----+----
 42 | 43
(1 row)

select * from returnsrecord(42) as r(x int, y int, z int);  -- fail
ERROR:  returned record type does not match expected record type
DETAIL:  Number of returned columns (2) does not match expected column count (3).
CONTEXT:  PL/pgSQL function returnsrecord(integer) while casting return value to function's return type
select * from returnsrecord(42) as r(x int, y bigint);  -- fail
ERROR:  returned record type does not match expected record type
DETAIL:  Returned type integer does not match expected type bigint in column 2.
CONTEXT:  PL/pgSQL function returnsrecord(integer) while casting return value to function's return type
-- same with an intermediate record variable
create or replace function returnsrecord(int) returns record language plpgsql as
$$ declare r record; begin r := row($1,$1+1)::has_hole; return r; end $$;
select returnsrecord(42);
 returnsrecord 
---------------
 (42,43)
(1 row)

select * from returnsrecord(42) as r(x int, y int);
 x  | y  
----+----
 42 | 43
(1 row)

select * from returnsrecord(42) as r(x int, y int, z int);  -- fail
ERROR:  returned record type does not match expected record type
DETAIL:  Number of returned columns (2) does not match expected column count (3).
CONTEXT:  PL/pgSQL function returnsrecord(integer) while casting return value to function's return type
select * from returnsrecord(42) as r(x int, y bigint);  -- fail
ERROR:  returned record type does not match expected record type
DETAIL:  Returned type integer does not match expected type bigint in column 2.
CONTEXT:  PL/pgSQL function returnsrecord(integer) while casting return value to function's return type
-- check access to a field of an argument declared "record"
create function getf1(x record) returns int language plpgsql as
$$ begin return x.f1; end $$;
select getf1(1);
ERROR:  function getf1(integer) does not exist
LINE 1: select getf1(1);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
select getf1(row(1,2));
 getf1 
-------
     1
(1 row)

-- the context stack is different when debug_invalidate_system_caches_always
-- is set, so suppress context output
\set SHOW_CONTEXT never
select getf1(row(1,2)::two_int8s);
ERROR:  record "x" has no field "f1"
\set SHOW_CONTEXT errors
select getf1(row(1,2));
 getf1 
-------
     1
(1 row)

-- check behavior when assignment to FOR-loop variable requires coercion
do $$
declare r two_int8s;
begin
  for r in select i, i+1 from generate_series(1,4) i
  loop
    raise notice 'r = %', r;
  end loop;
end$$;
NOTICE:  r = (1,2)
NOTICE:  r = (2,3)
NOTICE:  r = (3,4)
NOTICE:  r = (4,5)
-- check behavior when returning setof composite
create function returnssetofholes() returns setof has_hole language plpgsql as
$$
declare r record;
  h has_hole;
begin
  return next h;
  r := (1,2);
  h := (3,4);
  return next r;
  return next h;
  return next row(5,6);
  return next row(7,8)::has_hole;
end$$;
select returnssetofholes();
 returnssetofholes 
-------------------
 (,)
 (1,2)
 (3,4)
 (5,6)
 (7,8)
(5 rows)

create or replace function returnssetofholes() returns setof has_hole language plpgsql as
$$
declare r record;
begin
  return next r;  -- fails, not assigned yet
end$$;
select returnssetofholes();
ERROR:  record "r" is not assigned yet
DETAIL:  The tuple structure of a not-yet-assigned record is indeterminate.
CONTEXT:  PL/pgSQL function returnssetofholes() line 4 at RETURN NEXT
create or replace function returnssetofholes() returns setof has_hole language plpgsql as
$$
begin
  return next row(1,2,3);  -- fails
end$$;
select returnssetofholes();
ERROR:  returned record type does not match expected record type
DETAIL:  Number of returned columns (3) does not match expected column count (2).
CONTEXT:  PL/pgSQL function returnssetofholes() line 3 at RETURN NEXT
-- check behavior with changes of a named rowtype
create table mutable(f1 int, f2 text);
create function sillyaddone(int) returns int language plpgsql as
$$ declare r mutable; begin r.f1 := $1; return r.f1 + 1; end $$;
select sillyaddone(42);
 sillyaddone 
-------------
          43
(1 row)

-- test for change of type of column f1 should be here someday;
-- for now see plpgsql_cache test
alter table mutable drop column f1;
-- the context stack is different when debug_invalidate_system_caches_always
-- is set, so suppress context output
\set SHOW_CONTEXT never
select sillyaddone(42);  -- fail
ERROR:  record "r" has no field "f1"
\set SHOW_CONTEXT errors
create function getf3(x mutable) returns int language plpgsql as
$$ begin return x.f3; end $$;
select getf3(null::mutable);  -- doesn't work yet
ERROR:  record "x" has no field "f3"
CONTEXT:  SQL expression "x.f3"
PL/pgSQL function getf3(mutable) line 1 at RETURN
alter table mutable add column f3 int;
select getf3(null::mutable);  -- now it works
 getf3 
-------
      
(1 row)

alter table mutable drop column f3;
-- the context stack is different when debug_invalidate_system_caches_always
-- is set, so suppress context output
\set SHOW_CONTEXT never
select getf3(null::mutable);  -- fails again
ERROR:  record "x" has no field "f3"
\set SHOW_CONTEXT errors
-- check behavior with creating/dropping a named rowtype
set check_function_bodies = off;  -- else reference to nonexistent type fails
create function sillyaddtwo(int) returns int language plpgsql as
$$ declare r mutable2; begin r.f1 := $1; return r.f1 + 2; end $$;
reset check_function_bodies;
select sillyaddtwo(42);  -- fail
ERROR:  type "mutable2" does not exist
LINE 1:  declare r mutable2; begin r.f1 := $1; return r.f1 + 2; end 
                   ^
QUERY:   declare r mutable2; begin r.f1 := $1; return r.f1 + 2; end 
CONTEXT:  compilation of PL/pgSQL function "sillyaddtwo" near line 1
create table mutable2(f1 int, f2 text);
select sillyaddtwo(42);
 sillyaddtwo 
-------------
          44
(1 row)

drop table mutable2;
-- the context stack is different when debug_invalidate_system_caches_always
-- is set, so suppress context output
\set SHOW_CONTEXT never
select sillyaddtwo(42);  -- fail
ERROR:  type "mutable2" does not exist
\set SHOW_CONTEXT errors
create table mutable2(f0 text, f1 int, f2 text);
select sillyaddtwo(42);
 sillyaddtwo 
-------------
          44
(1 row)

select sillyaddtwo(43);
 sillyaddtwo 
-------------
          45
(1 row)

-- check access to system columns in a record variable
create function sillytrig() returns trigger language plpgsql as
$$begin
  raise notice 'old.ctid = %', old.ctid;
  raise notice 'old.tableoid = %', old.tableoid::regclass;
  return new;
end$$;
create trigger mutable_trig before update on mutable for each row
execute procedure sillytrig();
insert into mutable values ('foo'), ('bar');
update mutable set f2 = f2 || ' baz';
NOTICE:  old.ctid = (0,1)
NOTICE:  old.tableoid = mutable
NOTICE:  old.ctid = (0,2)
NOTICE:  old.tableoid = mutable
table mutable;
   f2    
---------
 foo baz
 bar baz
(2 rows)

-- check returning a composite datum from a trigger
create or replace function sillytrig() returns trigger language plpgsql as
$$begin
  return row(new.*);
end$$;
update mutable set f2 = f2 || ' baz';
table mutable;
     f2      
-------------
 foo baz baz
 bar baz baz
(2 rows)

create or replace function sillytrig() returns trigger language plpgsql as
$$declare r record;
begin
  r := row(new.*);
  return r;
end$$;
update mutable set f2 = f2 || ' baz';
table mutable;
       f2        
-----------------
 foo baz baz baz
 bar baz baz baz
(2 rows)

--
-- Domains of composite
--
create domain ordered_int8s as two_int8s check((value).q1 <= (value).q2);
create function read_ordered_int8s(p ordered_int8s) returns int8 as $$
begin return p.q1 + p.q2; end
$$ language plpgsql;
select read_ordered_int8s(row(1, 2));
 read_ordered_int8s 
--------------------
                  3
(1 row)

select read_ordered_int8s(row(2, 1));  -- fail
ERROR:  value for domain ordered_int8s violates check constraint "ordered_int8s_check"
create function build_ordered_int8s(i int8, j int8) returns ordered_int8s as $$
begin return row(i,j); end
$$ language plpgsql;
select build_ordered_int8s(1,2);
 build_ordered_int8s 
---------------------
 (1,2)
(1 row)

select build_ordered_int8s(2,1);  -- fail
ERROR:  value for domain ordered_int8s violates check constraint "ordered_int8s_check"
CONTEXT:  PL/pgSQL function build_ordered_int8s(bigint,bigint) while casting return value to function's return type
create function build_ordered_int8s_2(i int8, j int8) returns ordered_int8s as $$
declare r record; begin r := row(i,j); return r; end
$$ language plpgsql;
select build_ordered_int8s_2(1,2);
 build_ordered_int8s_2 
-----------------------
 (1,2)
(1 row)

select build_ordered_int8s_2(2,1);  -- fail
ERROR:  value for domain ordered_int8s violates check constraint "ordered_int8s_check"
CONTEXT:  PL/pgSQL function build_ordered_int8s_2(bigint,bigint) while casting return value to function's return type
create function build_ordered_int8s_3(i int8, j int8) returns ordered_int8s as $$
declare r two_int8s; begin r := row(i,j); return r; end
$$ language plpgsql;
select build_ordered_int8s_3(1,2);
 build_ordered_int8s_3 
-----------------------
 (1,2)
(1 row)

select build_ordered_int8s_3(2,1);  -- fail
ERROR:  value for domain ordered_int8s violates check constraint "ordered_int8s_check"
CONTEXT:  PL/pgSQL function build_ordered_int8s_3(bigint,bigint) while casting return value to function's return type
create function build_ordered_int8s_4(i int8, j int8) returns ordered_int8s as $$
declare r ordered_int8s; begin r := row(i,j); return r; end
$$ language plpgsql;
select build_ordered_int8s_4(1,2);
 build_ordered_int8s_4 
-----------------------
 (1,2)
(1 row)

select build_ordered_int8s_4(2,1);  -- fail
ERROR:  value for domain ordered_int8s violates check constraint "ordered_int8s_check"
CONTEXT:  PL/pgSQL function build_ordered_int8s_4(bigint,bigint) line 2 at assignment
create function build_ordered_int8s_a(i int8, j int8) returns ordered_int8s[] as $$
begin return array[row(i,j), row(i,j+1)]; end
$$ language plpgsql;
select build_ordered_int8s_a(1,2);
 build_ordered_int8s_a 
-----------------------
 {"(1,2)","(1,3)"}
(1 row)

select build_ordered_int8s_a(2,1);  -- fail
ERROR:  value for domain ordered_int8s violates check constraint "ordered_int8s_check"
CONTEXT:  PL/pgSQL function build_ordered_int8s_a(bigint,bigint) while casting return value to function's return type
-- check field assignment
do $$
declare r ordered_int8s;
begin
  r.q1 := null;
  r.q2 := 43;
  r.q1 := 42;
  r.q2 := 41;  -- fail
end$$;
ERROR:  value for domain ordered_int8s violates check constraint "ordered_int8s_check"
CONTEXT:  PL/pgSQL function inline_code_block line 7 at assignment
-- check whole-row assignment
do $$
declare r ordered_int8s;
begin
  r := null;
  r := row(null,null);
  r := row(1,2);
  r := row(2,1);  -- fail
end$$;
ERROR:  value for domain ordered_int8s violates check constraint "ordered_int8s_check"
CONTEXT:  PL/pgSQL function inline_code_block line 7 at assignment
-- check assignment in for-loop
do $$
declare r ordered_int8s;
begin
  for r in values (1,2),(3,4),(6,5) loop
    raise notice 'r = %', r;
  end loop;
end$$;
NOTICE:  r = (1,2)
NOTICE:  r = (3,4)
ERROR:  value for domain ordered_int8s violates check constraint "ordered_int8s_check"
CONTEXT:  PL/pgSQL function inline_code_block line 4 at FOR over SELECT rows
-- check behavior with toastable fields, too
create type two_texts as (f1 text, f2 text);
create domain ordered_texts as two_texts check((value).f1 <= (value).f2);
create table sometable (id int, a text, b text);
-- b should be compressed, but in-line
insert into sometable values (1, 'a', repeat('ffoob',1000));
-- this b should be out-of-line
insert into sometable values (2, 'a', repeat('ffoob',100000));
-- this pair should fail the domain check
insert into sometable values (3, 'z', repeat('ffoob',100000));
do $$
declare d ordered_texts;
begin
  for d in select a, b from sometable loop
    raise notice 'succeeded at "%"', d.f1;
  end loop;
end$$;
NOTICE:  succeeded at "a"
NOTICE:  succeeded at "a"
ERROR:  value for domain ordered_texts violates check constraint "ordered_texts_check"
CONTEXT:  PL/pgSQL function inline_code_block line 4 at FOR over SELECT rows
do $$
declare r record; d ordered_texts;
begin
  for r in select * from sometable loop
    raise notice 'processing row %', r.id;
    d := row(r.a, r.b);
  end loop;
end$$;
NOTICE:  processing row 1
NOTICE:  processing row 2
NOTICE:  processing row 3
ERROR:  value for domain ordered_texts violates check constraint "ordered_texts_check"
CONTEXT:  PL/pgSQL function inline_code_block line 6 at assignment
do $$
declare r record; d ordered_texts;
begin
  for r in select * from sometable loop
    raise notice 'processing row %', r.id;
    d := null;
    d.f1 := r.a;
    d.f2 := r.b;
  end loop;
end$$;
NOTICE:  processing row 1
NOTICE:  processing row 2
NOTICE:  processing row 3
ERROR:  value for domain ordered_texts violates check constraint "ordered_texts_check"
CONTEXT:  PL/pgSQL function inline_code_block line 8 at assignment
-- check coercion of a record result to named-composite function output type
create function compresult(int8) returns two_int8s language plpgsql as
$$ declare r record; begin r := row($1,$1); return r; end $$;
create table two_int8s_tab (f1 two_int8s);
insert into two_int8s_tab values (compresult(42));
-- reconnect so we lose any local knowledge of anonymous record types
\c -
table two_int8s_tab;
   f1    
---------
 (42,42)
(1 row)

