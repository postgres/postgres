<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso8859-9">
	<title>PostgreSQL Sýkça Sorulan Sorular - Türkçe</title>
	<style type="text/css"><!--
	body { background: #FFFFFF; }
	a:link { color: #ff0000; }
	a:active { color: #0000ff; }
	a:visited { color: #a00000; }
	i { font-style: oblique; }
	body, h1, h2, h4, ul, p, a { font-family: helvetica, arial, sans-serif; font-size: medium; color: black; }
	pre { color: #5C5C5C; padding-left: 30px; }
	.fixme { color: cyan; }
	--></style>
</head>
<body bgcolor="#ffffff" text="#000000" link="#ff0000" vlink="#a00000" alink="#0000ff">

<h1>PostgreSQL için Sýkça Sorulan Sorular (SSS)</h1>
<p>Son güncelleme : 15 Kasým 2004 Pazartesi - 15:03:23</p>
<p>Current maintainer: Bruce Momjian
(<a href="mailto:pgman@candle.pha.pa.us">pgman@candle.pha.pa.us</a>)<br></p>
<p>Çevirenler : Devrim Gündüz (<a href="mailto:devrim@tdmsoft.com">devrim@tdmsoft.com</a>)<br>Nicolai Tufar 
(<a href="mailto:ntufar@tdmsoft.com">ntufar@tdmsoft.com</a>)<BR>Volkan YAZICI (<a href="mailto:volkany@phreaker.net">volkany@phreaker.net</a>)</p>
<p>Bu belgenin en güncel hali, <a href="http://www.postgresql.org/docs/faqs/FAQ_turkish.html">http://www.PostgreSQL.org/docs/faqs/FAQ_turkish.html</a> 
ve <a href="http://www.gunduz.org/seminer/pg/FAQ_turkish.html">http://www.gunduz.org/seminer/pg/FAQ_turkish.html</a> 
adreslerinde görülebilir.</p>
<p>Platforma özel sorularýnýz, <a href="http://www.postgresql.org/docs/index.html">http://www.PostgreSQL.org/docs/index.html</a> adresinde yanýtlanýr.</p>

<hr>

<h2 align="center">Genel Sorular</h2>
	<a href="#1.1">1.1</a>) PostgreSQL nedir? Nasýl okunur?<br>
	<a href="#1.2">1.2</a>) PostgreSQL'in haklarý nedir?<br>
	<a href="#1.3">1.3</a>) PostgreSQL, hangi Unix platformlarýnda çalýþýr?<br>
	<a href="#1.4">1.4</a>) Hangi Unix olmayan uyarlamalarý bulunmaktadýr?<br>
	<a href="#1.5">1.5</a>) PostgreSQL'i nereden indirebilirim?<br>
	<a href="#1.6">1.6</a>) Desteði nereden alabilirim?<br>
	<a href="#1.7">1.7</a>) En son sürümü nedir?<br>
	<a href="#1.8">1.8</a>) Hangi belgelere ulaþabilirim?<br>
	<a href="#1.9">1.9</a>) Bilinen hatalar ya da eksik özelliklere nereden ulasabilirim?<br>
	<a href="#1.10">1.10</a>) Nasýl <small>SQL</small> öðrenebilirim?<br>
	<a href="#1.11">1.11</a>) PostgreSQL 2000 yýlýna uyumlu mudur?<br>
	<a href="#1.12">1.12</a>) Geliþtirme takýmýna nasýl katýlabilirim??<br>
	<a href="#1.13">1.13</a>) Bir hata raporunu nasýl gönderebilirim?<br>
	<a href="#1.14">1.14</a>) PostgreSQL, diðer <small>VTYS(DBMS)</small> lerle nasýl
	karþýlaþtýrýlabilir?<br>
	<a href="#1.15">1.15</a>) PostgreSQL'e maddi açýdan nasýl destek olabilirim?<br>
	
<h2 align="center">Kullanýcý/istemci Sorularý</h2>
	<a href="#2.1">2.1</a>) PostgreSQL için <i>ODBC</i> sürücüleri var mý?<br>
	<a href="#2.2">2.2</a>) PostgreSQL'i web sayfalarýnda kullanabilmek için
	hangi araçlar bulunmaktadýr?<br>
	<a href="#2.3">2.3</a>) PostgreSQL'in grafik kullanýcý arabirimi var mýdýr?<br>
	<a href="#2.4">2.4</a>) PostgreSQL ile iletiþimi kurabilmek için
	hangi dilleri kullanabilirim? <br>
	
<h2 align="center">Yönetimsel Sorular</h2>
	<a href="#3.1">3.1</a>) PostgreSQL'i <code>/usr/local/pgsql</code> dizininden
	baþka dizinlere nasýl kurabilirim?<br>
	<a href="#3.2">3.2</a>) <i>Postmaster</i>'ý baþlattýðýmda <code>Bad System Call</code>
	ya da <code>core dumped</code> mesajý alýyorum. Neden?<br>
	<a href="#3.3">3.3</a>) <i>Postmaster</i>'ý baþlattýðýmda, <code>IpcMemoryCreate</code>
	hatasý alýyorum. Neden?<br>
	<a href="#3.4">3.4</a>) <i>Postmaster</i>'ý, baþlattýðýmda, <code>IpcSemaphoreCreate</code>
	hatasý alýyorum. Neden?<br>
	<a href="#3.5">3.5</a>) Diðer bilgisayarlarýn benim PostgreSQL veritabaný
	sunucuma baðlantýlarýný nasýl kontrol edebilirim?<br>
	<a href="#3.6">3.6</a>) Veritabaný motorunu daha iyi baþarým icin nasýl ayarlayabilirim?<br>
	<a href="#3.7">3.7</a>) Hangi hata ayýklama özellikleri bulunmaktadýr?<br>
	<a href="#3.8">3.8</a>) Baðlanmaya çalýþýrken, neden "<code>Sorry, too many clients</code>"
	hatasýný alýyorum. Neden?<br>
	<a href="#3.9">3.9</a>) <code>pgsql_tmp</code>dizinin içindeki dosyalar nelerdir?<br>
	<a href="#3.10">3.10</a>) PostgreSQL sürümlerini yükseltmek için neden bir
	<code>dump/reload</code> iþlemi gerçekleþtirmek zorundayým?<br>
	<a href="#3.11">3.11</a>) Nasýl bir donaným kullanmalýyým?br>
	
<h2 align="center">Ýþletimsel Sorular</h2>
	<a href="#4.1">4.1</a>) <i>Binary cursor</i> ve <i>normal cursor</i> arasýndaki fark nedýr?<br>
	<a href="#4.2">4.2</a>) Sorgunun sadece ilk birkaç satýrýný nasýl
	<code>SELECT</code> edebilirim?<br>
	<a href="#4.3">4.3</a>) <i>psql</i>'in içinde gördügüm tablolarýn ya da diðer
	þeylerin listesini nasýl alabilirim?<br>
	<a href="#4.4">4.4</a>) Bir tablodan bir kolonu nasýl kaldýrabilirim?<br>
	<a href="#4.5">4.5</a>) Bir satýr, tablo ve veritabaný için en fazla büyüklük nedir?<br>
	<a href="#4.6">4.6</a>) Tipik bir metin dosyasýndaki veriyi saklamak için ne
	kadar disk alaný gereklidir?<br>
	<a href="#4.7">4.7</a>) Veritabanýnda hangi tablo ya da <i>index</i>'lerin
	tanýmlandýðýný nasýl görebilirim?<br>
	<a href="#4.8">4.8</a>) Sorgularým cok yavaþ, ya da <i>index</i>'lerimi kullanmýyorlar. Neden?<br>
	<a href="#4.9">4.9</a>) <i>Query-optimizer</i>'ýn sorgularýmý nasýl deðerlendirdiðini,
	iþleme soktuðunu nasýl görebilirim?<br>
	<a href="#4.10">4.10</a>) <i>R-tree index</i> nedir?<br>
	<a href="#4.11">4.11</a>) <i>Genetic Query Optimizer</i> nedir?<br>
	<a href="#4.12">4.12</a>) Düzenli ifade (<i>Regular Expression</i>) aramalarýný
	ve büyük/küçük harfe duyarsýz aramalarý nasýl yapabilirim? Bu büyük/küçük harfe duyarlý
	aramalar için <i>index</i>'i nasýl kullanabilirim?<br>
	<a href="#4.13">4.13</a>) Bir sorguda, bir alanýn <code>NULL</code> olduðunu nasýl
	ortaya çýkarabilirim?<br>
	<a href="#4.14">4.14</a>) Çesitli karakter tipleri arasýndaki farklar nelerdir?<br>
	<a href="#4.15.1">4.15.1</a>) Nasýl <code>serial</code>/otomatik artan
	(<i>auto-incrementing</i>) bir alan yaratabilirim?<br>
	<a href="#4.15.2">4.15.2</a>) <code>Serial</code> giriþinin deðerini nasýl alabilirim?<br>
	<a href="#4.15.3">4.15.3</a>) <code>currval()</code> ve  <code>nextval()</code>
	diðer kullanýcýlara sorun yaratmaz mý?<br>
	<a href="#4.15.4">4.15.4</a>) Neden sequence sayýlarýn <i>transaction</i>
	iþleminin iptalinden sonra yeniden kullanýlýyor? Neden <code>sequence/SERIAL</code>
	kolonumdaki sayýlarda atlamalar oluyor?<br>
	<a href="#4.16">4.16</a>) <code>OID</code> nedir? <code>TID</code> nedir?<br>
	<a href="#4.17">4.17</a>) PostgreSQL' de kullanýlan bazý terimlerin anlamlarý nelerdir?<br>
	<a href="#4.18">4.18</a>) Neden "<code>ERROR: Memory exhausted in AllocSetAlloc()</code>"
	hatasýný alýyorum?<br>
	<a href="#4.19">4.19</a>) Hangi PostgreSQL sürümünü çalýstýrdýðýmý nasýl görebilirim?<br>
	<a href="#4.20">4.20</a>) Neden <i>large-object</i> iþlemlerim, "<code>invalid large
	obj descriptor</code>" hatasýný veriyor?<br>
	<a href="#4.21">4.21</a>) Þu andaki zamaný öntanýmlý deðer olarak kabul
	eden kolonu nasýl yaratýrým?<br>
	<a href="#4.22">4.22</a>) Neden <code>IN</code> kullanan <i>subquery</i>'lerim çok yavaþ?<br>
	<a href="#4.23">4.23</a>) <i>Outer join</i> iþlemini nasýl yapabilirim?<br>
	<a href="#4.24">4.24</a>) Ayný anda birden fazla veritabanýnda nasýl iþlem yapabilirim?<br>
	<a href="#4.25">4.25</a>) Bir fonksiyondan nasýl çoklu satýr ya da kolon döndürebilirim?<br>
	<a href="#4.26">4.26</a>) Neden Pl/PgSQL fonksiyonlarý içinden güvenli
	bir þekilde tablo yaratma/kaldýrma iþlemlerini yapamýyoruz?<br>
	<a href="#4.27">4.27</a>) Hangi þifreleme seçenekleri bulunmaktadýr?<br>
	

<h2 align="center">PostgreSQL Özelliklerini Geniþletmek</h2>
	<a href="#5.1">5.1</a>) Kullanýcý-tanýmlý bir fonksiyon yazdým. <i>psql</i>'de
	çalýþtýrdýðým zaman neden <code>core dump</code> ediyor?<br>
	<a href="#5.2">5.2</a>) PostgreSQL'e nasýl yeni veri tipleri/fonksiyonlar ekleyebilirim?<br>
	<a href="#5.3">5.3</a>) Bir tuple döndürmek için bir C fonksiyonunu nasýl yazarým?<br>
	<a href="#5.4">5.4</a>) Bir kaynak dosyasýnda deðiþiklik yaptým.
	Yeniden derlememe raðmen deðiþiklik geçerli olmuyor. Neden?<br>
	
    <hr>

	<h2 align="center">Genel Sorular</h2>

		<h4><a name="1.1">1.1</a>) PostgreSQL nedir? Nasýl okunur?</h4>
		<p>PostgreSQL, <i>Post-Gres-Q-L</i>. olarak okunur</p>
		<p>PostgreSQL, yeni-nesil <small>VTYS</small> araþtýrma prototipi olan POSTGRES
		veritabaný yönetim sisteminin geliþtirilmesidir. POSTGRES'in zengin veri tiplerini ve
		güçlü veri modelini tutarken, <small>SQL</small>'in geliþtirilmiþ alt kümesi 
		olan PostQuel dilini kullanýr. PostgreSQL ücretsizdir ve kaynak kodu açýk daðýtýlýr.</p>
		<p>PostgreSQL, PostgreSQL geliþtirme listesine üye olan bir Internet geliþtirici
		takýmý tarafýndan geliþtirilir. Þu andaki koordinatör, Marc G. Fournier 
		(<a href="mailto:scrappy@PostgreSQL.org">scrappy@PostgreSQL.org</a>). 
		(Bu takýma nasýl katýlacagýnýzý öðrenmek için <a href="#1.6">1.6</a> numaralý maddeyi
		okuyunuz.) Bu takým, tüm PostgreSQL geliþiminden sorumludur.</p>
		<p>PostgreSQL 1.01 sürümünün yazarlarý Andrew Yu ve Jolly Chen idi. Bunlarýn dýþýnda
		bir kaç kisi de uyarlama, hata ayýklama ve kodun geliþtirilmesi için çalýsmýþtý.
		PostgreSQL'in türediði orijinal Postgres kodu, lisans, lisansüstü ve akademisyenler
		tarafýndan, Professor Michael Stonebraker (University of California, Berkeley)
		koordinatörlügünde yazýlmýþtýr.</p>
		<p>Berkley'deki yazýlýmýn adý Postgres idi. <small>SQL</small> uyumluluðu
		1995'te eklenince, adý Postgres 95 oldu. 1996 yýlýnýn sonlarýnda adý
		PostgreSQL olarak deðiþtirildi.</p>
		
		<h4><a name="1.2">1.2</a>) PostgreSQL'in haklarý nedir?</h4>
		<p>PostgreSQL Data Base Management System</p>

                <P>Portions Copyright (c) 1996-2007, PostgreSQL Global Development Group
                Portions Copyright (c) 1994-6 Regents of the University of California</P>

		<p>Permission to use, copy, modify, and distribute this software
		and its documentation for any purpose, without fee, and without a
		written agreement is hereby granted, provided that the above
		copyright notice and this paragraph and the following two
		paragraphs appear in all copies.</p>
		<p>IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY
		PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
		DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS
		SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
		CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
		<p>THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
		WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
		OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
		SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE
		UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE,
		SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.</p>
		<p>Üstteki metin klasik açýk-kod lisansý olan BSD lisansýdýr. Kaynak kodun nasýl 
		kullanýlabileceðine dair sýnýrlamalarý yoktur. Bu lisansý seviyoruz. Deðiþtirme 
		niyetimiz bulunmamaktadýr.</p>
		
		<h4><a name="1.3">1.3</a>) PostgreSQL, hangi Unix platforlarýnda çalýþýr?</h4>
		<p>Genel olarak, modern bir Unix-uyumlu platform PostgreSQL'i çalýþtýracaktýr.
		Ayrýntýlý bilgi için kurulum belgelerine bakabilirsiniz.</p>
		
		<h4><a name="1.4">1.4</a>) Hangi Unix olmayan uyarlamalarý bulunmaktadýr?</h4>
	        <P>PostgreSQL 8.0 sürümü ile , PostgreSQL artýk Win2000, WinXP ve Win2003 gibi Microsoft 
		Windows NT tabanlý iþletim sistemlerinde doðal olarak çalýþmaya baþlamýþtýr. Paketlenmiþ bir
		kurulum programý, <a href="http://pgfoundry.org/projects/pginstaller">http://pgfoundry.org/projects/pginstaller</a>. adresinden 
		indirilebilir.</P>

		<p>Ayrýca, http://forge.novell.com adresinde Novell Netware 6 portu bulunmaktadýr.</p>
		
		<h4><a name="1.5">1.5</a>) PostgreSQL'i nereden indirebilirim?</h4>
		<p>PostgreSQL için ana anonim ftp sitesi <i><a href="ftp://ftp.PostgreSQL.org/pub">ftp://ftp.PostgreSQL.org/pub</a></i>
		adresidir. Yansýlar için, ana web sayfamýza bakabilirsiniz.</p>
		
		<h4><a name="1.6">1.6</a>) Nereden destek alabilirim?</h4>
		<p>Ana e-posta listesi : pgsql-general@PostgreSQL.org. PostgreSQL konusundaki tartýþmalara
		açýktýr. Üye olmak için, aþaðýdaki satýrlarý e-postanýzýn <i>body</i> kýsmýna
		(konu kýsmýna deðil) yazýp, pgsql-general-request@PostgreSQL.org adresine gönderin:</p>
		<pre>subscribe<br>end</pre>
		<p>Ayný zamanda, bir <i>digest</i> listesi bulunmaktadýr. Bu listeye üye olmak için, 
		pgsql-general-digest-request@PostgreSQL.org adresine, body kýsmýnda</p>
		<pre>subscribe<br>end</pre>
		<p>yazan bir e-posta atmanýz yeterli olacaktýr.</p>
		<p><i>Digest</i> postalar, ana liste 30k civarýnda e-postaya ulaþtýðýnda
		üyelere gönderilmektedir.</p>
		<p><i>Bug</i>'lar için bir e-posta listesi bulunmaktadýr. Bu listeye üye olmak için,
		pgsql-bugs-request@PostgreSQL.org adresine, <i>body</i> kýsmýnda</p>
		<pre>subscribe<br>end</pre>
		<p>yazan bir e-posta atmanýz yeterli olacaktýr.</p>
		<p>Ayný zamanda, geliþtiriciler için tartýþma listesi bulunmaktadýr. Bu listeye
		üye olmak için, pgsql-hackers-request@PostgreSQL.org adresine, body kýsmýnda</p>
		<pre>subscribe<br>end</pre>
		<p>yazan bir e-posta atmanýz yeterli olacaktýr.</p>
		<p>Bunun dýþýndaki e-posta listelerine ve PostgreSQL hakkýnda bilgiye, PostgreSQL WWW 
		ana sayfasýndan ulasabilirsiniz: <i><a href="http://www.PostgreSQL.org">http://www.PostgreSQL.org</a></i></p>
		<p>Ayný zamanda, EFNet üzerinde, <code>#PostgreSQL</code> adlý bir IRC kanalý
		bulunmaktadýr. Bunun için, <code>irc -c '#PostgreSQL' "$USER" irc.phoenix.net</code>
		Unix komutunu kullanabilirsiniz.</p>
		<p>Ticari destek veren firmalarýn listesine</p>
		<p><i><a href="http://www.postgresql.org/users-lounge/commercial-support.html">http://www.postgresql.org/users-lounge/commercial-support.html</a></i></p>
		<p>adresinden ulaþbilirsiniz.</p>
		
		<h4><a name="1.7">1.7</a>) En son sürüm nedir?</h4>
		<p>PostgreSQL'in son sürümü 7.4.6'dýr.</p>
		<p>Her 6-8 ayda <i>ana sürüm</i> çýkarýlmasý planlanmaktadýr.</p>

		<h4><a name="1.8">1.8</a>) Hangi belgelere ulaþabilirim?</h4>
		<p>Daðýtýmýn içinde, kitapçýklar, kitapçýk sayfalarý ve bazý küçük örnekler verilmektedir.
		<code>/doc</code> dizinine bakýnýz. Ayrýca, bu el kitapçýklarýný online olarak
		<i><a href="http://www.PostgreSQL.org/docs/">http://www.PostgreSQL.org/docs/</a></i> adresinden inceleyebilirsiniz.</p>
		<p><i><a href="http://www.PostgreSQL.org/docs/awbook.html">http://www.PostgreSQL.org/docs/awbook.html</a></i>
		ve <i><a href="http://www.commandprompt.com/ppbook">http://www.commandprompt.com/ppbook</a></i>
		adreslerinde PostgreSQL kitaplarý bulunmaktadýr. PostgreSQL kitablarýnýn listesine, 
		<i><a href="http://www.ca.PostgreSQL.org/books/">http://www.ca.PostgreSQL.org/books/</a></i> adresinden ulaþaiblirsiniz.
		Ayrýca, PostgreSQL konusundaki teknik makalelere de
		<i><a href="http://techdocs.PostgreSQL.org/">http://techdocs.PostgreSQL.org/</a></i> adresinden ulaþabilirsiniz.</p>
		<p>psql'in, \d ile baslayan veri tipler, operatorler, fonksiyonlar,
		<i>aggregate</i>'ler, vb. ile ilgili güzel komutlarý vardýr.</p>
		<p>Web sitemiz daha fazla belgeyi içermektedir.</p>
		
		<h4><a name="1.9">1.9</a>) Bilinen hatalar ya da eksik
		özelliklere nereden ulaþabilirim?</h4>
		<p>PostgreSQL SQL-92 uyumluluðu içindedir, standartlardan fazla da özellikleri
		bulunmaktadýr. Bilinen hatalar, eksik özellikler ve gelecek ile ilgili planlar için
		TODO listesine bakýnýz.</p>
		
		<h4><a name="1.10">1.10</a>) Nasýl <small>SQL</small> öðrenebilirim?</h4>
		<p><i><a href="http:/www.PostgreSQL.org/docs/awbook.html">http:/www.PostgreSQL.org/docs/awbook.html</a></i>
		adresindeki kitap SQL ögretecektir.
		<i><a href="http://www.commandprompt.com/ppbook">http://www.commandprompt.com/ppbook</a></i>
		adresinde de bir baska PostgreSQL kitabý bulunmaktadýr.</p>
		<p><i><a href="http://www.intermedia.net/support/sql/sqltut.shtm">http://www.intermedia.net/support/sql/sqltut.shtm</a></i>,
		<i><a href="http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM">http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM</a></i>
		<i><a href="http://sqlcourse.com">http://sqlcourse.com</a></i>
		ve <i><a href="http://sqlcourse2.com">http://sqlcourse2.com</a></i>
		adreslerinde de güzel belgeler bulunmaktadýr.</p>
		<p>Bir baþkasý da, <i><a href="http://members.tripod.com/er4ebus/sql/index.htm">http://members.tripod.com/er4ebus/sql/index.htm</a></i>
		adresinde bulunan "<i>Teach Yourself SQL in 21 Days, Second Edition</i>" kitabýdýr.</p>
		<p>Bazý kullanýcýlarýmýz da þu kitabý önermektedirler: "<i>The Practical SQL Handbook,
		Bowman, Judith S., et al.,Addison-Wesley</i>". Bazýlarý ise "<i>The Complete
		Reference SQL, Groff et al., McGraw-Hill</i>" kitabýný önermektedirler.</p>
		
		<h4><a name="1.11">1.11</a>) PostgreSQL 2000 yýlýna uyumlu mudur?</h4>
		<p>Evet.</p>
		
		<h4><a name="1.12">1.12</a>) Geliþtirme takýmýna nasýl katýlabilirim?</h4>
		<p>Öncelikle, en son kaynak kodunu indirin ve web sitemizdeki ya da daðýtýmýn içindeki
		PostgreSQL Developer belgesini okuyun. Ardýndan, pgsql-hackers ve pgsql-patches 
		listelerine üye olun. Üçüncü olarak da, pgsql-pacthes listesine yüksek kalitede 
		yamalar gönderin.</p>
		<p>PostgreSQL CVS arþivine eriþim izni olan, 10 kadar geliþtirici bulunmaktadýr.
		Hepsi defalarca, diðer kiþilerin yaptýðýndan çok daha yüksek-kaliteli yamalar 
		göndermiþlerdir. Ayrýca biz de bu geliþtiricilerin ekledikleri yamalarýn yüksek
		kalitede olduðuna güveniyoruz.</p>
		
		<h4><a name="1.13">1.13</a>) Bir hata raporunu nasýl gönderebilirim?</h4>
		<p>PostgreSQL BugTool sayfasýna gidiniz. O sayfada bir <i>bug</i> bildirmek
		için neleri yapmanýz gerektiði anlatýlmýþtýr.</p>
		<p>Ayrýca, <i><a href="ftp://ftp.PostgreSQL.org/pub">ftp://ftp.PostgreSQL.org/pub</a></i>
		ftp adresimizde, yeni bir PostgreSQL sürümü ya da yamasý olup olmadýðýni kontrol ediniz.</p>
		
		<h4><a name="1.14">1.14</a>) PostgreSQL, diger DBMS'lerle nasýl karþýlastýrýlabilir?</h4>
		<p>Bir yazýlýmýn gücünü ölçmek için çeþitli yollar vardýr: Yazýlýmýn özellikleri, 
		baþarýmý, güvenilirliði, desteði ve ücreti.</p>
		<p>Özellikler:</p>
		<p>PostgreSQL mevcut büyük ticari veritabanlarýnýn, <i>transaction</i>,
		<i>subselect</i>, <i>trigger</i>, <i>view</i>, <i>foreign key referential integrity</i>
		ve <i>sophisticated locking</i> gibi (<i>user-defined types</i>), <i>rules</i>,
		<i>inheritance</i> ve <i>lock</i> cakýþmalarýný düþürmek için <i>multi-version</i>
		uyumluluk özellikleri bulunmaktadýr.</p>
		<p>Performans (Baþarým):</p>
		<p>PostgreSQL, diðer ticari ve açýk kaynak kodlu veritabanlarýyla yakýn baþarýmý saðlar.
		Bazý açýlardan daha hýzlýdýr, diðer açýlardan da yavaþtýr. MySQL ya da daha zayýf 
		veritabanlarý ile karþýlaþtýrýldýðýnda, <code>INSERT/UPDATE</code> iþlemlerinde,
		<i>transaction</i> bazlý çalýstýðýmýz için daha yavaþýz. MySQL, yukarýdaki "özellikler"
		kýsmýnda belirtilenlerden hiç birine sahip deðildir. Biz, baþarýmýmýzý her sürümde
		arttýrsak da, esneklik ve geliþmiþ özellikler için yapýlanmýþ durumdayýz.
		PostgreSQL'i MySQL ile karþýlaþtýran þu web sitesine bakabilirsiniz:
		<i><a href="http://openacs.org/why-not-mysql.html">http://openacs.org/why-not-mysql.html</a></i></p>
		<p>Güvenilirlik:</p>
		<p><i>DBMS</i>'lerin güvenilir olmasý gerketiði, yoksa deðerleri olmayacaðýný düþünüyoruz.
		Çok iyi test edilmiþ, dengeli çalýsan minimum sayýda hata içeren kod sunmaya çalýþýyoruz.
		Her bir sürüm en az 1 aylýk beta testlerinden geçirilmektedir. Sürüm geçmiþine bakarsanýz,
		üretime hazýr, dengeli ve kararlý kodlar sunduðumuzu görebilirsiniz. Bu alanda, diðer 
		veritabaný yazýlýmlarýna üstünlüðümüz olduðuna inanmaktayýz.</p>
		<p>Destek:</p>
		<p>E-posta listemiz, oluþan herhangi bir sorunu çözebilecek büyük sayýda kullanýcý
		ve geliþtirici grubunu içerir. Sorununuz için, en az bir ticari veritabaný kadar
		rahat çözüm bulabilirsiniz. Gelistiricilere, kullanýcý grubuna, belgelere ve
		kaynak koda direk olarak eriþebilme, PostgreSQL desteðini, diðer <i>DBMS</i>'lere
		göre daha önemli kýlar. Gereksinimi olanlara, ticari destek verilebilir.
		(Destek için 1.6 bölümüne bakýnýz.)</p>
		<p>Fiyat:</p>
		<p>Ticari ve ticari olmayan tüm kullanýmlarýnýz için PostgreSQL ücretsizdir. Kodumuzu,
		yukarýda belirtilen BSD-stili lisanstaki sýnýrlamalar hariç, ürününüzün içine
		ekleyebilirsiniz.</p>
		
		<h4><a name="1.15">1.15</a>) PostgreSQL'e maddi açýdan nasýl destek olabilirim?</h4>
		<p>PostgreSQL, 1996 yýlýndan beri 1. sýnýf altyapýya sahiptir. Bunun için, yýllar
		boyu çalýþýp bu altyapýyý oluþturup yöneten Marc Fournier'e teþekkürler.</p>
		<p>Bir açýk kaynak kodlu proje için, kaliteli altyapý çok önemlidir. Bu altyapý,
		projenin kesilmesini önler ve projenin ilerlemesini hýzlandýrýr.</p>
		<p>Tabii ki bu altyapý ucuz deðildir. Ýþlerin yürümesi için çeþitli yýlýk ve anlýk 
		harcamalarýmýz olmaktadýr. Eðer siz ya da þirketinizin bu çabamýza baðýþta
		bulunabilecek parasý varsa, lütfen
		<i><a href="http://store.pgsql.com/">http://store.pgsql.com/</a></i>
		adresine gidiniz ve baðýþta, hibede bulununuz.</p>
		<p>Web sayfasýnýn 'PostgreSQL Inc.' den bahsetmesine raðmen, "katkýda bulunanlar" 
		(<i>contributors</i>) maddesi sadece PostgreSQL projesini desteklemek içindir ve
		belirli bir þirketin para kaynaðý deðildir. isterseniz, baðlantý adresine bir
		çek gönderebilirsiniz.</p>
		
		<hr>
		
	<h2 align="center">Kullanýcý/Ýstemci Sorularý</h2>
		
		<h4><a name="2.1">2.1</a>) PostgreSQL icin ODBC sürücüleri var mý?</h4>
		<p>iki tane ODBC sürücüsü bulunmaktadýr:  PsqlODBC ve OpenLink ODBC.</p>
		<p>PsqlODBC'i http://gborg.postgresql.org/project/psqlodbc/projdisplay.php adresinden 
		indirebilirsiniz.</p>
		<p>OpenLink ODBC http://www.openlinksw.com adresinden alýnabilir.Bu sürücü,
		kendi standart ODBC istemci yazýlýmý ile çalýstýðýndan, destekledikleri 
		her platformda (Win, Mac, Unix, VMS) PostgreSQL ODBC bulunmalidir.</p>
		<p>Ücretsiz sürümü olmakla beraber, ticari kalitede destek almak isteyenlere satmak isteyeceklerdir. 
		Sorularýnýzý lütfen postgres95@openlink.co.uk adresine gönderiniz.</p>
		
		<h4><a name="2.2">2.2</a>) PostgreSQL'i web sayfalarýnda kullanabilmek için hangi
		araçlar bulunmaktadýr?</h4>
		<p><i><a href="http://www.webreview.com/">http://www.webreview.com/</a></i> adresinde,
		arka planda veritabaný çalýstýran Web sayfalarý için giriþ seviyesinde bilgi bulunmaktadýr.</p>
		<p>Web ile bütünleþme için, PHP (<i><a href="http://www.php.net/"></a></i>)
		mükemmel bir arabirim sunar.</p>
		<p>Karmaþýk sorunlar için, çoðu kisi Perl arabirimini ve CGI.pm ya da mod_perl kullanýr.</p>
		
		<h4><a name="2.3">2.3</a>) PostgreSQL'in grafik kullanýcý arabirimi var mýdýr?</h4>
		<p>Çeþitli grafik arabirimlerimiz bulunmaktadýr. Bunlarýn arasýnda,
		PgAccess (<i><a href="http://www.pgaccess.org/">http://www.pgaccess.org/</a></i>),
		PgAdmin II (<i><a href="http://www.pgadmin.org/">http://www.pgadmin.org/</a></i>, sadece Win32 için),
		RHDB Admin (<i><a href="http://sources.redhat.com/rhdb/">http://sources.redhat.com/rhdb/</a></i>)
		ve Rekall (<i><a href="http://www.thekompany.com/products/rekall/">http://www.thekompany.com/products/rekall/</a></i>)
		bulunmaktadýr. Ayrýca, PostgreSQL için web tabanlý bir arabirim olan
		PHPPgAdmin (<i><a href="http://phppgadmin.sourceforge.net/">http://phppgadmin.sourceforge.net/</a></i>) bulunmaktadýr.</p>
		<p>Daha ayrýntýlý liste için
		<i><a href="http://techdocs.postgresql.org/guides/GUITools">http://techdocs.postgresql.org/guides/GUITools</a></i>
		adresine bakabilirsiniz.</p>
		
		<h4><a name="2.4">2.4</a>) PostgreSQL ile iletiþimi kurabilmek için hangi dilleri kullanabilirim?</h4>
		<ul><li>C (libpq)</li>
		<li>Embedded C (ecpg)</li>
		<li>Java (jdbc)</li>
		<li>Python (PyGreSQL)</li>
		<li>TCL (libpgtcl)</li></ul>
		<p>Diðerleri için, http://gborg.postgresql.org adresindeki Drivers/Interfaces bölümüne 
  		bakabilirsiniz.</p>
		
		<hr>
		
	<h2 align="center">Yönetimsel Sorular</h2>
		
		<h4><a name="3.1">3.1</a>) PostgreSQL'i, <code>/usr/local/pgsql</code> dizininden
		baþka dizinlere nasýl kurabilirim?</h4>
		<p><i>configure</i> betiðini çalýstýrýrken, <code>--prefix</code> seçeneðini veriniz.</p>
		
		<h4><a name="3.2">3.2</a>) postmaster'i baslattýgýmda, a Bad System Call ya da core dumped mesajý alýyorum. Neden?</h4>
		<p>Bunun birçok nedeni olabilir. Ancak ilk kontrol edilmesi gereken sey, çekirdeginize
		System V uzantýlarýnýn kurulu olup olmadýgýný kontrol etmek olabilir. PostgreSQL 
		shared memory ve semaphores için çekirdek destegine gereksinim duyar.</p>
		
		<h4><a name="3.3">3.3</a>) postmaster'i baþlattýðýmda, <code>ýpcMemoryCreate</code>
		hatasý alýyorum. Neden?</h4>
		<p>Ya çekirdeðinizde <i>shared memory</i> desteðiniz düzgünce yapýlandýrýlmamýþtýr,
		ya da çekirdeðinizdeki mevcut <i>shared memory</i> miktarýný büyütmeniz gerekecektir.
		Gereksinim duyacaðýnýz miktar, mimarinize ve postmaster için ayarladýgýnýz tampon
		ile <i>backend</i> iþlemi sayýsýna baðlýdýr. Tüm sistemler için, tamponlar ve
		iþlemlerde öntanýmlý sayýlarla, ~ 1MB kadar yere gereksinmeniz olacaktýr.
		<i><a href="http://www.postgresql.com/docs/7.3/interactive/admin.html">PostgreSQL
		7.3.2 Sistem Yöneticileri Rehberi</a></i>'ne, <i>shared memory</i> ve <i>semaphorelar</i>
		hakkýndaki ayrýntýlý bilgi için bakabilirsiniz.</p>
		
		<h4><a name="3.3">3.4</a>) postmaster'ý baþlattýðýmda,
		<code>ýpcSemaphoreCreate</code> hatasý alýyorum. Neden?</h4>
		<p>Eðer hata, "<code>ýpcSemaphoreCreate: semget failed (No space left on device)</code>"
		ise, çekirdeðiniz yeterli <i>semaphore</i> ile yapýlandýrýlmamýþ demektir. Postgres, her 
		bir potansiyel <i>backend</i> için bir <i>semaphore</i> gereksinimi duyar. Geçici
		bir çözüm, postmasterý <i>backend</i> iþlemleri için daha az miktarda sýnýrla
		baþlatmak olabilir. <code>-N</code>'i varsayýlan deðer olan 32'den küçük bir
		deðerle baþlatýnýz. Daha kalýcý bir çözüm, çekirdeðinizin <code>SEMMNS</code> ve
		<code>SEMMNI</code> parametrelerini yükseltmek olacaktýr.</p>
		<p>Çalýþmayan <i>semaphore</i>'lar aðýr veritabaný iþlemlerinde çökme yaratabilirler.</p>
		<p>Eðer hata mesajýnýz baþka bir þey ise, çekirdeðinizde <i>semaphore</i> desteðini 
		yapýlandýrmamýþ olabilirsiniz. <i>Shared memory</i> ve <i>semaphore</i>'lar hakkýndaki
		daha ayrýntýlý bilgi için
		<i><a href="http://www.postgresql.com/docs/7.3/interactive/admin.html">PostgreSQL
		7.3.2 Sistem Yöneticileri Rehberi</a></i>'ne bakabilirsiniz.</p>
		
		
		<h4><a name="3.5">3.5</a>) Diger bilgisayarlarýn benim PostgreSQL veritabaný
		sunucuma baðlantýlarýný nasýl kontrol edebilirim?</h4>
		<p>Ön tanýmlý olarak, PostgreSQL sadece yerel makineden <i>Unix domain sockets</i>
		kullanarak baðlanýlmasýna izin verir. Diger makineler, postmaster'a <code>-i</code>
		etiketini geçirmezseniz ve <code>$PGDATA/pg_hba.conf</code> dosyasýný düzenleyerek
		<i>host-based authentication</i>'a  olanak vermezseniz, baðlantý yapamayacaklardýr.</p>
		
		<h4><a name="3.6">3.6</a>) Veritabani motorunu daha iyi
		baþarým için nasýl ayarlayabilirim?</h4>
		<p><i>Index</i>'ler sorgularý hýzlandýrabilir. <code>EXPLAIN</code> komutu,
		PostgreSQL'in sorgunuzu nasýl yorumladýðýný ve hangi <i>index</i>'leri kullandýðýný
		görmenize izin verir.</p>
		<p>Eðer cok fazla <code>INSERT</code> iþlemi yapýyorsanýz, bunlarý büyük bir
		toplu iþlem dosyasýkullanýp <code>COPY</code> komutu ile veritabanýna girmeyi
		deneyiniz. Bu, tekil <code>INSERT</code>'lerden daha hýzlýdýr. Ýkinci olarak,
		<code>BEGIN WORK/COMMIT</code> <i>transaction</i> bloðu içinde olmayan ifadeler kendi 
		<i>transaction</i>'larýndaymýþ gibi düþünülür. Çoklu ifadeleri tek bir
		<i>transaction</i> bloðu içinde yapabilirsiniz. Bu, <i>transaction overhead</i>'ini
		düþürecektir. Tek bir <i>transaction</i> bloðu içinde birden çok ifadeyi çalýþtýrmayý 
		deneyebilirsiniz. Bu da ayný þekilde, <i>transaction overhead</i>'ini düþürür.</p>
		<p>Çeþitli ayarlama seçenekleri mevcuttur. <code>fsync()</code> iþlemini, postmaster'ý
		<code>-o -F</code> seçeneði ile baþlatarak devre dýþý býrakabilirsiniz. Bu iþlem,
		<code>fsync()</code>'lerin her <i>transactiondan</i> sonra diski <i>flush</i> etmesini
		engelleyecektir.</p>
		<p>Ayný zamanda, postmaster'i <code>-B</code> seçeneði ile baþlatýp, <i>backend</i>
		iþlemleri tarafýndan kullanýlan <i>shared memory buffers</i> sayýlarýný arttýrabilirsiniz.
		Eðer bu parametreyi çok yüksek tutarsanýz, çekirdeðinizin <i>shared memory</i>
		bölgesindeki limiti aþma olasýlýðýnýz yüzünden postmaster baþlayamayabilir. Her bir
		tampon (<i>buffer</i>) 8K'dýr. Öntanýmlý sayý ise 64 tampondur.</p>
		<p>Ayný þekilde, backend'in <code>-S</code> seçeneðini geçici sýralamalar için
		<i>backend</i> süreçleri tarafýndan kullanýlacak hafýzayý arttýrmak amacýyla
		kullanabilirsiniz. <code>-S</code> seçeneði kilobayt cinsinden deðer alýr ve ön
		tanýmlý deðeri 512'dir (512 K)</p>
		<p>Tablolardaki veriyi bir <i>index</i>'e eþlemek amacýyla gruplama için
		<code>CLUSTER</code> komutunu kullanabilirsiniz. Ayrýntýlý bilgi için
		<code>CLUSTER</code> komutunun yardým sayfasýna bakabilirsiniz.</p>
		
		<h4><a name="3.7">3.7</a>) Hangi hata ayýklama özellikleri bulunmaktadýr?</h4>
		<p>PostgreSQL, hata ayýklama amacýyla kullanýlabilecek durum bilgisi
		rapor eden çeþitli özeliklere sahiptir.</p>
		<p>Öncelikle, <i>configure</i> betiðini <code>--enable-cassert</code> seçeneðiyle
		çalýþtýrýrsanýz, bir çok <code>assert() backend</code> calýþmasýný gözlemler ve
		beklenmeyen bir durumda programý durdurur.</p>
		<p>Postmaster ve postgres çeþitli hata ayýklama seçeneklerine sahiptir. Öncelikle,
		postmaster'ý baþlattýðýnýzda, standart çýktýyý ve hatalarý bir log dosyasýna 
		yönlendirdiðinize emin olun:</p>
		<pre>cd /usr/local/pgsql<br>./bin/postmaster >server.log 2>&amp;1 &amp;</pre>
		<p>Bu iþlem PostgreSQL ana dizinine <code>server.log</code> dosyasý yerleþtirecektir.
		Bu dosya sunucunun yaþadýðý sorunlar ya da hatalar hakkýnda yararlý bilgiler içerir.
		<code>-d</code> seçeneði, hata ayýklama seviyesini belirten bir rakam ile kullanýlýr.
		Yüksek hata ayýklama seviyelerinin büyük log dosyalarý oluþturacaðýný unutmayýnýz.</p>
		<p>Eðer postmaster çalýþmýyorsa, <code>postgres backend</code>'ini komut satýrýndan
		çalýþtýrabilir ve SQL ifadenizi direk olarak yazabilirsiniz. Bu sadece hata ayýklama
		amacýyla önerilir. Burada, noktalý virgülün deðil de yeni bir satýrýn sorguyu
		sonlandýrdýðýný unutmayýnýz. Eðer hata ayýklama sembolleri ile derlediyseniz,
		ne olduðunu görmek için bir hata ayýklayýcý kullanabilirsiniz. <i>backend</i>
		postmaster'dan baþlatýlmadýðýndan, eþdeðer bir ortamda çalýþmamaktadýr ve
		<i>locking/backend</i> etkileþim sorunlarý artabilir.</p>
		<p>Eðer postmaster çalýþýyorsa, bir pencerede psql'i çalýþtýrýn ve psql tarafýndan
		kullanýlan postgres sürecinin süreç numarasýný (<code>PID</code>) bulun. Postgres
		süreci ile iliþkilendirmek için bir hata ayýklarýcý kullanýn. Sorgularý psql aracýlýðý
		ile çalýþtýrabilirsiniz. Eðer postgres baþlangýcýnda hata ayýklamak istiyorsanýz,
		<code>PGOPTIONS="-W n"</code> seçeneðini ayarlayabilir ve psql'i baþlatabilirsiniz.
		Bu iþlem, baþlangýcýn <code>n</code> saniye kadar gecikmesini saðlayacaktýr; böylece
		hata ayýklayýcýyý sürece iliþkilendirdikten sonra baþlangýç sürecinin devam etmesini 
		saðlayabilirsiniz.</p>
		<p>postgres programý hata ayýklama ve baþarým ölçümleri için <code>-s</code>,
		<code>-A</code> ve <code>-t</code> seçeneklerine sahiptir.</p>
		
		<h4><a name="3.8">3.8</a>) Baðlanmaya çalýþýrken, neden "<i>Sorry, too many
		clients</i>" hatasýný alýyorum?</h4>
		<p>Postmaster'ýn  eþzamanlý olarak baþlatabileceði <i>backend</i> süreçleri
		sýnýrlarýný arttýrmanýz gerekmektedir.</p>
		<p>Ön tanýmlý deðer 32 süreçtir. Bunu, postmaster'ý uygun <code>-N</code>
		deðeri ile ya da <code>postgresql.conf</code> dosyasýný düzenleyerek yeniden
		baþlatmakla arttýrabilirsiniz.</p>
		<p>Eðer <code>-N</code> deðerini 32'den büyük yapacaksanýz, ayný zamanda
		<code>-B</code> deðerini de deðiþtirmeniz gerektiðini unutmayýn. <code>-B</code>,
		<code>-N</code>'nin en az 2 katý kadar olmalýdýr; daha iyi baþarým için bu sayýyý daha
		da arttýrmalýsýnýz. Yüksek sayýdaki <i>backend</i> süreçleri için, çeþitli çekirdek
		yapýlandýrma parametrelerini arttýrmanýz gerekecektir. Yapýlmasý gerekenler,
		<code>SHMMAX</code>, <code>SEMMNS</code>, <code>SEMMNI</code>, <code>NPROC</code>,
		<code>MAXUPRC</code> ve açýlabilecek dosyalarýn maksimum sayýsý olan <code>NFILE</code>
		ve <code>NINODE</code> deðerlerini karýþtýrmaktýr. Bunun nedeni, PostgreSQL'in izin
		verilen <i>backend</i> süreçlerinin sayýsý üzerinde bir sýnýrý olmasýdýr. Böylelikle
		sistem kaynaklarýnýn dýþýna çýkýlmayacaktýr.</p>
		<p>PostgreSQL'in 6.5 sürümüne kadar, en fazla <i>backend</i> sayýsý 64 idi ve bunu
		deðiþtirmek için <code>include/storage/sinvaladt.h</code> dosyasý içindeki
		<code>MaxBAckendid</code> sabitini deðiþtirdek sonra yazýlýmý yeniden
		derlemek gerekiyordu.</p>
		
		<h4><a name="3.9">3.9</a>) <code>pgsql_tmp</code> dizinin içindeki dosyalar nelerdir?</h4>
		<p>Sorgu çalýstýrýcý (<i>query executer</i>) tarafýndan yaratýlan geçici dosyalardýr.
		Örnegin, bir sýralama <code>ORDER BY</code> ile yapýlacaksa ve sýralama
		<code>backend</code>'in <code>-s</code> parametresinin izin verdiðinden daha
		fazla alana gereksinim duyuyorsa, ekstra veriyi tutmak için geçici dosyalar yaratýlýr.</p>
		<p>Geçici dosyalar, eðer sýralama sýrasýnda <i>backend</i> göçmezse otomatik olarak
		silinecektir. Eðer çalýþan durumda bir <i>backend</i>'iniz yoksa,
		<code>pg_tempNNN.NN</code> dosyalarýný silmeniz güvenlidir.</p>
		
		<h4><a name="3.10">3.10</a>) PostgreSQL sürümlerini yükseltmek için neden bir
		dump/reload iþlemi gerçekleþtirmek zorundayým?</h4>
		<p>PostgreSQL takýmý ara sürümlerde sadece küçük deðiþiklikler yapmaktadýr;
		bu yüzden 7.2 sürümünden 7.2.1'e yükseltmek <i>dump/restore</i> iþlemi
		gerekmemektedir. Ancak, esas sürümlerde (örnek: 7.2'den 7.3'e) çoðunlukla sistem
		tablolarýnýn ve veri dosyalarýnýn iç yapýsý deðiþtirilir. Bu deðiþiklikler çoðunlukla
		karmaþýktýr; dolayýsýyla veri dosyalarýnýn geriye dönük uyumluluðu iþlemlerini
		yapmýyoruz. <i>Dump</i> iþlemi, veriyi genel biçimde alacaðýndan yeniden yükleme
		esnasýnda veri, yeni iç biçime uygun þekilde yerleþtirilecektir.</p>
		<p>Disk biçiminin deðiþmediði sürümlerde, <code>pg_upgrade</code> betiði güncellemenin
		bir <i>dump/restore</i> gerektirmeden yapýlmasýný saðlayacaktýr. <i>pg_upgrade</i>
		betiðinin o sürüm için bulunup bulunmadýðýný sürüm notlarý içinde bulabilirsiniz.</p>

		<h4><a name="3.11">3.11</a>) Nasýl bir donaným kullanmalýyým? </h4>
		<p> PC donanýmý tamamen uyumlu olduðu için, insanlar tüm PC donanýmlarýnýn ayný kalitede olduðunu 
		düþünürler. Oysa böyle deðildir. ECC RAM, SCSI ve kaliteli anakartlar daha ucuz donanýmlara göre daha 
		çok güvenilirlerdir ve baþarýmlarý daha yüksektir. PostgreSQL hemen hemen tüm donanýmda 
		çalýþabilmektedir, ancak güvenilirlik ve baþarým önemli ise donaným seçeneklerini çok iyi araþtýrmak 
		gereklidir. E-posta listelerimi donanýmlarla ilgili sorular ve de ticaret için kullanýlabilir.</p>

		<hr>
		
	<h2 align="center">Ýþletimsel Sorular</h2>
	
		<h4><a name="4.1">4.1</a>) <i>Binary cursor</i> ve <i>normal cursor</i>
		arasýndaki fark nedir?</h4>
		<p><code>DECLARE</code> yardým sayfasýna bakýnýz.</p>
		
		<h4><a name="4.2">4.2</a>) Sorgunun sadece ilk birkaç satýrýný
		nasýl <code>SELECT</code> edebilirim?</h4>
		<p><code>FETCH</code> yardým sayfasýna bakýnýz, ya da <code>SELECT</code> ...
		<code>LIMIT</code> ... kullanýnýz.</p>
		<p>Ýlk birkaç satýrý almak isteseniz bile, tüm sorgu deðerlendirilmek durumunda kalýnabilir. ORDER 
 		BY içeren bir sorgu düþünün. Eðer ORDER BY iþe eþleþen bir index varsa, PostgreSQL istenen ilk birkaç  
		satýrý iþleyebilir, ya da tüm sorgu istenen satýrlar üretilene kadar iþlenebilir. </p>
		
		<h4><a name="4.3">4.3</a>) psql'in içinde gördügüm tablolarýn ya da diðer
		þeylerin listesini nasýl alabilirim?</h4>
		<p><code>pgsql/src/bin/psql/describe.c</code> içindeki psql kaynak kodunu
		okuyabilirsiniz. Bu kod, psql'in <code>\</code> ile baþlayan komutlarýnýn
		çýktýsýný olusturan SQL komutlarýný içerir. Ayný zamanda, psql'i <code>-E</code>
		seçeneði ile baþlatýp, verdiðiniz komutlarý çalýþtýrmak için yaptýðý 
		sorgularýn çýktýlarýný görebilirsiniz.</p>
		
		<h4><a name="4.4">4.4</a>) Bir tablodan bir kolonu nasýl kaldýrabilirim?</h4>
		<p>Bu özellik (<code>ALTER TABLE DROP COLUMN</code>) 7.3 sürümü ile gelmiþtir.
		Eski sürümlerde aþaðýdakileri uygulamalýsýnýz: </p>
		<pre>
BEGIN;
LOCK TABLE old_table;
SELECT ...  -- select all columns but the one you want to remove
INTO TABLE new_table
FROM old_table;
DROP TABLE old_table;
ALTER TABLE new_table RENAME TO old_table;
COMMIT;		
		</pre>
		
		<h4><a name="4.5">4.5</a>) Bir satýr, tablo ve veritabaný için en
		fazla büyüklük nedir?</h4>
		<p>Sýnýrlar:</p>
		<p>Veritabaný için en fazla büyüklük nedir?<br>Sýnýrsýz (32 TB'lýk veritabaný bulunmaktadýr)<br><br>
		Bir tablo için en fazla büyüklük nedir?<br>32 TB<br><br>
		Bir satýr için en fazla büyüklük nedir?<br>1.6 TB<br><br>
		Bir alan için en fazla büyüklük nedir?<br>1 GB<br><br>
		Tabloda en fazla satýr sayýsý kaçtýr?<br>Sýnýrsýz<br><br>
		Bir tabloda olabilecek en fazla kolon sayýsý kaçtýr?<br>Kolon tiplerine baðlý olarak 250-1600<br><br>
		Bir tabloda olabilecek en fazla <i>index</i> sayýsý kaçtýr?<br>Sýnýrsýz</p>
		<p>Tabii ki bunlar aslýnda sýnýrsýz degildir. Burada belirtilen sýnýrlar, fiziksel
		sýnýrlarýn haricindeki sýnýrlardýr. Boþ disk alaný, hafýza/takas alaný na baðlý 
		sýnýrlamalar vardýr. Baþarým, sýnýr deðerlere yaklaþtýkça, ya da deðerler çok büyük 
		olduðunda düþebilir.</p>
		<p>Bir tablo için büyüklük sýnýrý olan 32 TB, iþletim sisteminin büyük dosya desteði olup
		olmamasýndan baðýmsýzdýr. Büyük tablolar, 1 GB'lik dosyalarda saklandýðý için, dosya 
		sistemi sýnýrlarýnin bir önemi yoktur.</p>
		<p>Tablo ve kolon sayýsý büyüklükleri, ön tanýmlý blok büyüklüðü 32k ya çýkarýlarak 
		arttýrýlabilir.</p>
		
		<h4><a name="4.6">4.6</a>) Tipik bir metin dosyasýndaki veriyi saklamak için ne
		kadar disk alaný gereklidir?</h4>
		<p>Bir PostgreSQL veritabaný, veriyi "<i>flat</i>" metin dosyasýnda saklamak için
		gereken alanýn 5 kat fazla disk alanýna gereksinim duyabilir.</p>
		<p>Her satýrýnda bir tamsayý ve metin (<i>text</i>) içeren, 100.000 satýrlýk bir
		dosya düþünün.  Her satýrýn ortalama 20 byte olduðunu farzedelim. Metin dosyasý
		2.8 MB olacaktýr. Bu veriyi tutan PostgreSQL veritabaný
		yaklaþýk 6.4 MB yer kaplayacaktýr.</p>
		<pre>
  36 byte: Her bir satýr baþlýðý (yaklaþýk)
+ 24 byte: Bir tamsayý (int) alaný ve bir metin (text) alaný 
+  4 byte: Sayfada tuple a pointer
----------------------------------------
  64 byte -> kayýt baþýna</pre>
		<p>PostgreSQL'de veri sayfasý (data page) büyüklüðü 8192 byte (8k)dýr, dolayýsýyla:</p>
		<pre>
8192 byte -> page baþýna
-------------------------  =  Her bir veritabaný <i>page</i>'ý baþýna 128 satýr (yaklaþýk)
  Satýr baþýna 64 byte
  
100000 veri satýrý
--------------------  =  782 veritabaný sayfasý
     128 satýr</pre>
		<p>782 veritabaný sayfasý <code>*</code> sayfa baþýna <code>8192 byte =
		6,406,144 bytes (6.4 MB)</code></p>
		<p><i>Index</i>'ler çok fazla yere gereksinim duymazlar, ama <i>index</i>'lenmiþ
		veriyi tutacaklarýndan büyük olabilirler.</p>
		<p><code>NULL</code> deðerler bitmapler içinde tutulur; dolayýsýyla çok az yer kaplarlar.</p>
		
		<h4><a name="4.7">4.7</a>) Veritabanýnda hangi tablo ya da <i>index</i>'lerin
		tanýmlandýðýný nasýl görebilirim?</h4>
		<p>psql, bu tür bilgileri göstermek için, <code>\</code> ile baþlayan bir çok
		komut sunmaktadýr. <code>\?</code> komutu ile bu komutlarý görebilirsiniz. Ayrýca,
		bunlarý açýklayan ve <code>pg_</code> ile baþlayan çok sayýda sistem tablosu
		bulunmaktadýr. Ayný zamanda, <code>psql -l</code> ile tüm veritabanlarýný
		listeyelebirsiniz.</p>
		<p>Ayrýca, <code>pgsql/src/tutorial/syscat.source</code> kodunu inceleyebilirsiniz.
		Bu dosya, veritabaný sistem dosyalarýndan bilgiyi almak için gereksinim duyulan
		bir çok <code>SELECT</code>'leri gösterir.</p>
		
		<h4><a name="4.8">4.8</a>) Sorgularým cok yavaþ, ya da <i>index</i>'lerimi
		kullanmýyorlar. Neden?</h4>
		<p>Indexler her sorgu tarafýndan otomatik olarak kullanýlmazlar. Indexler eðer bir 
		tablonun büyüklüðü minimum bir büyüklükten fazla ise ve sorgu tablodaki satýrlarýn sadece küçük bir 
		yüzdesini seçiyorsa kullanýlýr. Bunun nedeni, index eriþiminin neden olduðu raslansal disk eriþimi
		nin diskin ya da tablonun sýralý okunmasýndan daha yavas olabilmesidir.</p>

	 	<p>Bir index'in kullanýlýp kullanýlmayacaðýný belirlemek için, PostgreSQL tablo hakkýndaki 
		istatistiklere gereksinmesi vardýr. Bu istatistikler, <small>VACUUM ANALYZE</small> kullanýlarak
		toplanýrlar. Optimizer, istatistikleri kullanarak, tabloda kaç satýr olduðunu ve bilir ve indexin 
		kullanýlýp kullanýlmayacaðýna daha iyi karar verir. Istatistikler, ayný zamanda en uygun join 
		sýrasýný ve yöntemini belirlemekte çok önemlidir. Ýstatistik toplanmasý, tablo içerikleri 
		deðiþtikçe periyodik olarak yapýlmalýdýr.</p>
		

    <p>Indexler normalde <small>ORDER BY</small> sorgularý ya da join iþlemlerini gerçekleþtirmek için
    kullanýlmazlar. Açýk bir sýralamayý takip eden sýralý bir arama (sequential scan), büyük bir tabloda index
    aramasý yapmaktan genelde daha hýzlýdýr.</p>

    Ancak, <small>ORDER BY</small> ile birleþmiþ <small>LIMIT</small>
    genellikle bir index kullanacaktýr; çünkü tablonun sadece belirli bir miktarý döndürülecektir.
    Aslýnda, MAX() ve MIN() fonksiyonlarýnýn index kullanmamalarýndan dolayý, bu gibi deðerleri ORDER BY ve LIMIT 
    kullanarak da almak olasýdýr:
<pre>
    SELECT col
    FROM tab
    ORDER BY col [ DESC ]
    LIMIT 1;
</pre>

    <p>Eðer optimizer'ýn sýralý arama yapmasýnýn yanlýþ olduðuna inanýyorsanýz, <code>SET enable_seqscan TO 
'off'</code> kullanýn ve index kullanan aramalarýn hala daha hýzlý olup olmadýðýný görün.</p>

		<p><code>LIKE</code> ya da <code>~</code> gibi operatörler kullanýyorsanýz,
		<i>index</i>'ler sadece aþaðýdaki koþullarda kullanýlabilir:</p>

		<ul>
		<li>Arama dizininin baþý, dizinin baþý ile baðlanmalýdýr. Yani,
		<ul><li><code>LIKE</code> sorgularý <code>%</code> ile baþlamamalýdýr.</li>
		<li>Düzenli ifade sorgularý <code>^</code> iþe baþlamamalýdýr.</li></ul></li>
		<li>Arama metni bir karakter sýnýfý ile baþlayamaz. Örnek: <code>[a-e]</code></li>
		<li><code>ILIKE</code> ve <code>~*</code> gibi  büyük/küçük harfe duyarsýz
		aramalar <i>index</i>'lerden yararlanmazlar. Onun yerine, bölüm 4.12'de anlatýlan
		fonksiyonel <i>index</i>'leri kullanabilirsiniz.</li>
		<li><i>initdb</i> sýrasýnda öntanýmlý <i>C locale</i>'i kullanýlmalýdýr.</li>
		</ul>
		
		<h4><a name="4.9">4.9</a>) <i>query-optimizer</i>'ýn sorgularýmý nasýl
		deðerlendirdiðini, iþleme soktuðunu nasýl görebilirim?</h4>
		<p><code>EXPLAIN</code> yardým sayfasýna bakýnýz.</p>
		
		<h4><a name="4.10">4.10</a>) <i>R-tree index</i> nedir?</h4>
		<p>R-tree index, uzaysal (spatial) verileri indexlemek için kullanýlýr. Bir hash
		index, dizi aramalarýnda (range search) kullanýlamaz. B-tree index dizi aramalarýnda sadece tek 
		boyutlu çalýþmaktadýr. R-tree, çok boyutlu veriyi destekler. Örneðin, eðer bir R-tree index point 
		veri tipi üzerinde inþa edililebilirse, sistem "select all points within a bounding rectangle"
		gibi sorgulara daha verimli yanýtlar verecektir.</p>
		<p>Orijinal R-tree tasarýmýný açýklayan belge:</p>
		<p>Guttman, A. "R-trees: A Dynamic Index Structure for Spatial Searching."
		Proceedings of the 1984 ACM SIGMOD Int'l Conf on Mgmt of Data, 45-57.</p>
		<p>Bu belgeyi, Stonebraker'ýn "Readings in Database Systems" kitabýnda bulabilirsiniz.</p>
		<p>Gömülü R-tree indexleri poligon ve boxlarý kullanabilir. Teorik olarak,
		R-tree indexlerin özelliklerini geniþletmek bir miktar çaba gerektirir ve bunun nasýl 
		yapýlacaðýna dair bir belgemiz henüz bulunmamaktadýr.</p>

		<h4><a name="4.11">4.11</a>) <i>Genetic Query Optimizer</i> nedir?</h4>
		<p><i>GEQO</i> modülü, <i>Genetic Algorithm(GA)</i> kullanýlarak tablolar
		birleþtirildiðinde sorgu optimizasyonunu hýzlandýrýr. </p>
		
		<h4><a name="4.12">4.12</a>) Düzenli ifade (<i>Regular Expression</i>) aramalarýný
		ve büyük/küçük harfe duyarsýz aramalarý nasýl yapabilirim?
		Bu büyük(küçük harfe duyarlý aramalar için <i>index</i>'i nasýl kullanabilirim?</h4>
		<p><code>~</code> operatörü düzenli ifade eþleþmesi ve <code>~*</code>  büyük/küçük
		harfe duyarsýz düzenli ifade eþleþmesi yapar. Büyük/küçük harfe duyarlý olan
		<code>LIKE</code>'ýn  büyük/küçük harfe duyarsýz olan biçimi <code>ILIKE</code>'týr
		ve PostgreSQL 7.1 sürümü ile birlikte gelmiþtir.</p>
		<p>Büyük-küçük harfe duyarsýz eþitlik karþýlaþtýrmalarý aþaðýdaki gibi ifade edilir:</p>
		<pre>
SELECT *
FROM tab
WHERE lower(col) = 'abc'
		</pre>
		<p>Bu standart bir <i>index</i> yaratmayacaktýr. Ancak eðer fonksiyonel bir
		<i>index</i> yaratýrsanýz; o kullanýlacaktýr:</p>
		<pre>CREATE INDEX tabindex on tab (lower(col));</pre>
		
		<h4><a name="4.13">4.13</a>) Bir sorguda, bir alanin "<code>NULL</code>" olduðunu
		nasýl ortaya çýkarabilirim?</h4>
		<p>Kolonu, <code>IS NULL</code> ve <code>IS NOT NULL</code> ile test edebilirsiniz.</p>
		
		<h4><a name="4.14">4.14</a>) Çesitli karakter tipleri arasýndaki farklar nelerdir?</h4>
		<pre>
Veri Tipi	    Ýç Adý              Not
--------------------------------------------------
VARCHAR(n)      varchar         boyut en büyük uzunluðu verir; sadece verilen kadar veri tutulur.
CHAR(n)         bpchar          belirtilen uzunluða kadar sonuna  boþluk eklenir.
TEXT            text            uzunlukta herhangi bir üst sýnýr yoktur. 
BYTEA           bytea           variable-length byte array (null-byte safe)
"char"          char            bir karakter 
		</pre>
		<p>Ýç adlarý (<i>internal name</i>) sistem kataloglarýný ve
		bazý hata mesajlarýný incelerken göreceksiniz.</p>
		<p>Ýlk dört veri tipi "<i>varlena</i>" tipidir (yani, diskteki ilk 4 bayt uzunluktur;
		devamý da veridir.) Dolayýsýyla, kullanýlan gerçek alan, belirtilen alandan biraz
		daha büyüktür. Ancak, bu veri tipleri, sýkýþtýrýlmaya tabi tutulabilir; dolayýsýyla
		disk alaný beklenilenden küçük olabilir. <code>VARCHAR(<i>n</i>)</code> büyüklüðü
		artabilen ama en büyük uzunluðu sýnýrlý olan verileri saklamak için en uygun yöntemdir.
		<code>TEXT</code>, 1 GB büyüklüðe kadar olan verileri tutmak için kullanýlýr.</p>
		<p><code>CHAR(<i>n</i>)</code>, ayný uzunluktaki dizilerin saklanmasý için kullanýmýr.
		<code>CHAR(<i>n</i>)</code> belirtilen uzunluða kadar boþluk ile doldurur; ancak
		<code>VARCHAR(<i>n</i>)</code> sadece verilen karakterleri saklar. <code>BYTEA</code>
		binary veri saklamak içindir; ayrýca "<code>NULL</code>" bayt içeren deðerleri de saklar.
		Burada anlatýlan üç veri tipi de benzer baþarým karakteristiklere sahiptir.</p>
		
		<h4><a name="4.15.1">4.15.1</a>) Nasýl <i>serial</i>/otomatik artan
		(<i>auto-incrementing</i>) bir alan yaratabilirim?</h4>
		<p>PostgreSQL'de <code>SERIAL</code> veri tipi vardýr. Bu veri tipi bir
		<i>sequence</i> ve kolon üzerinde bir <i>index</i> yaratýr.</p>
		<p>Örnek, aþaðýdaki sorgu:</p>
		<pre>
CREATE TABLE person (
    id   SERIAL,
    name TEXT
);		
		</pre>
		<p>buna çevrilir:</p>
		<pre>
CREATE SEQUENCE person_id_seq;
CREATE TABLE person (
    id   INT4 NOT NULL DEFAULT nextval('person_id_seq'),
    name TEXT
);
CREATE UNIQUE INDEX person_id_key ON person ( id );		
		</pre>
		<p><i>Sequenceler</i> hakkýnda daha fazla bilgi için <i>create_sequence</i>
		yardým sayfasýna bakabilirsiniz. Her satýrýn <code>OID</code> alanýný tekil bir sayý
		olarak alabilirsiniz. Ancak, veritabanýnýzýn <i>dump</i>'ýný alýp yeniden yüklerseniz,
		<code>OID</code> deðerlerini koruyabilmek için <code>pg_dump</code>'ýn <code>-o</code>
		parametresini ya da "<code>COPY WITH OIDS</code>" seçeneðini kullanmanýz gerekecektir.</p>

    	<h4><a name="4.15.2">4.15.2</a>) <code>SERIAL</code> giriþinin degerini nasýl alabilirim?</h4>
		<p>Bir yaklaþým, sequence nesnesindeki SERIAL deðerini, veriyi girmeden önce nextval() ile alýp, 
		aldýðýnýz deðeri kendinizin girmesidir. 4.15.1'deki örnek tabloyu kullanarak bir örnek verelim:</p>

		<pre>new_id = execute("SELECT nextval('person_id_seq')");<BR>
    execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");</pre>

	<P>Diðer sorgular için new_id'de yeni deðerin saklanmasý gerekir. Otomatik olarak yaratýlan SEQUENE nesnesinin adý,
  &lt;tablo adý&gt;_&lt;serial kolonu adý&gt;_seq þeklinde olacaktýr (&lt; &gt; iþaretleri olmadan).</p>

		<p>Alternatif olarak, atanmýþ SERIAL deðerini, deðer girildikten sonra currval()
		fonksiyonu ile alabilirsiniz:</p>
		<pre>
		execute("INSERT INTO person (name) VALUES ('Blaise Pascal')");
		new_id = execute("SELECT currval('person_id_seq')");	
		</pre>
		<p>Son olarak, ön tanýmlý deðeri bulmak için <code>INSERT</code> ifadesinden
		dönen <code>OID</code> deðerini kullanabilirsiniz; ancak bu en az taþýnabilir
		çözüm olacaktýr. Perl'de, Edmund Mergl'in <i>DBD:Pg</i> mödülü ile birlikte
		<i>DBI</i> kullanarak, <code>OID</code> deðeri <code>$sth->execute()</code>
		çalýþtýrýldýktan sonra <code>$sth->(pg_oid_status)</code> ile alýnabilir.</p>
	
		<h4><a name="4.15.3">4.15.3</a>) <code>currval()</code> ve <code>nextval()</code>
		diðer kullanýcýlara sorun yaratmaz mý?</h4>
		<p>Hayýr. <code>curval()</code>, tüm kullanýcýlar deðil, backend
		tarafýndan atanan geçerli deðeri döndürür.</p>
		
		<h4><a name="4.15.4">4.15.4</a>) Neden <i>sequence</i> sayýlarý <i>transaction</i>
		iþleminin iptalinden sonra yeniden kullanýlýyor? Neden <i>sequence/SERIAL</i>
		kolonumdaki sayýlarda atlamalar oluyor?</h4>
		<p>Uyumluluðu arttýrmak için, <i>sequence</i> deðerleri çalýþan
		<i>transaction</i>'lara gerektiði þekilde aktarýlýr ve <i>transaction</i>
		bitene kadar o deðer kilitlenmez. Bu, iptal edilen <i>transaction</i>
		iþlemleri nedeniyle boþluklara neden olur.</p>
		
		<h4><a name="4.16">4.16</a>) OID nedir? TID nedir?</h4>
		<p>OIDler, tekil satýr numaralarýna PostgreSQL'in yanýtýdýr. PostgreSQL'de yaratýlan
		her sayý, tekil bir OID alýr. initdb iþlemi sýrasýnda yaratýlan tüm OID'ler 16384'ten küçüktür 
		(backend/access/transam.h). Kullanýcýlar tarafýndan yaratýlan tüm OID'ler bu sayýya eþit ya da bu 
		sayýdan büyüktür. Varsayýlan durumda, tüm bu OIDler sadece bir tablo ya da veritabanýnda deðil, tüm 
		PostgreSQL kurulumunda tekildir.</p>

		<p> PostgreSQL OIDleri, tablolar arasýnda satýrlarý iliþkilendirmek için kendi iç tablolarýnda 
		kullanýr. Bu OIDler belirli kullanýcý satýrlarýný belirtmek için kullanabilir ve join iþlemlerinde 
		kullanýlýr. OID deðerlerini saklamak için OID kolon tipini kullanmanýz önerinir. Daha hýzlý bir 
		eriþim için, OID alanýnda bir index yaratabilirsiniz.</p>

		<p>OID'ler yeni satýrlara, tüm veritabanlarý tarafýnda kullanýlan ortak bir alandan atanýrlar. Eðer 
		 OID'i baþka bir deðere eþitlemek isterseniz ya da tablonun bir kopyasýný orijinal OIDler ile 
		çýkarmak isterseniz, bu mümkündür:</p>
		<pre>
			CREATE TABLE new_table(old_oid oid, mycol int);
			SELECT old_oid, mycol INTO new FROM old;
			COPY new TO '/tmp/pgtable';
			DELETE FROM new;
			COPY new WITH OIDS FROM '/tmp/pgtable';		
		</pre>
		<p>OIDler 4-bit tamsayý olarak saklanýrlar ve 4 milyarda overflow olacaktýr. Kimse 
		bu sayýya ulaþtýðýna dair bir bilgi iletmedi ve bu sýnýrý kimse bu sýnýra ulaþmadan kaldýracaðýz.</p>

		<p>TIDler, belirli fiziksel satýrlar block ve offset deðerleri ile belirtmekte kullanýlýr. TIDler, 
		satýrlar deðiþtiðinde ya da yeniden yüklendiðinde deðiþirler. Index girdileri tarafýndan fiziksel 
		satýrlarý göstermek için kullanýlýrlar.</p>
		
		<h4><a name="4.17">4.17</a>) PostgreSQL'de kullanýlan bazý
		terimlerin anlamlarý nelerdir?</h4>
		<p>Kaynak kodun bir kýsmý ve eski belgeler, daha geniþ kullaným alaný olan terimleri
		kullanýrlar. Bunlarýn bazýlarý:</p>
		<ul><li>table, relation, class</li>
		<li>row, record, tuple</li>
		<li>column, field, attribute</li>
		<li>retrieve, select</li>
		<li>replace, update</li>
		<li>append, insert</li>
		<li>OID, serial value</li>
		<li>portal, cursor</li>
		<li>range variable, table name, table alias</li></ul>
		<p>Genel veritabaný terimleri, 
		<i><a href="http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary/glossary.html">http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary/glossary.html</a></i>
		adresinde bulunabilir.</p>
		
		<h4><a name="4.18">4.18</a>) Neden "<i>ERROR: Memory exhausted in AllocSetAlloc()</i>"
		hatasýný alýyorum?</h4>
		<p>Sisteminizde sanal belleðinizi tüketmiþ olabilirsiniz, ya da çekirdeðiniz
		belli kaynaklar icin düþük bir sýnýra sahip olabilir. <i>postmaster</i>'ý
		baþlatmadan önce aþaðýdakileri deneyebilirsiniz:</p>
		<pre>
ulimit -d 262144
limit datasize 256m		
		</pre>
		<p>Kabuðunuza baðlý olarak, bunlardan sadece biri olumlu sonuç verecektir, ama
		bu iþlem veri segment sýnýrýnýzý arttýracak, ve belki de sorgunuzun tamamlanmasýný
		saðlayacaktýr. Bu komut, varolan iþleme (<i>current process</i>) ve komut çalýþtýrýldýktan
		sonraki tüm alt iþlemlere uygulanýr. Eðer SQL istemcinizle, <i>backend</i>'in çok
		fazla veri döndürmesi nedeniyle bir sorun yaþýyorsanýz, bunu istemciyi baþlatmadan
		önce deneyiniz.</p>
		
		<h4><a name="4.19">4.19</a>) Hangi PostgreSQL sürümünü çalýþtýrdýðýmý nasýl görebilirim?</h4>
		<p>psql arabiriminde, <code>select version();</code> yazýnýz.</p>
		
		<h4><a name="4.20">4.20</a>) Neden <i>large-object</i> iþlemlerim, "<i>invalid large obj
		descriptor</i>" hatasýný veriyor?</h4>
		<p><i>Large object</i> iþlemlerinizin uçlarýna, yani <code>lo_open</code> ...
		<code>lo_close</code> komutlarýnýn çevresine, <code>BEGIN WORK</code> ve
		<code>COMMIT</code> koymanýz gerekmektedir;</p>
		<p>Þu anda, PostgreSQL kurallarý large objectleri transaction commit edildiðinde kapatarak 
	        uygulamaktadýr. Dolayýsýyla handle ile yapýlacak ilk þey <i>invalid large obj descriptor</i> hatasý 
		ile sonuçlanacaktýr.Dolayýsýyla çalýþan kodunuz eðer transaction kullanmazsanýz hata mesajlarý 
		üretecektir.</p>
		<p>Eðer ODBC gibi bir istemci arabirimi kullanýyorsanýz, <i>auto-commit</i>'i
		kapatmanýz gerekebilir.</p>
		
		<h4><a name="4.21">4.21</a>) Þu andaki zamaný öntanýmlý deðer olarak
		kabul eden <b>How do I create a column that will default to the current time?</b></h4>
		<p>Alttakini kullanabilirsiniz:</p>
		<pre>
CURRENT_TIMESTAMP:
CREATE TABLE test (x int, modtime timestamp DEFAULT CURRENT_TIMESTAMP );
		</pre>
		
		<h4><a name="4.22">4.22</a>) Neden <code>IN</code> kullanan <i>subquery</i>'lerim
		çok yavas?</h4>
		<p>7.4 sürümünden önce, subqueryler. Eðer subquery sadece birkaç satýr ve outer query bol 
		sayýda satýr döndürüyorsa, IN en hýzlýsýdýr. Sorgularý hýzlandýrmak için IN yerine EXISTS 
		kullanýn:</p>
		<pre>
SELECT *
    FROM tab
    WHERE col1 IN (SELECT col2 FROM TAB2)
		</pre>
		<p>sorgusunu, aþaðýdaki ile deðiþtirin:</p>
		<pre>
SELECT *
    FROM tab
    WHERE EXISTS (SELECT col2 FROM TAB2 WHERE col1 = col2)		
		</pre>
		<p>Bu iþlemin hýzlý olmasý için, subcol'un indexlenmiþ bir kolon olmasý gerekmektedir.</p>
		<p>7.4 sürümü ve sonrasýnda, IN aslýnda normal sorgularla ayný karmaþýk join tekniklerini kullanýr ve 
		EXISTS'e tercih edilir.</p>

		<h4><a name="4.23">4.23</a>) <i>Outer join</i> iþlemini nasýl yapabilirim?</h4>
		<p>PostgreSQL outer joins islemlerini SQL standartlarýný kullanarak
		gerçekleþtirmektedir. Aþaðýda 2 örnek bulunmaktadýr:</p>
		<pre>
SELECT *
FROM t1 LEFT OUTER JOIN t2 ON (t1.col = t2.col);		
		</pre>
		<p>ya da</p>
		<pre>
SELECT *
FROM t1 LEFT OUTER JOIN t2 ON (t1.col = t2.col);		
		</pre>
		<p>Bu özdeþ sorgular t1.col' i t2.col'ye <i>join</i> ederler ve ayný zamanda t1'deki
		<i>unjoined</i> satýrlarý (t2'de eþlenmemiþ olanlarla) döndürürler. <code>RIGHT
		JOIN t2</code>'nin <i>unjoined</i> satýrlarýný ekleyecektir. Bir FULL join, eþleþmiþ
		bütün satýrlarý ve t1 ile t2'den tüm baðlanmamýþ (<i>unjoined</i>) satýrlarý alýr.
		<code>OUTER</code> sözcüðü seçimseldir ve <code>LEFT</code>, <code>RIGHT</code> ve
		<code>FULL</code> <i>join</i> iþlemlerinde olduðu kabul edilir. Sýradan <i>join</i>
		iþlemleri <code>INNER JOIN</code> olarak adlandýrýlýr.</p>
		<p>Önceki sürümlerde, <code>OUTER JOIN</code>ler <code>UNION</code> ve <code>NOT IN</code>
		kullanýlarak simüle edilebiliyordu. Örneðin, tab1 ve tab2'yi birleþtirirken, aþaðýdaki
		sorgu iki tablonun dýþtan baðlanmasýný saðlar:</p>
		<pre>
SELECT tab1.col1, tab2.col2
FROM tab1, tab2
WHERE tab1.col1 = tab2.col1
UNION ALL
SELECT tab1.col1, NULL
FROM tab1
WHERE tab1.col1 NOT IN (SELECT tab2.col1 FROM tab2)
ORDER BY col1		
		</pre>
		
		<h4><a name="4.24">4.24</a>) Ayný andan birden fazla veritabanýnda nasýl
		iþlem yapabilirim?</h4>
		<p>Mevcut veritabanýnýz dýþýndaki baþka bir veritabanýnýzý sorgulamanýzýn
		bir yolu bulunmamaktadýr. Bunun nedeni, PostgreSQL'in veritabanýna özel sistem
		kataloglarý yüklemesidir. Bu nedenle, cross-database bir sorgunun nasýl
		davranacaðýný kestirmek zordur.</p>
		<p>contrib/dblink fonksiyon çaðrýlarýný kullanarak cross-database sorgulara
		izin verir. Tabii ki, bir istemci deðiþik veritabanlarýna ayný anda eriþim
		saðlayabilir ve bilgiyi bu þekilde birleþtirebilir.</p>
		
		<h4><a name="4.25">4.25</a>) Bir fonksiyondan nasýl çoklu satýr ya da 
		kolon döndürebilirim?</h4>
		<p>7.3 sürümünde, bir fonksiyondan kolaylýkla çoklu satýr ya da sütun
		döndürebilirsiniz.
		(<i><a href="http://techdocs.postgresql.org/guides/SetReturningFunctions">http://techdocs.postgresql.org/guides/SetReturningFunctions</a></i>)</p>
		
		<h4><a name="4.26">4.26</a>) Neden Pl/PgSQL fonksiyonlarý içinden
		güvenli bir þekilde tablo yaratma/kaldýrma iþlemlerini yapamýyoruz?</h4>
		<p>PL/PgSQL fonksiyon içerikleri <i>cache</i>'ler. Bunun istenmeyen bir tarafý,
		eðer bir PL/PgSQL fonksiyonu geçici bir tabloya eriþiyorsa ve bu tablo ileride
		kaldýrýlýp yeniden oluþturulduktan sonra fonksiyon yeniden çaðrýlýrsa, fonksiyon
		çalýþmayacaktýr; çünkü <i>cache</i>'lenmiþ fonksiyon hala eski geçici tabloyu
		gösteriyor olacaktýr. Çözüm, geçici tablo eriþimleri için PL/PgSQL'de
		<code>EXECUTE</code> kullanmaktýr. Bu, sorgunun her seferinde yeniden iþlenmesini
		saðlayacaktýr.</p>
		
		<h4><a name="4.27">4.27</a>) 4.28) Hangi þifreleme seçenekleri bulunmaktadýr?</h4>
		<ul><li>contrib/pgcrypto SQL sorgularýnda kullanýlabilmesi için
		þifreleme fonksiyonlarý içermektedir.</li>
		<li> Ýstemciden sunucuya iletiþimi þifrelemek için, sunucuda ssl seçeneði postgresql.conf içinde 
		açýk olmalýdýr. Ayrýca,pg_hba.conf dosyasý içinde host ya da hostssl kaydý mutlaka olmalýdýr ve 
		istemci sslmode kapatýlmamalýdýr. (Ayný zamanda,PostgreSQL'in doðal SSL baðlantýlarý dýþýnda ssh ya 
		da ssl gibi 3.parti þifrelenmiþ veri iletimi de mümkündür.)</li>
		<li>Veritabaný kullanýcý adý ve þifreleri 7.3 sürümü ile birlikte
		otomatik olarak þifrelenirler. Önceki sürümlerde, postgresql.conf
		içindeki PASSWORD_ENCRYPTION seçeneðini aktif hale getirmeniz gerekmektedir.</li>
		<li>Sunucunun kendisini þifreli dosya sistemi üzerinde çalýþtýrabilirsiniz.</li></ul>
		
		<hr>
		
	<h2 align="center">PostgreSQL Özelliklerini Geniþletmek</h2>
		
		<h4><a name="5.1">5.1</a>) Kullanýcý-tanýmlý bir fonksiyon yazdým.
		psql'de çalýþtýrdýðým zaman neden core dump ediyor?</h4>
		<p>Sorunun nedeni birden fazla þey olabilir. Kullanýcý-tanýmlý fonksiyonunuzu
		stand-alone bir programda çalýþtýrmayý deneyiniz.</p>
		
		<h4><a name="5.2">5.2</a>) PostgreSQL'e nasýl yeni tipler/fonksiyonlar ekleyebilirim?</h4>
		<p>Çalýþmalarýnýzý pgsql-hackers e-posta listesine gönderiniz. Kodunuz
		incelendikten sonra /contrib dizinine konacaktýr.</p>
		
		<h4><a name="5.3">5.3</a>) Bir <i>tuple</i> dondürmek icin bir C fonksiyonunu nasil yazarým?</h4>
		<p>PostgreSQL 7.3 sürümü ile birlikte, C, PL/PgSQL ve SQL kullanýlarak tablo-döndüren
		fonksiyonlar tamamen desteklenmektedir. Ayrýntýlý bilgi için
		<i><a href="http://www.postgresql.com/docs/7.3/interactive/user.html">PostgreSQL 7.3.2
		Kullanýcý Rehberi</a></i>'ne bakabilrisiniz. Bir örneði contrib/tablefunc
		içinde bulabilirsiniz.</p>
		
		<h4><a name="5.4">5.4</a>) Bir kaynak dosyasýnda deðiþiklik yaptým. Yeniden derlememe
		raðmen deðiþiklik geçerli olmuyor. Neden?</h4>
		<p>Makefile'lar include dosyalarý için tam bir baðýmlýlýk içermezler. 
		Öncelikle make clean, ardýndan da baska bir make iþlemi yapmanýz gerekir.
		GCC kullanýyorsanýz, configure betiðinin --enable-depend seçeneðini, derleyicinin
		baðýmlýlýklarý otomatik olarak hesaplamasý için kullanabilirsiniz.</p>
		
</body></html>
