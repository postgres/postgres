<!-- $PostgreSQL: pgsql/doc/src/sgml/catalogs.sgml,v 2.161 2008/01/31 18:40:02 tgl Exp $ -->
<!--
 Documentation of the system catalogs, directed toward PostgreSQL developers
 -->

<chapter id="catalogs">
 <title>System Catalogs</title>

  <para>
   The system catalogs are the place where a relational database
   management system stores schema metadata, such as information about
   tables and columns, and internal bookkeeping information.
   <productname>PostgreSQL</productname>'s system catalogs are regular
   tables.  You can drop and recreate the tables, add columns, insert
   and update values, and severely mess up your system that way.
   Normally, one should not change the system catalogs by hand, there
   are always SQL commands to do that.  (For example, <command>CREATE
   DATABASE</command> inserts a row into the
   <structname>pg_database</structname> catalog &mdash; and actually
   creates the database on disk.)  There are some exceptions for
   particularly esoteric operations, such as adding index access methods.
  </para>

 <sect1 id="catalogs-overview">
  <title>Overview</title>

  <para>
   <xref linkend="catalog-table"> lists the system catalogs.
   More detailed documentation of each catalog follows below.
  </para>

  <para>
   Most system catalogs are copied from the template database during
   database creation and are thereafter database-specific. A few
   catalogs are physically shared across all databases in a cluster;
   these are noted in the descriptions of the individual catalogs.
  </para>

  <table id="catalog-table">
   <title>System Catalogs</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Catalog Name</entry>
      <entry>Purpose</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="catalog-pg-aggregate"><structname>pg_aggregate</structname></link></entry>
      <entry>aggregate functions</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-am"><structname>pg_am</structname></link></entry>
      <entry>index access methods</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amop"><structname>pg_amop</structname></link></entry>
      <entry>access method operators</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link></entry>
      <entry>access method support procedures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link></entry>
      <entry>column default values</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link></entry>
      <entry>table columns (<quote>attributes</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link></entry>
      <entry>authorization identifiers (roles)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link></entry>
      <entry>authorization identifier membership relationships</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-autovacuum"><structname>pg_autovacuum</structname></link></entry>
      <entry>per-relation autovacuum configuration parameters</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-cast"><structname>pg_cast</structname></link></entry>
      <entry>casts (data type conversions)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-class"><structname>pg_class</structname></link></entry>
      <entry>tables, indexes, sequences, views (<quote>relations</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
      <entry>check constraints, unique constraints, primary key constraints, foreign key constraints</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-conversion"><structname>pg_conversion</structname></link></entry>
      <entry>encoding conversion information</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-database"><structname>pg_database</structname></link></entry>
      <entry>databases within this database cluster</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-depend"><structname>pg_depend</structname></link></entry>
      <entry>dependencies between database objects</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-description"><structname>pg_description</structname></link></entry>
      <entry>descriptions or comments on database objects</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-enum"><structname>pg_enum</structname></link></entry>
      <entry>enum label and value definitions</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-index"><structname>pg_index</structname></link></entry>
      <entry>additional index information</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-inherits"><structname>pg_inherits</structname></link></entry>
      <entry>table inheritance hierarchy</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-language"><structname>pg_language</structname></link></entry>
      <entry>languages for writing functions</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link></entry>
      <entry>large objects</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-listener"><structname>pg_listener</structname></link></entry>
      <entry>asynchronous notification support</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link></entry>
      <entry>schemas</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link></entry>
      <entry>access method operator classes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link></entry>
      <entry>operators</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link></entry>
      <entry>access method operator families</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link></entry>
      <entry>template data for procedural languages</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link></entry>
      <entry>functions and procedures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
      <entry>query rewrite rules</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link></entry>
      <entry>dependencies on shared objects</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link></entry>
      <entry>comments on shared objects</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link></entry>
      <entry>planner statistics</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link></entry>
      <entry>tablespaces within this database cluster</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
      <entry>triggers</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link></entry>
      <entry>text search configurations</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link></entry>
      <entry>text search configurations' token mappings</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link></entry>
      <entry>text search dictionaries</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link></entry>
      <entry>text search parsers</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link></entry>
      <entry>text search templates</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-type"><structname>pg_type</structname></link></entry>
      <entry>data types</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-aggregate">
  <title><structname>pg_aggregate</structname></title>

  <indexterm zone="catalog-pg-aggregate">
   <primary>pg_aggregate</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_aggregate</structname> stores information about
   aggregate functions.  An aggregate function is a function that
   operates on a set of values (typically one column from each row
   that matches a query condition) and returns a single value computed
   from all these values.  Typical aggregate functions are
   <function>sum</function>, <function>count</function>, and
   <function>max</function>.  Each entry in
   <structname>pg_aggregate</structname> is an extension of an entry
   in <structname>pg_proc</structname>.  The <structname>pg_proc</structname>
   entry carries the aggregate's name, input and output data types, and
   other information that is similar to ordinary functions.
  </para>

  <table>
   <title><structname>pg_aggregate</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>aggfnoid</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><structname>pg_proc</structname> OID of the aggregate function</entry>
     </row>
     <row>
      <entry><structfield>aggtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Transition function</entry>
     </row>
     <row>
      <entry><structfield>aggfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Final function (zero if none)</entry>
     </row>
     <row>
      <entry><structfield>aggsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Associated sort operator (zero if none)</entry>
     </row>
     <row>
      <entry><structfield>aggtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Data type of the aggregate function's internal transition (state) data</entry>
     </row>
     <row>
      <entry><structfield>agginitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       The initial value of the transition state.  This is a text
       field containing the initial value in its external string
       representation.  If this field is NULL, the transition state
       value starts out NULL
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   New aggregate functions are registered with the <xref
   linkend="sql-createaggregate" endterm="sql-createaggregate-title">
   command.  See <xref linkend="xaggr"> for more information about
   writing aggregate functions and the meaning of the transition
   functions, etc.
  </para>

 </sect1>


 <sect1 id="catalog-pg-am">
  <title><structname>pg_am</structname></title>

  <indexterm zone="catalog-pg-am">
   <primary>pg_am</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_am</structname> stores information about index
   access methods.  There is one row for each index access method supported by
   the system.  The contents of this catalog are discussed in detail in
   <xref linkend="indexam">.
  </para>

  <table>
   <title><structname>pg_am</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the access method</entry>
     </row>

     <row>
      <entry><structfield>amstrategies</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of operator strategies for this access method,
       or zero if access method does not have a fixed set of operator
       strategies</entry>
     </row>

     <row>
      <entry><structfield>amsupport</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of support routines for this access method</entry>
     </row>

     <row>
      <entry><structfield>amcanorder</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Does the access method support ordered scans?</entry>
     </row>

     <row>
      <entry><structfield>amcanunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Does the access method support unique indexes?</entry>
     </row>

     <row>
      <entry><structfield>amcanmulticol</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Does the access method support multicolumn indexes?</entry>
     </row>

     <row>
      <entry><structfield>amoptionalkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Does the access method support a scan without any constraint
       for the first index column?</entry>
     </row>

     <row>
      <entry><structfield>amindexnulls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Does the access method support null index entries?</entry>
     </row>

     <row>
      <entry><structfield>amsearchnulls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Does the access method support IS NULL searches?</entry>
     </row>

     <row>
      <entry><structfield>amstorage</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Can index storage data type differ from column data type?</entry>
     </row>

     <row>
      <entry><structfield>amclusterable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Can an index of this type be clustered on?</entry>
     </row>

     <row>
      <entry><structfield>aminsert</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Insert this tuple</quote> function</entry>
     </row>

     <row>
      <entry><structfield>ambeginscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Start new scan</quote> function</entry>
     </row>

     <row>
      <entry><structfield>amgettuple</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Next valid tuple</quote> function</entry>
     </row>

     <row>
      <entry><structfield>amgetmulti</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Fetch multiple tuples</quote> function</entry>
     </row>

     <row>
      <entry><structfield>amrescan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Restart this scan</quote> function</entry>
     </row>

     <row>
      <entry><structfield>amendscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>End this scan</quote> function</entry>
     </row>

     <row>
      <entry><structfield>ammarkpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Mark current scan position</quote> function</entry>
     </row>

     <row>
      <entry><structfield>amrestrpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Restore marked scan position</quote> function</entry>
     </row>

     <row>
      <entry><structfield>ambuild</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Build new index</quote> function</entry>
     </row>

     <row>
      <entry><structfield>ambulkdelete</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Bulk-delete function</entry>
     </row>

     <row>
      <entry><structfield>amvacuumcleanup</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Post-<command>VACUUM</command> cleanup function</entry>
     </row>

     <row>
      <entry><structfield>amcostestimate</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Function to estimate cost of an index scan</entry>
     </row>

     <row>
      <entry><structfield>amoptions</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Function to parse and validate <structfield>reloptions</> for an index</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-amop">
  <title><structname>pg_amop</structname></title>

  <indexterm zone="catalog-pg-amop">
   <primary>pg_amop</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_amop</structname> stores information about
   operators associated with access method operator families.  There is one
   row for each operator that is a member of an operator family.  An operator
   can appear in more than one family, but cannot appear in more than one
   position within a family.
  </para>

  <table>
   <title><structname>pg_amop</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amopfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>The operator family this entry is for</entry>
     </row>

     <row>
      <entry><structfield>amoplefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Left-hand input data type of operator</entry>
     </row>

     <row>
      <entry><structfield>amoprighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Right-hand input data type of operator</entry>
     </row>

     <row>
      <entry><structfield>amopstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Operator strategy number</entry>
     </row>

     <row>
      <entry><structfield>amopreqcheck</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Index hit must be rechecked</entry>
     </row>

     <row>
      <entry><structfield>amopopr</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>OID of the operator</entry>
     </row>

     <row>
      <entry><structfield>amopmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Index access method operator family is for</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   An entry's <structfield>amopmethod</> must match the
   <structname>opfmethod</> of its containing operator family (including
   <structfield>amopmethod</> here is an intentional denormalization of the
   catalog structure for performance reasons).  Also,
   <structfield>amoplefttype</> and <structfield>amoprighttype</> must match
   the <structfield>oprleft</> and <structfield>oprright</> fields of the
   referenced <structname>pg_operator</> entry.
  </para>

 </sect1>


 <sect1 id="catalog-pg-amproc">
  <title><structname>pg_amproc</structname></title>

  <indexterm zone="catalog-pg-amproc">
   <primary>pg_amproc</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_amproc</structname> stores information about
   support procedures associated with access method operator families.  There
   is one row for each support procedure belonging to an operator family.
  </para>

  <table>
   <title><structname>pg_amproc</structname> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amprocfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>The operator family this entry is for</entry>
     </row>

     <row>
      <entry><structfield>amproclefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Left-hand input data type of associated operator</entry>
     </row>

     <row>
      <entry><structfield>amprocrighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Right-hand input data type of associated operator</entry>
     </row>

     <row>
      <entry><structfield>amprocnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Support procedure number</entry>
     </row>

     <row>
      <entry><structfield>amproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the procedure</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   The usual interpretation of the
   <structfield>amproclefttype</> and <structfield>amprocrighttype</> fields
   is that they identify the left and right input types of the operator(s)
   that a particular support procedure supports.  For some access methods
   these match the input data type(s) of the support procedure itself, for
   others not.  There is a notion of <quote>default</> support procedures for
   an index, which are those with <structfield>amproclefttype</> and
   <structfield>amprocrighttype</> both equal to the index opclass's
   <structfield>opcintype</>.
  </para>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
  <title><structname>pg_attrdef</structname></title>

  <indexterm zone="catalog-pg-attrdef">
   <primary>pg_attrdef</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_attrdef</structname> stores column default values.  The main information
   about columns is stored in <structname>pg_attribute</structname>
   (see below).  Only columns that explicitly specify a default value
   (when the table is created or the column is added) will have an
   entry here.
  </para>

  <table>
   <title><structname>pg_attrdef</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>adrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this column belongs to</entry>
     </row>

     <row>
      <entry><structfield>adnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>The number of the column</entry>
     </row>

     <row>
      <entry><structfield>adbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>The internal representation of the column default value</entry>
     </row>

     <row>
      <entry><structfield>adsrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>A human-readable representation of the default value</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <para>
    The <structfield>adsrc</structfield> field is historical, and is best
    not used, because it does not track outside changes that might affect
    the representation of the default value.  Reverse-compiling the
    <structfield>adbin</structfield> field (with <function>pg_get_expr</> for
    example) is a better way to display the default value.
   </para>

 </sect1>


 <sect1 id="catalog-pg-attribute">
  <title><structname>pg_attribute</structname></title>

  <indexterm zone="catalog-pg-attribute">
   <primary>pg_attribute</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_attribute</structname> stores information about
   table columns.  There will be exactly one
   <structname>pg_attribute</structname> row for every column in every
   table in the database.  (There will also be attribute entries for
   indexes, and indeed all objects that have <structname>pg_class</structname>
   entries.)
  </para>

  <para>
   The term attribute is equivalent to column and is used for
   historical reasons.
  </para>

  <table>
   <title><structname>pg_attribute</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>attrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this column belongs to</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>The column name</entry>
     </row>

     <row>
      <entry><structfield>atttypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>The data type of this column</entry>
     </row>

     <row>
      <entry><structfield>attstattarget</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>attstattarget</structfield> controls the level of detail
       of statistics accumulated for this column by
       <xref linkend="sql-analyze" endterm="sql-analyze-title">.
       A zero value indicates that no statistics should be collected.
       A negative value says to use the system default statistics target.
       The exact meaning of positive values is data type-dependent.
       For scalar data types, <structfield>attstattarget</structfield>
       is both the target number of <quote>most common values</quote>
       to collect, and the target number of histogram bins to create
      </entry>
     </row>

     <row>
      <entry><structfield>attlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       A copy of <literal>pg_type.typlen</literal> of this column's
       type
      </entry>
     </row>

     <row>
      <entry><structfield>attnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       The number of the column.  Ordinary columns are numbered from 1
       up.  System columns, such as <structfield>oid</structfield>,
       have (arbitrary) negative numbers
      </entry>
     </row>

     <row>
      <entry><structfield>attndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Number of dimensions, if the column is an array type; otherwise 0.
       (Presently, the number of dimensions of an array is not enforced,
       so any nonzero value effectively means <quote>it's an array</>)
      </entry>
     </row>

     <row>
      <entry><structfield>attcacheoff</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Always -1 in storage, but when loaded into a row descriptor
       in memory this might be updated to cache the offset of the attribute
       within the row
      </entry>
     </row>

     <row>
      <entry><structfield>atttypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>atttypmod</structfield> records type-specific data
       supplied at table creation time (for example, the maximum
       length of a <type>varchar</type> column).  It is passed to
       type-specific input functions and length coercion functions.
       The value will generally be -1 for types that do not need <structfield>atttypmod</>
      </entry>
     </row>

     <row>
      <entry><structfield>attbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       A copy of <literal>pg_type.typbyval</> of this column's type
      </entry>
     </row>

     <row>
      <entry><structfield>attstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Normally a copy of <literal>pg_type.typstorage</> of this
       column's type.  For TOAST-able data types, this can be altered
       after column creation to control storage policy
      </entry>
     </row>

     <row>
      <entry><structfield>attalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A copy of <literal>pg_type.typalign</> of this column's type
      </entry>
     </row>

     <row>
      <entry><structfield>attnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This represents a not-null constraint.  It is possible to
       change this column to enable or disable the constraint
      </entry>
     </row>

     <row>
      <entry><structfield>atthasdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column has a default value, in which case there will be a
       corresponding entry in the <structname>pg_attrdef</structname>
       catalog that actually defines the value
      </entry>
     </row>

     <row>
      <entry><structfield>attisdropped</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column has been dropped and is no longer valid.  A dropped
       column is still physically present in the table, but is
       ignored by the parser and so cannot be accessed via SQL
      </entry>
     </row>

     <row>
      <entry><structfield>attislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column is defined locally in the relation.  Note that a column can
       be locally defined and inherited simultaneously
      </entry>
     </row>

     <row>
      <entry><structfield>attinhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       The number of direct ancestors this column has.  A column with a 
       nonzero number of ancestors cannot be dropped nor renamed
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   In a dropped column's <structname>pg_attribute</structname> entry,
   <structfield>atttypid</structfield> is reset to zero, but 
   <structfield>attlen</structfield> and the other fields copied from
   <structname>pg_type</> are still valid.  This arrangement is needed
   to cope with the situation where the dropped column's data type was
   later dropped, and so there is no <structname>pg_type</> row anymore.
   <structfield>attlen</structfield> and the other fields can be used
   to interpret the contents of a row of the table.
  </para>
 </sect1>


 <sect1 id="catalog-pg-authid">
  <title><structname>pg_authid</structname></title>

  <indexterm zone="catalog-pg-authid">
   <primary>pg_authid</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_authid</structname> contains information about
   database authorization identifiers (roles).  A role subsumes the concepts
   of <quote>users</> and <quote>groups</>.  A user is essentially just a
   role with the <structfield>rolcanlogin</> flag set.  Any role (with or
   without <structfield>rolcanlogin</>) can have other roles as members; see
   <link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link>.
  </para>

  <para>
   Since this catalog contains passwords, it must not be publicly readable.
   <link linkend="view-pg-roles"><structname>pg_roles</structname></link>
   is a publicly readable view on
   <structname>pg_authid</structname> that blanks out the password field.
  </para>

  <para>
   <xref linkend="user-manag"> contains detailed information about user and
   privilege management.
  </para>

  <para>
   Because user identities are cluster-wide,
   <structname>pg_authid</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_authid</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title><structname>pg_authid</> Columns</title>

   <tgroup cols=3>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Role name</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Role has superuser privileges</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Role automatically inherits privileges of roles it is a
       member of</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Role can create more roles</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>Role can create databases</entry>
     </row>

     <row>
      <entry><structfield>rolcatupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       Role can update system catalogs directly.  (Even a superuser cannot do
       this unless this column is true)
      </entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       Role can log in. That is, this role can be given as the initial
       session authorization identifier
      </entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>
       For roles that can log in, this sets maximum number of concurrent 
       connections this role can make.  -1 means no limit
      </entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Password (possibly encrypted); NULL if none</entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>Password expiry time (only used for password authentication);
       NULL if no expiration</entry>
     </row>

     <row>
      <entry><structfield>rolconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>Session defaults for run-time configuration variables</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-auth-members">
  <title><structname>pg_auth_members</structname></title>

  <indexterm zone="catalog-pg-auth-members">
   <primary>pg_auth_members</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_auth_members</structname> shows the membership
   relations between roles.  Any non-circular set of relationships is allowed.
  </para>

  <para>
   Because user identities are cluster-wide,
   <structname>pg_auth_members</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_auth_members</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title><structname>pg_auth_members</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>roleid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID of a role that has a member</entry>
     </row>

     <row>
      <entry><structfield>member</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID of a role that is a member of <structfield>roleid</></entry>
     </row>

     <row>
      <entry><structfield>grantor</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID of the role that granted this membership</entry>
     </row>

     <row>
      <entry><structfield>admin_option</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if <structfield>member</> can grant membership in
       <structfield>roleid</> to others</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-autovacuum">
  <title><structname>pg_autovacuum</structname></title>

  <indexterm zone="catalog-pg-autovacuum">
   <primary>pg_autovacuum</primary>
  </indexterm>

  <indexterm zone="catalog-pg-autovacuum">
   <primary>autovacuum</primary>
   <secondary>table-specific configuration</secondary>
  </indexterm>

  <para>
   The catalog <structname>pg_autovacuum</structname> stores optional
   per-relation configuration parameters for the autovacuum daemon.
   If there is an entry here for a particular relation, the given
   parameters will be used for autovacuuming that table.  If no entry
   is present, the system-wide defaults will be used. For more information
   about the autovacuum daemon, see <xref linkend="autovacuum">.
  </para>

  <note>
   <para>
    It is likely that <structname>pg_autovacuum</structname> will disappear
    in a future release, with the information instead being kept in
    <structname>pg_class</>.<structfield>reloptions</> entries.
   </para>
  </note>

  <table>
   <title><structname>pg_autovacuum</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>vacrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this entry is for</entry>
     </row>

     <row>
      <entry><structfield>enabled</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If false, this table will not be autovacuumed, except
       to prevent transaction ID wraparound</entry>
     </row>

     <row>
      <entry><structfield>vac_base_thresh</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Minimum number of modified tuples before vacuum</entry>
     </row>

     <row>
      <entry><structfield>vac_scale_factor</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Multiplier for <structfield>reltuples</> to add to
       <structfield>vac_base_thresh</></entry>
     </row>

     <row>
      <entry><structfield>anl_base_thresh</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Minimum number of modified tuples before analyze</entry>
     </row>

     <row>
      <entry><structfield>anl_scale_factor</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Multiplier for <structfield>reltuples</> to add to
       <structfield>anl_base_thresh</></entry>
     </row>

     <row>
      <entry><structfield>vac_cost_delay</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Custom <varname>vacuum_cost_delay</> parameter</entry>
     </row>

     <row>
      <entry><structfield>vac_cost_limit</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Custom <varname>vacuum_cost_limit</> parameter</entry>
     </row>

     <row>
      <entry><structfield>freeze_min_age</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Custom <varname>vacuum_freeze_min_age</> parameter</entry>
     </row>

     <row>
      <entry><structfield>freeze_max_age</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Custom <varname>autovacuum_freeze_max_age</> parameter</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The autovacuum daemon will initiate a <command>VACUUM</> operation
   on a particular table when the number of updated or deleted tuples
   exceeds <structfield>vac_base_thresh</structfield> plus
   <structfield>vac_scale_factor</structfield> times the number of
   live tuples currently estimated to be in the relation.
   Similarly, it will initiate an <command>ANALYZE</> operation
   when the number of inserted, updated or deleted tuples
   exceeds <structfield>anl_base_thresh</structfield> plus
   <structfield>anl_scale_factor</structfield> times the number of
   live tuples currently estimated to be in the relation.
  </para>

  <para>
   Also, the autovacuum daemon will perform a <command>VACUUM</> operation
   to prevent transaction ID wraparound if the table's
   <structname>pg_class</>.<structfield>relfrozenxid</> field attains an age
   of more than <structfield>freeze_max_age</> transactions, whether the table
   has been changed or not, even if
   <structname>pg_autovacuum</>.<structfield>enabled</> is set to
   <literal>false</> for it.  The system will launch autovacuum to perform
   such <command>VACUUM</>s even if autovacuum is otherwise disabled.
   See <xref linkend="vacuum-for-wraparound"> for more about wraparound
   prevention.
  </para>

  <para>
   Any of the numerical fields can contain <literal>-1</> (or indeed
   any negative value) to indicate that the system-wide default should
   be used for this particular value.  Observe that the
   <structfield>vac_cost_delay</> variable inherits its default value from the
   <xref linkend="guc-autovacuum-vacuum-cost-delay"> configuration parameter,
   or from <xref linkend="guc-vacuum-cost-delay"> if the former is set to a
   negative value.  The same applies to <structfield>vac_cost_limit</>.
   Also, autovacuum will ignore attempts to set a per-table
   <structfield>freeze_max_age</> larger than the system-wide setting (it can
   only be set smaller), and the <structfield>freeze_min_age</> value will be
   limited to half the system-wide <xref
   linkend="guc-autovacuum-freeze-max-age"> setting.  Note that while you
   can set <structfield>freeze_max_age</> very small, or even zero, this
   is usually unwise since it will force frequent vacuuming.
  </para>

 </sect1>


 <sect1 id="catalog-pg-cast">
  <title><structname>pg_cast</structname></title>

  <indexterm zone="catalog-pg-cast">
   <primary>pg_cast</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_cast</structname> stores data type conversion
   paths, both built-in paths and those defined with
   <xref linkend="sql-createcast" endterm="sql-createcast-title">.
  </para>

  <para>
   It should be noted that <structname>pg_cast</structname> does not represent
   every type conversion that the system knows how to perform; only those that
   cannot be deduced from some generic rule.  For example, casting between a
   domain and its base type is not explicitly represented in
   <structname>pg_cast</structname>.  Another important exception is that
   <quote>I/O conversion casts</>, those performed using a data type's own
   I/O functions to convert to or from <type>text</> or other string types,
   are not explicitly represented in <structname>pg_cast</structname>.
  </para>

  <table>
   <title><structname>pg_cast</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>castsource</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID of the source data type</entry>
     </row>

     <row>
      <entry><structfield>casttarget</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID of the target data type</entry>
     </row>

     <row>
      <entry><structfield>castfunc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       The OID of the function to use to perform this cast.  Zero is
       stored if the data types are binary compatible (that is, no
       run-time operation is needed to perform the cast)
      </entry>
     </row>

     <row>
      <entry><structfield>castcontext</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Indicates what contexts the cast can be invoked in.
       <literal>e</> means only as an explicit cast (using
       <literal>CAST</> or <literal>::</> syntax).
       <literal>a</> means implicitly in assignment
       to a target column, as well as explicitly.
       <literal>i</> means implicitly in expressions, as well as the
       other cases
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The cast functions listed in <structname>pg_cast</structname> must
   always take the cast source type as their first argument type, and
   return the cast destination type as their result type.  A cast
   function can have up to three arguments.  The second argument,
   if present, must be type <type>integer</>; it receives the type
   modifier associated with the destination type, or <literal>-1</>
   if there is none.  The third argument,
   if present, must be type <type>boolean</>; it receives <literal>true</>
   if the cast is an explicit cast, <literal>false</> otherwise.
  </para>

  <para>
   It is legitimate to create a <structname>pg_cast</structname> entry
   in which the source and target types are the same, if the associated
   function takes more than one argument.  Such entries represent
   <quote>length coercion functions</> that coerce values of the type
   to be legal for a particular type modifier value.
  </para>

  <para>
   When a <structname>pg_cast</structname> entry has different source and
   target types and a function that takes more than one argument, it
   represents converting from one type to another and applying a length
   coercion in a single step.  When no such entry is available, coercion
   to a type that uses a type modifier involves two steps, one to
   convert between data types and a second to apply the modifier.
  </para>
 </sect1>

 <sect1 id="catalog-pg-class">
  <title><structname>pg_class</structname></title>

  <indexterm zone="catalog-pg-class">
   <primary>pg_class</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_class</structname> catalogs tables and most
   everything else that has columns or is otherwise similar to a
   table.  This includes indexes (but see also
   <structname>pg_index</structname>), sequences, views, composite types,
   and TOAST tables; see <structfield>relkind</>.
   Below, when we mean all of these
   kinds of objects we speak of <quote>relations</quote>.  Not all
   columns are meaningful for all relation types.
  </para>

  <table>
   <title><structname>pg_class</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the table, index, view, etc.</entry>
     </row>

     <row>
      <entry><structfield>relnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this relation
      </entry>
     </row>

     <row>
      <entry><structfield>reltype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       The OID of the data type that corresponds to this table's row type,
       if any (zero for indexes, which have no <structname>pg_type</> entry)
      </entry>
     </row>

     <row>
      <entry><structfield>relowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the relation</entry>
     </row>

     <row>
      <entry><structfield>relam</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>If this is an index, the access method used (B-tree, hash, etc.)</entry>
     </row>

     <row>
      <entry><structfield>relfilenode</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Name of the on-disk file of this relation; 0 if none</entry>
     </row>

     <row>
      <entry><structfield>reltablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       The tablespace in which this relation is stored.  If zero,
       the database's default tablespace is implied.  (Not meaningful
       if the relation has no on-disk file.)
      </entry>
     </row>

     <row>
      <entry><structfield>relpages</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Size of the on-disk representation of this table in pages (of size
       <symbol>BLCKSZ</symbol>).  This is only an estimate used by the
       planner.  It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and a few DDL commands such as
       <command>CREATE INDEX</command>
      </entry>
     </row>

     <row>
      <entry><structfield>reltuples</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
       Number of rows in the table.  This is only an estimate used by the
       planner.  It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and a few DDL commands such as
       <command>CREATE INDEX</command>
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID of the TOAST table associated with this table, 0 if none.  The
       TOAST table stores large attributes <quote>out of line</quote> in a
       secondary table
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastidxid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       For a TOAST table, the OID of its index.  0 if not a TOAST table
      </entry>
     </row>

     <row>
      <entry><structfield>relhasindex</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if this is a table and it has (or recently had) any
       indexes. This is set by <command>CREATE INDEX</command>, but
       not cleared immediately by <command>DROP INDEX</command>.
       <command>VACUUM</command> clears <structfield>relhasindex</> if it finds the
       table has no indexes
      </entry>
     </row>

     <row>
      <entry><structfield>relisshared</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if this table is shared across all databases in the cluster.  Only
       certain system catalogs (such as <structname>pg_database</structname>)
       are shared
      </entry>
     </row>

     <row>
      <entry><structfield>relkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>r</> = ordinary table, <literal>i</> = index,
       <literal>S</> = sequence, <literal>v</> = view, <literal>c</> =
       composite type, <literal>t</> = TOAST
       table
      </entry>
     </row>

     <row>
      <entry><structfield>relnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of user columns in the relation (system columns not
       counted).  There must be this many corresponding entries in
       <structname>pg_attribute</structname>.  See also
       <literal>pg_attribute.attnum</literal>
      </entry>
     </row>

     <row>
      <entry><structfield>relchecks</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of check constraints on the table; see
       <link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link> catalog
      </entry>
     </row>

     <row>
      <entry><structfield>reltriggers</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of triggers on the table; see
       <link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link> catalog
      </entry>
     </row>

     <row>
      <entry><structfield>relukeys</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Unused  (<emphasis>not</emphasis> the number of unique keys)</entry>
     </row>

     <row>
      <entry><structfield>relfkeys</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Unused  (<emphasis>not</emphasis> the number of foreign keys on the table)</entry>
     </row>

     <row>
      <entry><structfield>relrefs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Unused</entry>
     </row>

     <row>
      <entry><structfield>relhasoids</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if we generate an OID for each row of the relation
      </entry>
     </row>

     <row>
      <entry><structfield>relhaspkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if the table has (or once had) a primary key
      </entry>
     </row>

     <row>
      <entry><structfield>relhasrules</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if table has rules; see
       <link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link> catalog
      </entry>
     </row>

     <row>
      <entry><structfield>relhassubclass</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if table has (or once had) any inheritance children</entry>
     </row>

     <row>
      <entry><structfield>relfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       All transaction IDs before this one have been replaced with a permanent
       (<quote>frozen</>) transaction ID in this table.  This is used to track
       whether the table needs to be vacuumed in order to prevent transaction
       ID wraparound or to allow <literal>pg_clog</> to be shrunk.  Zero
       (<symbol>InvalidTransactionId</symbol>) if the relation is not a table
      </entry>
     </row>

     <row>
      <entry><structfield>relacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see
       <xref linkend="sql-grant" endterm="sql-grant-title"> and
       <xref linkend="sql-revoke" endterm="sql-revoke-title">
       for details
      </entry>
     </row>

     <row>
      <entry><structfield>reloptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       Access-method-specific options, as <quote>keyword=value</> strings
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-constraint">
  <title><structname>pg_constraint</structname></title>

  <indexterm zone="catalog-pg-constraint">
   <primary>pg_constraint</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_constraint</structname> stores check, primary key, unique, and foreign
   key constraints on tables.  (Column constraints are not treated
   specially.  Every column constraint is equivalent to some table
   constraint.)  Not-null constraints are represented in the
   <structname>pg_attribute</> catalog.
  </para>

  <para>
   Check constraints on domains are stored here, too.
  </para>

  <table>
   <title><structname>pg_constraint</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Constraint name (not necessarily unique!)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this constraint
      </entry>
     </row>

     <row>
      <entry><structfield>contype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
        <literal>c</> = check constraint,
        <literal>f</> = foreign key constraint,
        <literal>p</> = primary key constraint,
        <literal>u</> = unique constraint
      </entry>
     </row>

     <row>
      <entry><structfield>condeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Is the constraint deferrable?</entry>
     </row>

     <row>
      <entry><structfield>condeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Is the constraint deferred by default?</entry>
     </row>

     <row>
      <entry><structfield>conrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this constraint is on; 0 if not a table constraint</entry>
     </row>

     <row>
      <entry><structfield>contypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>The domain this constraint is on; 0 if not a domain constraint</entry>
     </row>

     <row>
      <entry><structfield>confrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>If a foreign key, the referenced table; else 0</entry>
     </row>

     <row>
      <entry><structfield>confupdtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Foreign key update action code</entry>
     </row>

     <row>
      <entry><structfield>confdeltype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Foreign key deletion action code</entry>
     </row>

     <row>
      <entry><structfield>confmatchtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Foreign key match type</entry>
     </row>

     <row>
      <entry><structfield>conkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</></entry>
      <entry>If a table constraint, list of columns which the constraint constrains</entry>
     </row>

     <row>
      <entry><structfield>confkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</></entry>
      <entry>If a foreign key, list of the referenced columns</entry>
     </row>

     <row>
      <entry><structfield>conpfeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</></entry>
      <entry>If a foreign key, list of the equality operators for PK = FK comparisons</entry>
     </row>

     <row>
      <entry><structfield>conppeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</></entry>
      <entry>If a foreign key, list of the equality operators for PK = PK comparisons</entry>
     </row>

     <row>
      <entry><structfield>conffeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</></entry>
      <entry>If a foreign key, list of the equality operators for FK = FK comparisons</entry>
     </row>

     <row>
      <entry><structfield>conbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>If a check constraint, an internal representation of the expression</entry>
     </row>

     <row>
      <entry><structfield>consrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>If a check constraint, a human-readable representation of the expression</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <structfield>consrc</structfield> is not updated when referenced objects
    change; for example, it won't track renaming of columns.  Rather than
    relying on this field, it's best to use <function>pg_get_constraintdef()</>
    to extract the definition of a check constraint.
   </para>
  </note>

  <note>
   <para>
    <literal>pg_class.relchecks</literal> needs to agree with the
    number of check-constraint entries found in this table for each
    relation.
   </para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-conversion">
  <title><structname>pg_conversion</structname></title>

  <indexterm zone="catalog-pg-conversion">
   <primary>pg_conversion</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_conversion</structname> describes the
   available encoding conversion procedures.  See
   <xref linkend="sql-createconversion" endterm="sql-createconversion-title">
   for more information.
  </para>

  <table>
   <title><structname>pg_conversion</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Conversion name (unique within a namespace)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this conversion
      </entry>
     </row>

     <row>
      <entry><structfield>conowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the conversion</entry>
     </row>

     <row>
      <entry><structfield>conforencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Source encoding ID</entry>
     </row>

     <row>
      <entry><structfield>contoencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Destination encoding ID</entry>
     </row>

     <row>
      <entry><structfield>conproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Conversion procedure</entry>
     </row>

     <row>
      <entry><structfield>condefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if this is the default conversion</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-database">
  <title><structname>pg_database</structname></title>

  <indexterm zone="catalog-pg-database">
   <primary>pg_database</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_database</structname> stores information about
   the available databases.  Databases are created with the <xref
   linkend="sql-createdatabase" endterm="sql-createdatabase-title"> command.
   Consult <xref linkend="managing-databases"> for details about the meaning
   of some of the parameters.
  </para>

  <para>
   Unlike most system catalogs, <structname>pg_database</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_database</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title><structname>pg_database</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>datname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Database name</entry>
     </row>

     <row>
      <entry><structfield>datdba</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the database, usually the user who created it</entry>
     </row>

     <row>
      <entry><structfield>encoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Character encoding for this database
          (<function>pg_encoding_to_char()</function> can translate
           this number to the encoding name)</entry>
     </row>

     <row>
      <entry><structfield>datistemplate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true then this database can be used in the
       <literal>TEMPLATE</literal> clause of <command>CREATE
       DATABASE</command> to create a new database as a clone of
       this one
      </entry>
     </row>

     <row>
      <entry><structfield>datallowconn</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If false then no one can connect to this database.  This is
       used to protect the <literal>template0</> database from being altered
      </entry>
     </row>

     <row>
      <entry><structfield>datconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Sets maximum number of concurrent connections that can be made 
       to this database.  -1 means no limit
      </entry>
     </row>

     <row>
      <entry><structfield>datlastsysoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>
       Last system OID in the database; useful
       particularly to <application>pg_dump</application>
      </entry>
     </row>

     <row>
      <entry><structfield>datfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       All transaction IDs before this one have been replaced with a permanent
       (<quote>frozen</>) transaction ID in this database.  This is used to
       track whether the database needs to be vacuumed in order to prevent
       transaction ID wraparound or to allow <literal>pg_clog</> to be shrunk.
       It is the minimum of the per-table
       <structname>pg_class</>.<structfield>relfrozenxid</> values
      </entry>
     </row>

     <row>
      <entry><structfield>dattablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       The default tablespace for the database.
       Within this database, all tables for which
       <structname>pg_class</>.<structfield>reltablespace</> is zero
       will be stored in this tablespace; in particular, all the non-shared
       system catalogs will be there
      </entry>
     </row>

     <row>
      <entry><structfield>datconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Session defaults for run-time configuration variables</entry>
     </row>

     <row>
      <entry><structfield>datacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see
       <xref linkend="sql-grant" endterm="sql-grant-title"> and
       <xref linkend="sql-revoke" endterm="sql-revoke-title">
       for details
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-depend">
  <title><structname>pg_depend</structname></title>

  <indexterm zone="catalog-pg-depend">
   <primary>pg_depend</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_depend</structname> records the dependency
   relationships between database objects.  This information allows
   <command>DROP</> commands to find which other objects must be dropped
   by <command>DROP CASCADE</> or prevent dropping in the <command>DROP
   RESTRICT</> case.
  </para>

  <para>
   See also <link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link>,
   which performs a similar function for dependencies involving objects
   that are shared across a database cluster.
  </para>

  <table>
   <title><structname>pg_depend</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog the dependent object is in</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the specific dependent object</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a table column, this is the column number (the
       <structfield>objid</> and <structfield>classid</> refer to the
       table itself).  For all other object types, this column is
       zero
      </entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog the referenced object is in</entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the specific referenced object</entry>
     </row>

     <row>
      <entry><structfield>refobjsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a table column, this is the column number (the
       <structfield>refobjid</> and <structfield>refclassid</> refer
       to the table itself).  For all other object types, this column
       is zero
      </entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A code defining the specific semantics of this dependency relationship; see text
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   In all cases, a <structname>pg_depend</structname> entry indicates that the
   referenced object cannot be dropped without also dropping the dependent
   object.  However, there are several subflavors identified by
   <structfield>deptype</>:

   <variablelist>
    <varlistentry>
     <term><symbol>DEPENDENCY_NORMAL</> (<literal>n</>)</term>
     <listitem>
      <para>
       A normal relationship between separately-created objects.  The
       dependent object can be dropped without affecting the
       referenced object.  The referenced object can only be dropped
       by specifying <literal>CASCADE</>, in which case the dependent
       object is dropped, too.  Example: a table column has a normal
       dependency on its data type.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO</> (<literal>a</>)</term>
     <listitem>
      <para>
       The dependent object can be dropped separately from the
       referenced object, and should be automatically dropped
       (regardless of <literal>RESTRICT</> or <literal>CASCADE</>
       mode) if the referenced object is dropped.  Example: a named
       constraint on a table is made autodependent on the table, so
       that it will go away if the table is dropped.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_INTERNAL</> (<literal>i</>)</term>
     <listitem>
      <para>
       The dependent object was created as part of creation of the
       referenced object, and is really just a part of its internal
       implementation.  A <command>DROP</> of the dependent object
       will be disallowed outright (we'll tell the user to issue a
       <command>DROP</> against the referenced object, instead).  A
       <command>DROP</> of the referenced object will be propagated
       through to drop the dependent object whether
       <command>CASCADE</> is specified or not.  Example: a trigger
       that's created to enforce a foreign-key constraint is made
       internally dependent on the constraint's
       <structname>pg_constraint</> entry.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PIN</> (<literal>p</>)</term>
     <listitem>
      <para>
       There is no dependent object; this type of entry is a signal
       that the system itself depends on the referenced object, and so
       that object must never be deleted.  Entries of this type are
       created only by <command>initdb</command>.  The columns for the
       dependent object contain zeroes.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Other dependency flavors might be needed in future.
  </para>

 </sect1>


 <sect1 id="catalog-pg-description">
  <title><structname>pg_description</structname></title>

  <indexterm zone="catalog-pg-description">
   <primary>pg_description</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_description</> stores optional descriptions
   (comments) for each database object.  Descriptions can be manipulated
   with the <xref linkend="sql-comment" endterm="sql-comment-title"> command and viewed with
   <application>psql</application>'s <literal>\d</literal> commands.
   Descriptions of many built-in system objects are provided in the initial
   contents of <structname>pg_description</structname>.
  </para>

  <para>
   See also <link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link>,
   which performs a similar function for descriptions involving objects that
   are shared across a database cluster.
  </para>

  <table>
   <title><structname>pg_description</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the object this description pertains to</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog this object appears in</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a comment on a table column, this is the column number (the
       <structfield>objoid</> and <structfield>classoid</> refer to
       the table itself).  For all other object types, this column is
       zero
      </entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Arbitrary text that serves as the description of this object</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-enum">
  <title><structname>pg_enum</structname></title>

  <indexterm zone="catalog-pg-enum">
   <primary>pg_enum</primary>
  </indexterm>

  <para>
   The <structname>pg_enum</structname> catalog contains entries
   matching enum types to their associated values and labels. The
   internal representation of a given enum value is actually the OID
   of its associated row in <structname>pg_enum</structname>.  The
   OIDs for a particular enum type are guaranteed to be ordered in
   the way the type should sort, but there is no guarantee about the
   ordering of OIDs of unrelated enum types.
  </para>

  <table>
   <title><structname>pg_enum</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>enumtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>The OID of the <structname>pg_type</> entry owning this enum value</entry>
     </row>

     <row>
      <entry><structfield>enumlabel</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>The textual label for this enum value</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-index">
  <title><structname>pg_index</structname></title>

  <indexterm zone="catalog-pg-index">
   <primary>pg_index</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_index</structname> contains part of the information
   about indexes.  The rest is mostly in
   <structname>pg_class</structname>.
  </para>

  <table>
   <title><structname>pg_index</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>indexrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the <structname>pg_class</> entry for this index</entry>
     </row>

     <row>
      <entry><structfield>indrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the <structname>pg_class</> entry for the table this index is for</entry>
     </row>

     <row>
      <entry><structfield>indnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>The number of columns in the index (duplicates
      <literal>pg_class.relnatts</literal>)</entry>
     </row>

     <row>
      <entry><structfield>indisunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this is a unique index</entry>
     </row>

     <row>
      <entry><structfield>indisprimary</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this index represents the primary key of the table
      (<structfield>indisunique</> should always be true when this is true)</entry>
     </row>

     <row>
      <entry><structfield>indisclustered</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, the table was last clustered on this index</entry>
     </row>

     <row>
      <entry><structfield>indisvalid</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true, the index is currently valid for queries.  False means the
       index is possibly incomplete: it must still be modified by
       <command>INSERT</>/<command>UPDATE</> operations, but it cannot safely
       be used for queries. If it is unique, the uniqueness property is not
       true either
      </entry>
     </row>

     <row>
      <entry><structfield>indcheckxmin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true, queries must not use the index until the <structfield>xmin</>
       of this <structname>pg_index</> row is below their TransactionXmin
       event horizon, because the table may contain broken HOT chains with
       incompatible rows that they can see
      </entry>
     </row>

     <row>
      <entry><structfield>indisready</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true, the index is currently ready for inserts.  False means the
       index must be ignored by <command>INSERT</>/<command>UPDATE</>
       operations
      </entry>
     </row>

     <row>
      <entry><structfield>indkey</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       This is an array of <structfield>indnatts</structfield> values that
       indicate which table columns this index indexes.  For example a value
       of <literal>1 3</literal> would mean that the first and the third table
       columns make up the index key.  A zero in this array indicates that the
       corresponding index attribute is an expression over the table columns,
       rather than a simple column reference
      </entry>
     </row>

     <row>
      <entry><structfield>indclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>
       For each column in the index key, this contains the OID of
       the operator class to use.  See
       <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link> for details
      </entry>
     </row>

     <row>
      <entry><structfield>indoption</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>
       This is an array of <structfield>indnatts</structfield> values that
       store per-column flag bits.  The meaning of the bits is defined by
       the index's access method
      </entry>
     </row>

     <row>
      <entry><structfield>indexprs</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Expression trees (in <function>nodeToString()</function> representation)
      for index attributes that are not simple column references.  This is a
      list with one element for each zero entry in <structfield>indkey</>.
      NULL if all index attributes are simple references</entry>
     </row>

     <row>
      <entry><structfield>indpred</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Expression tree (in <function>nodeToString()</function> representation)
      for partial index predicate.  NULL if not a partial index</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
  <title><structname>pg_inherits</structname></title>

  <indexterm zone="catalog-pg-inherits">
   <primary>pg_inherits</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_inherits</> records information about
   table inheritance hierarchies.  There is one entry for each direct
   child table in the database.  (Indirect inheritance can be determined
   by following chains of entries.)
  </para>

  <table>
   <title><structname>pg_inherits</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>inhrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       The OID of the child table
      </entry>
     </row>

     <row>
      <entry><structfield>inhparent</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       The OID of the parent table
      </entry>
     </row>

     <row>
      <entry><structfield>inhseqno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       If there is more than one direct parent for a child table (multiple
       inheritance), this number tells the order in which the
       inherited columns are to be arranged.  The count starts at 1
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-language">
  <title><structname>pg_language</structname></title>

  <indexterm zone="catalog-pg-language">
   <primary>pg_language</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_language</structname> registers
   languages in which you can write functions or stored procedures.
   See <xref linkend="sql-createlanguage" endterm="sql-createlanguage-title">
   and <xref linkend="xplang"> for more information about language handlers.
  </para>

  <table>
   <title><structname>pg_language</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>lanname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the language</entry>
     </row>

     <row>
      <entry><structfield>lanowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the language</entry>
     </row>

     <row>
      <entry><structfield>lanispl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This is false for internal languages (such as
       <acronym>SQL</acronym>) and true for user-defined languages.
       Currently, <application>pg_dump</application> still uses this
       to determine which languages need to be dumped, but this might be
       replaced by a different mechanism in the future
      </entry>
     </row>

     <row>
      <entry><structfield>lanpltrusted</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if this is a trusted language, which means that it is believed
       not to grant access to anything outside the normal SQL execution
       environment.  Only superusers can create functions in untrusted
       languages
      </entry>
     </row>

     <row>
      <entry><structfield>lanplcallfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       For noninternal languages this references the language
       handler, which is a special function that is responsible for
       executing all functions that are written in the particular
       language
      </entry>
     </row>

     <row>
      <entry><structfield>lanvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       This references a language validator function that is responsible
       for checking the syntax and validity of new functions when they
       are created.  Zero if no validator is provided
      </entry>
     </row>

     <row>
      <entry><structfield>lanacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see
       <xref linkend="sql-grant" endterm="sql-grant-title"> and
       <xref linkend="sql-revoke" endterm="sql-revoke-title">
       for details
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
  <title><structname>pg_largeobject</structname></title>

  <indexterm zone="catalog-pg-largeobject">
   <primary>pg_largeobject</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_largeobject</structname> holds the data making up
   <quote>large objects</quote>.  A large object is identified by an
   OID assigned when it is created.  Each large object is broken into
   segments or <quote>pages</> small enough to be conveniently stored as rows
   in <structname>pg_largeobject</structname>.
   The amount of data per page is defined to be <symbol>LOBLKSIZE</> (which is currently
   <literal>BLCKSZ/4</>, or typically 2 kB).
  </para>

  <table>
   <title><structname>pg_largeobject</> Columns</title>

   <tgroup cols=3>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>loid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>Identifier of the large object that includes this page</entry>
     </row>

     <row>
      <entry><structfield>pageno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>Page number of this page within its large object
      (counting from zero)</entry>
     </row>

     <row>
      <entry><structfield>data</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry>
       Actual data stored in the large object.
       This will never be more than <symbol>LOBLKSIZE</> bytes and might be less
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Each row of <structname>pg_largeobject</structname> holds data
   for one page of a large object, beginning at
   byte offset (<literal>pageno * LOBLKSIZE</>) within the object.  The implementation
   allows sparse storage: pages might be missing, and might be shorter than
   <literal>LOBLKSIZE</> bytes even if they are not the last page of the object.
   Missing regions within a large object read as zeroes.
  </para>

 </sect1>


 <sect1 id="catalog-pg-listener">
  <title><structname>pg_listener</structname></title>

  <indexterm zone="catalog-pg-listener">
   <primary>pg_listener</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_listener</structname> supports the
   <xref linkend="sql-listen" endterm="sql-listen-title"> and
   <xref linkend="sql-notify" endterm="sql-notify-title">
   commands.  A listener creates an entry in
   <structname>pg_listener</structname> for each notification name
   it is listening for.  A notifier scans <structname>pg_listener</structname>
   and updates each matching entry to show that a notification has occurred.
   The notifier also sends a signal (using the PID recorded in the table)
   to awaken the listener from sleep.
  </para>

  <table>
   <title><structname>pg_listener</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>
       Notify condition name.  (The name need not match any actual
       relation in the database; the name <structfield>relname</> is historical.)
      </entry>
     </row>

     <row>
      <entry><structfield>listenerpid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>PID of the server process that created this entry</entry>
     </row>

     <row>
      <entry><structfield>notification</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>
       Zero if no event is pending for this listener.  If an event is
       pending, the PID of the server process that sent the notification
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-namespace">
  <title><structname>pg_namespace</structname></title>

  <indexterm zone="catalog-pg-namespace">
   <primary>pg_namespace</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_namespace</> stores namespaces.
   A namespace is the structure underlying SQL schemas: each namespace
   can have a separate collection of relations, types, etc. without name
   conflicts.
  </para>

  <table>
   <title><structname>pg_namespace</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>nspname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the namespace</entry>
     </row>

     <row>
      <entry><structfield>nspowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the namespace</entry>
     </row>

     <row>
      <entry><structfield>nspacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see
       <xref linkend="sql-grant" endterm="sql-grant-title"> and
       <xref linkend="sql-revoke" endterm="sql-revoke-title">
       for details
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-opclass">
  <title><structname>pg_opclass</structname></title>

  <indexterm zone="catalog-pg-opclass">
   <primary>pg_opclass</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_opclass</structname> defines
   index access method operator classes.  Each operator class defines
   semantics for index columns of a particular data type and a particular
   index access method.  An operator class essentially specifies that a
   particular operator family is applicable to a particular indexable column
   data type.  The set of operators from the family that are actually usable
   with the indexed column are whichever ones accept the column's data type
   as their lefthand input.
  </para>

  <para>
   Operator classes are described at length in <xref linkend="xindex">.
  </para>

  <table>
   <title><structname>pg_opclass</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>opcmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Index access method operator class is for</entry>
     </row>

     <row>
      <entry><structfield>opcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of this operator class</entry>
     </row>

     <row>
      <entry><structfield>opcnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>Namespace of this operator class</entry>
     </row>

     <row>
      <entry><structfield>opcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the operator class</entry>
     </row>

     <row>
      <entry><structfield>opcfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <entry>Operator family containing the operator class</entry>
     </row>

     <row>
      <entry><structfield>opcintype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Data type that the operator class indexes</entry>
     </row>

     <row>
      <entry><structfield>opcdefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if this operator class is the default for <structfield>opcintype</></entry>
     </row>

     <row>
      <entry><structfield>opckeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type of data stored in index, or zero if same as <structfield>opcintype</></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   An operator class's <structfield>opcmethod</> must match the
   <structname>opfmethod</> of its containing operator family.
   Also, there must be no more than one <structname>pg_opclass</structname>
   row having <structname>opcdefault</> true for any given combination of
   <structname>opcmethod</> and <structname>opcintype</>.
  </para>

 </sect1>


 <sect1 id="catalog-pg-operator">
  <title><structname>pg_operator</structname></title>

  <indexterm zone="catalog-pg-operator">
   <primary>pg_operator</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_operator</> stores information about operators.
   See <xref linkend="sql-createoperator" endterm="sql-createoperator-title">
   and <xref linkend="xoper"> for more information.
  </para>

  <table>
   <title><structname>pg_operator</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oprname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the operator</entry>
     </row>

     <row>
      <entry><structfield>oprnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this operator
      </entry>
     </row>

     <row>
      <entry><structfield>oprowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the operator</entry>
     </row>

     <row>
      <entry><structfield>oprkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>b</> = infix (<quote>both</quote>), <literal>l</> = prefix
       (<quote>left</quote>), <literal>r</> = postfix (<quote>right</quote>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprcanmerge</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>This operator supports merge joins</entry>
     </row>

     <row>
      <entry><structfield>oprcanhash</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>This operator supports hash joins</entry>
     </row>

     <row>
      <entry><structfield>oprleft</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type of the left operand</entry>
     </row>

     <row>
      <entry><structfield>oprright</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type of the right operand</entry>
     </row>

     <row>
      <entry><structfield>oprresult</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type of the result</entry>
     </row>

     <row>
      <entry><structfield>oprcom</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Commutator of this operator, if any</entry>
     </row>

     <row>
      <entry><structfield>oprnegate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Negator of this operator, if any</entry>
     </row>

     <row>
      <entry><structfield>oprcode</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Function that implements this operator</entry>
     </row>

     <row>
      <entry><structfield>oprrest</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Restriction selectivity estimation function for this operator</entry>
     </row>

     <row>
      <entry><structfield>oprjoin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Join selectivity estimation function for this operator</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Unused column contain zeroes. For example, <structfield>oprleft</structfield>
   is zero for a prefix operator.
  </para>

 </sect1>


 <sect1 id="catalog-pg-opfamily">
  <title><structname>pg_opfamily</structname></title>

  <indexterm zone="catalog-pg-opfamily">
   <primary>pg_opfamily</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_opfamily</structname> defines operator families.
   Each operator family is a collection of operators and associated
   support routines that implement the semantics specified for a particular
   index access method.  Furthermore, the operators in a family are all
   <quote>compatible</>, in a way that is specified by the access method.
   The operator family concept allows cross-data-type operators to be used
   with indexes and to be reasoned about using knowledge of access method
   semantics.
  </para>

  <para>
   Operator families are described at length in <xref linkend="xindex">.
  </para>

  <table>
   <title><structname>pg_opfamily</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>opfmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Index access method operator family is for</entry>
     </row>

     <row>
      <entry><structfield>opfname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of this operator family</entry>
     </row>

     <row>
      <entry><structfield>opfnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>Namespace of this operator family</entry>
     </row>

     <row>
      <entry><structfield>opfowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the operator family</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   The majority of the information defining an operator family is not in its
   <structname>pg_opfamily</structname> row, but in the associated rows in
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>,
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>,
   and
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.
  </para>

 </sect1>


 <sect1 id="catalog-pg-pltemplate">
  <title><structname>pg_pltemplate</structname></title>

  <indexterm zone="catalog-pg-pltemplate">
   <primary>pg_pltemplate</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_pltemplate</structname> stores
   <quote>template</> information for procedural languages.
   A template for a language allows the language to be created in a
   particular database by a simple <command>CREATE LANGUAGE</> command,
   with no need to specify implementation details.
  </para>

  <para>
   Unlike most system catalogs, <structname>pg_pltemplate</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_pltemplate</structname> per cluster, not
   one per database.  This allows the information to be accessible in
   each database as it is needed.
  </para>

  <table>
   <title><structname>pg_pltemplate</> Columns</title>

   <tgroup cols=3>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry>Name of the language this template is for</entry>
     </row>

     <row>
      <entry><structfield>tmpltrusted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True if language is considered trusted</entry>
     </row>

     <row>
      <entry><structfield>tmpldbacreate</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True if language may be created by a database owner</entry>
     </row>

     <row>
      <entry><structfield>tmplhandler</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Name of call handler function</entry>
     </row>

     <row>
      <entry><structfield>tmplvalidator</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Name of validator function, or NULL if none</entry>
     </row>

     <row>
      <entry><structfield>tmpllibrary</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Path of shared library that implements language</entry>
     </row>

     <row>
      <entry><structfield>tmplacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry>Access privileges for template (not yet used)</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   There are not currently any commands that manipulate procedural language
   templates; to change the built-in information, a superuser must modify
   the table using ordinary <command>INSERT</command>, <command>DELETE</command>,
   or <command>UPDATE</command> commands.  It is likely that a future
   release of <productname>PostgreSQL</productname> will offer
   commands to change the entries in a cleaner fashion.
  </para>

  <para>
   When implemented, the <structfield>tmplacl</structfield> field will provide
   access control for the template itself (i.e., the right to create a
   language using it), not for the languages created from the template.
  </para>

 </sect1>


 <sect1 id="catalog-pg-proc">
  <title><structname>pg_proc</structname></title>

  <indexterm zone="catalog-pg-proc">
   <primary>pg_proc</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_proc</> stores information about functions (or procedures).
   See <xref linkend="sql-createfunction" endterm="sql-createfunction-title">
   and <xref linkend="xfunc"> for more information.
  </para>

  <para>
   The table contains data for aggregate functions as well as plain functions.
   If <structfield>proisagg</structfield> is true, there should be a matching
   row in <structfield>pg_aggregate</structfield>.
  </para>

  <table>
   <title><structname>pg_proc</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>proname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the function</entry>
     </row>

     <row>
      <entry><structfield>pronamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this function
      </entry>
     </row>

     <row>
      <entry><structfield>proowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the function</entry>
     </row>

     <row>
      <entry><structfield>prolang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-language"><structname>pg_language</structname></link>.oid</literal></entry>
      <entry>Implementation language or call interface of this function</entry>
     </row>

     <row>
      <entry><structfield>procost</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Estimated execution cost (in units of
       <xref linkend="guc-cpu-operator-cost">); if <structfield>proretset</>,
       this is cost per row returned</entry>
     </row>

     <row>
      <entry><structfield>prorows</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>Estimated number of result rows (zero if not <structfield>proretset</>)</entry>
     </row>

     <row>
      <entry><structfield>proisagg</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function is an aggregate function</entry>
     </row>

     <row>
      <entry><structfield>prosecdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function is a security definer (i.e., a <quote>setuid</>
      function)</entry>
     </row>

     <row>
      <entry><structfield>proisstrict</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Function returns null if any call argument is null.  In that
       case the function won't actually be called at all.  Functions
       that are not <quote>strict</quote> must be prepared to handle
       null inputs
      </entry>
     </row>

     <row>
      <entry><structfield>proretset</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function returns a set (i.e., multiple values of the specified
      data type)</entry>
     </row>

     <row>
      <entry><structfield>provolatile</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>provolatile</structfield> tells whether the function's
       result depends only on its input arguments, or is affected by outside
       factors.
       It is <literal>i</literal> for <quote>immutable</> functions,
       which always deliver the same result for the same inputs.
       It is <literal>s</literal> for <quote>stable</> functions,
       whose results (for fixed inputs) do not change within a scan.
       It is <literal>v</literal> for <quote>volatile</> functions,
       whose results might change at any time.  (Use <literal>v</literal> also
       for functions with side-effects, so that calls to them cannot get
       optimized away.)
      </entry>
     </row>

     <row>
      <entry><structfield>pronargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of arguments</entry>
     </row>

     <row>
      <entry><structfield>prorettype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Data type of the return value</entry>
     </row>

     <row>
      <entry><structfield>proargtypes</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       An array with the data types of the function arguments.  This includes
       only input arguments (including <literal>INOUT</literal> arguments), and thus represents
       the call signature of the function
      </entry>
     </row>

     <row>
      <entry><structfield>proallargtypes</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       An array with the data types of the function arguments.  This includes
       all arguments (including <literal>OUT</literal> and <literal>INOUT</literal> arguments); however, if all the
       arguments are IN arguments, this field will be null.
       Note that subscripting is 1-based, whereas for historical reasons
       <structfield>proargtypes</> is subscripted from 0
      </entry>
     </row>

     <row>
      <entry><structfield>proargmodes</structfield></entry>
      <entry><type>char[]</type></entry>
      <entry></entry>
      <entry>
        An array with the modes of the function arguments, encoded as
        <literal>i</literal> for <literal>IN</> arguments,
        <literal>o</literal> for <literal>OUT</> arguments,
        <literal>b</literal> for <literal>INOUT</> arguments.
        If all the arguments are <literal>IN</literal> arguments, this field will be null.
        Note that subscripts correspond to positions of
        <structfield>proallargtypes</> not <structfield>proargtypes</>
      </entry>
     </row>

     <row>
      <entry><structfield>proargnames</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
        An array with the names of the function arguments.
        Arguments without a name are set to empty strings in the array.
        If none of the arguments have a name, this field will be null.
        Note that subscripts correspond to positions of
        <structfield>proallargtypes</> not <structfield>proargtypes</>
      </entry>
     </row>

     <row>
      <entry><structfield>prosrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       This tells the function handler how to invoke the function.  It
       might be the actual source code of the function for interpreted
       languages, a link symbol, a file name, or just about anything
       else, depending on the implementation language/call convention
      </entry>
     </row>

     <row>
      <entry><structfield>probin</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       Additional information about how to invoke the function.
       Again, the interpretation is language-specific
      </entry>
     </row>

     <row>
      <entry><structfield>proconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Function's local settings for run-time configuration variables</entry>
     </row>

     <row>
      <entry><structfield>proacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see
       <xref linkend="sql-grant" endterm="sql-grant-title"> and
       <xref linkend="sql-revoke" endterm="sql-revoke-title">
       for details
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   For compiled functions, both built-in and dynamically loaded,
   <structfield>prosrc</structfield> contains the function's C-language
   name (link symbol).  For all other currently-known language types,
   <structfield>prosrc</structfield> contains the function's source
   text.  <structfield>probin</structfield> is unused except for
   dynamically-loaded C functions, for which it gives the name of the
   shared library file containing the function.
  </para>

 </sect1>

 <sect1 id="catalog-pg-rewrite">
  <title><structname>pg_rewrite</structname></title>

  <indexterm zone="catalog-pg-rewrite">
   <primary>pg_rewrite</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_rewrite</structname> stores rewrite rules for tables and views.
  </para>

  <table>
   <title><structname>pg_rewrite</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Rule name</entry>
     </row>

     <row>
      <entry><structfield>ev_class</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this rule is for</entry>
     </row>

     <row>
      <entry><structfield>ev_attr</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>The column this rule is for (currently, always zero to
      indicate the whole table)</entry>
     </row>

     <row>
      <entry><structfield>ev_type</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Event type that the rule is for: 1 = <command>SELECT</>, 2 =
       <command>UPDATE</>, 3 = <command>INSERT</>, 4 =
       <command>DELETE</>
      </entry>
     </row>

     <row>
      <entry><structfield>ev_enabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Controls in which <xref linkend="guc-session-replication-role"> modes
       the rule fires.
       <literal>O</> = rule fires in <quote>origin</> and <quote>local</> modes,
       <literal>D</> = rule is disabled,
       <literal>R</> = rule fires in <quote>replica</> mode,
       <literal>A</> = rule fires always.
      </entry>
     </row>

     <row>
      <entry><structfield>is_instead</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if the rule is an <literal>INSTEAD</literal> rule</entry>
     </row>

     <row>
      <entry><structfield>ev_qual</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Expression tree (in the form of a
       <function>nodeToString()</function> representation) for the
       rule's qualifying condition
      </entry>
     </row>

     <row>
      <entry><structfield>ev_action</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Query tree (in the form of a
       <function>nodeToString()</function> representation) for the
       rule's action
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <literal>pg_class.relhasrules</literal>
    must be true if a table has any rules in this catalog.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-shdepend">
  <title><structname>pg_shdepend</structname></title>

  <indexterm zone="catalog-pg-shdepend">
   <primary>pg_shdepend</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_shdepend</structname> records the
   dependency relationships between database objects and shared objects,
   such as roles.  This information allows
   <productname>PostgreSQL</productname> to ensure that those objects are
   unreferenced before attempting to delete them.
  </para>

  <para>
   See also <link linkend="catalog-pg-depend"><structname>pg_depend</structname></link>,
   which performs a similar function for dependencies involving objects
   within a single database.
  </para>

  <para>
   Unlike most system catalogs, <structname>pg_shdepend</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_shdepend</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title><structname>pg_shdepend</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>The OID of the database the dependent object is in,
       or zero for a shared object</entry>
     </row>

     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog the dependent object is in</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the specific dependent object</entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog the referenced object is in
       (must be a shared catalog)</entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the specific referenced object</entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A code defining the specific semantics of this dependency relationship; see text
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   In all cases, a <structname>pg_shdepend</structname> entry indicates that
   the referenced object cannot be dropped without also dropping the dependent
   object.  However, there are several subflavors identified by
   <structfield>deptype</>:

   <variablelist>
    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_OWNER</> (<literal>o</>)</term>
     <listitem>
      <para>
       The referenced object (which must be a role) is the owner of the
       dependent object.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_ACL</> (<literal>a</>)</term>
     <listitem>
      <para>
       The referenced object (which must be a role) is mentioned in the
       ACL (access control list, i.e., privileges list) of the
       dependent object.  (A <symbol>SHARED_DEPENDENCY_ACL</> entry is
       not made for the owner of the object, since the owner will have
       a <symbol>SHARED_DEPENDENCY_OWNER</> entry anyway.)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_PIN</> (<literal>p</>)</term>
     <listitem>
      <para>
       There is no dependent object; this type of entry is a signal
       that the system itself depends on the referenced object, and so
       that object must never be deleted.  Entries of this type are
       created only by <command>initdb</command>.  The columns for the
       dependent object contain zeroes.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Other dependency flavors might be needed in future.  Note in particular
   that the current definition only supports roles as referenced objects.
  </para>

 </sect1>

 <sect1 id="catalog-pg-shdescription">
  <title><structname>pg_shdescription</structname></title>

  <indexterm zone="catalog-pg-shdescription">
   <primary>pg_shdescription</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_shdescription</structname> stores optional
   descriptions (comments) for shared database objects.  Descriptions can be
   manipulated with the <xref linkend="sql-comment"
   endterm="sql-comment-title"> command and viewed with
   <application>psql</application>'s <literal>\d</literal> commands.
  </para>

  <para>
   See also <link linkend="catalog-pg-description"><structname>pg_description</structname></link>,
   which performs a similar function for descriptions involving objects
   within a single database.
  </para>

  <para>
   Unlike most system catalogs, <structname>pg_shdescription</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_shdescription</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title><structname>pg_shdescription</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the object this description pertains to</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog this object appears in</entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Arbitrary text that serves as the description of this object</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-statistic">
  <title><structname>pg_statistic</structname></title>

  <indexterm zone="catalog-pg-statistic">
   <primary>pg_statistic</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_statistic</structname> stores
   statistical data about the contents of the database.  Entries are
   created by <xref linkend="sql-analyze" endterm="sql-analyze-title">
   and subsequently used by the query planner.  There is one entry for
   each table column that has been analyzed.  Note that all the
   statistical data is inherently approximate, even assuming that it
   is up-to-date.
  </para>

  <para>
   <structname>pg_statistic</structname> also stores statistical data about
   the values of index expressions.  These are described as if they were
   actual data columns; in particular, <structfield>starelid</structfield>
   references the index.  No entry is made for an ordinary non-expression
   index column, however, since it would be redundant with the entry
   for the underlying table column.
  </para>

  <para>
   Since different kinds of statistics might be appropriate for different
   kinds of data, <structname>pg_statistic</structname> is designed not
   to assume very much about what sort of statistics it stores.  Only
   extremely general statistics (such as nullness) are given dedicated
   columns in <structname>pg_statistic</structname>.  Everything else
   is stored in <quote>slots</quote>, which are groups of associated columns
   whose content is identified by a code number in one of the slot's columns.
   For more information see
   <filename>src/include/catalog/pg_statistic.h</filename>.
  </para>

  <para>
   <structname>pg_statistic</structname> should not be readable by the
   public, since even statistical information about a table's contents
   might be considered sensitive.  (Example: minimum and maximum values
   of a salary column might be quite interesting.)
   <link linkend="view-pg-stats"><structname>pg_stats</structname></link>
   is a publicly readable view on
   <structname>pg_statistic</structname> that only exposes information
   about those tables that are readable by the current user.
  </para>

  <table>
   <title><structname>pg_statistic</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>starelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table or index that the described column belongs to</entry>
     </row>

     <row>
      <entry><structfield>staattnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>The number of the described column</entry>
     </row>

     <row>
      <entry><structfield>stanullfrac</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>The fraction of the column's entries that are null</entry>
     </row>

     <row>
      <entry><structfield>stawidth</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>The average stored width, in bytes, of nonnull entries</entry>
     </row>

     <row>
      <entry><structfield>stadistinct</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>The number of distinct nonnull data values in the column.
      A value greater than zero is the actual number of distinct values.
      A value less than zero is the negative of a fraction of the number
      of rows in the table (for example, a column in which values appear about
      twice on the average could be represented by <structfield>stadistinct</> = -0.5).
      A zero value means the number of distinct values is unknown
      </entry>
     </row>

     <row>
      <entry><structfield>stakind<replaceable>N</></structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       A code number indicating the kind of statistics stored in the
       <replaceable>N</>th <quote>slot</quote> of the
       <structname>pg_statistic</structname> row
      </entry>
     </row>

     <row>
      <entry><structfield>staop<replaceable>N</></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       An operator used to derive the statistics stored in the
       <replaceable>N</>th <quote>slot</quote>.  For example, a
       histogram slot would show the <literal>&lt;</literal> operator
       that defines the sort order of the data
      </entry>
     </row>

     <row>
      <entry><structfield>stanumbers<replaceable>N</></structfield></entry>
      <entry><type>float4[]</type></entry>
      <entry></entry>
      <entry>
       Numerical statistics of the appropriate kind for the
       <replaceable>N</>th <quote>slot</quote>, or NULL if the slot
       kind does not involve numerical values
      </entry>
     </row>

     <row>
      <entry><structfield>stavalues<replaceable>N</></structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       Column data values of the appropriate kind for the
       <replaceable>N</>th <quote>slot</quote>, or NULL if the slot
       kind does not store any data values.  Each array's element
       values are actually of the specific column's data type, so there
       is no way to define these columns' type more specifically than
       <type>anyarray</>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-tablespace">
  <title><structname>pg_tablespace</structname></title>

  <indexterm zone="catalog-pg-tablespace">
   <primary>pg_tablespace</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_tablespace</structname> stores information
   about the available tablespaces.  Tables can be placed in particular
   tablespaces to aid administration of disk layout.
  </para>

  <para>
   Unlike most system catalogs, <structname>pg_tablespace</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_tablespace</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title><structname>pg_tablespace</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>spcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Tablespace name</entry>
     </row>

     <row>
      <entry><structfield>spcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the tablespace, usually the user who created it</entry>
     </row>

     <row>
      <entry><structfield>spclocation</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Location (directory path) of the tablespace</entry>
     </row>

     <row>
      <entry><structfield>spcacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see
       <xref linkend="sql-grant" endterm="sql-grant-title"> and
       <xref linkend="sql-revoke" endterm="sql-revoke-title">
       for details
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-trigger">
  <title><structname>pg_trigger</structname></title>

  <indexterm zone="catalog-pg-trigger">
   <primary>pg_trigger</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_trigger</structname> stores triggers on tables.
   See <xref linkend="sql-createtrigger" endterm="sql-createtrigger-title">
   for more information.
  </para>

  <table>
   <title><structname>pg_trigger</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tgrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this trigger is on</entry>
     </row>

     <row>
      <entry><structfield>tgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Trigger name (must be unique among triggers of same table)</entry>
     </row>

     <row>
      <entry><structfield>tgfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>The function to be called</entry>
     </row>

     <row>
      <entry><structfield>tgtype</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Bit mask identifying trigger conditions</entry>
     </row>

     <row>
      <entry><structfield>tgenabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Controls in which <xref linkend="guc-session-replication-role"> modes
       the trigger fires.
       <literal>O</> = trigger fires in <quote>origin</> and <quote>local</> modes,
       <literal>D</> = trigger is disabled,
       <literal>R</> = trigger fires in <quote>replica</> mode,
       <literal>A</> = trigger fires always.
      </entry>
     </row>

     <row>
      <entry><structfield>tgisconstraint</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if trigger is a <quote>constraint trigger</></entry>
     </row>

     <row>
      <entry><structfield>tgconstrname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Constraint name, if a constraint trigger</entry>
     </row>

     <row>
      <entry><structfield>tgconstrrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table referenced by a referential integrity constraint</entry>
     </row>

     <row>
      <entry><structfield>tgconstraint</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.oid</literal></entry>
      <entry>The <structname>pg_constraint</> entry owning the trigger, if any</entry>
     </row>

     <row>
      <entry><structfield>tgdeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if constraint trigger is deferrable</entry>
     </row>

     <row>
      <entry><structfield>tginitdeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if constraint trigger is initially deferred</entry>
     </row>

     <row>
      <entry><structfield>tgnargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of argument strings passed to trigger function</entry>
     </row>

     <row>
      <entry><structfield>tgattr</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>Currently unused</entry>
     </row>

     <row>
      <entry><structfield>tgargs</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>Argument strings to pass to trigger, each NULL-terminated</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    When <structfield>tgconstraint</> is nonzero,
    <structfield>tgisconstraint</> must be true, and
    <structfield>tgconstrname</>, <structfield>tgconstrrelid</>,
    <structfield>tgdeferrable</>, <structfield>tginitdeferred</> are redundant
    with the referenced <structname>pg_constraint</> entry.  The reason we
    keep these fields is that we support <quote>stand-alone</> constraint
    triggers with no corresponding <structname>pg_constraint</> entry.
   </para>
  </note>

  <note>
   <para>
    <literal>pg_class.reltriggers</literal> needs to agree with the
    number of triggers found in this table for each relation.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-ts-config">
  <title><structname>pg_ts_config</structname></title>

  <indexterm zone="catalog-pg-ts-config">
   <primary>pg_ts_config</primary>
  </indexterm>

  <para>
   The <structname>pg_ts_config</structname> catalog contains entries
   representing text search configurations.  A configuration specifies
   a particular text search parser and a list of dictionaries to use
   for each of the parser's output token types.  The parser is shown
   in the <structname>pg_ts_config</structname> entry, but the
   token-to-dictionary mapping is defined by subsidiary entries in <link
   linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link>.
  </para>

  <para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch">.
  </para>

  <table>
   <title><structname>pg_ts_config</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>cfgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Text search configuration name</entry>
     </row>

     <row>
      <entry><structfield>cfgnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this configuration
      </entry>
     </row>

     <row>
      <entry><structfield>cfgowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the configuration</entry>
     </row>

     <row>
      <entry><structfield>cfgparser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link>.oid</literal></entry>
      <entry>The OID of the text search parser for this configuration</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-config-map">
  <title><structname>pg_ts_config_map</structname></title>

  <indexterm zone="catalog-pg-ts-config-map">
   <primary>pg_ts_config_map</primary>
  </indexterm>

  <para>
   The <structname>pg_ts_config_map</structname> catalog contains entries
   showing which text search dictionaries should be consulted, and in
   what order, for each output token type of each text search configuration's
   parser.
  </para>

  <para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch">.
  </para>

  <table>
   <title><structname>pg_ts_config_map</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>mapcfg</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link>.oid</literal></entry>
      <entry>The OID of the <structname>pg_ts_config</> entry owning this map entry</entry>
     </row>

     <row>
      <entry><structfield>maptokentype</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>A token type emitted by the configuration's parser</entry>
     </row>

     <row>
      <entry><structfield>mapseqno</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Order in which to consult this entry (lower
       <structfield>mapseqno</>s first)</entry>
     </row>

     <row>
      <entry><structfield>mapdict</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link>.oid</literal></entry>
      <entry>The OID of the text search dictionary to consult</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-dict">
  <title><structname>pg_ts_dict</structname></title>

  <indexterm zone="catalog-pg-ts-dict">
   <primary>pg_ts_dict</primary>
  </indexterm>

  <para>
   The <structname>pg_ts_dict</structname> catalog contains entries
   defining text search dictionaries.  A dictionary depends on a text
   search template, which specifies all the implementation functions
   needed; the dictionary itself provides values for the user-settable
   parameters supported by the template.  This division of labor allows
   dictionaries to be created by unprivileged users.  The parameters
   are specified by a text string <structfield>dictinitoption</>,
   whose format and meaning vary depending on the template.
  </para>

  <para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch">.
  </para>

  <table>
   <title><structname>pg_ts_dict</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>dictname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Text search dictionary name</entry>
     </row>

     <row>
      <entry><structfield>dictnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this dictionary
      </entry>
     </row>

     <row>
      <entry><structfield>dictowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the dictionary</entry>
     </row>

     <row>
      <entry><structfield>dicttemplate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link>.oid</literal></entry>
      <entry>The OID of the text search template for this dictionary</entry>
     </row>

     <row>
      <entry><structfield>dictinitoption</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Initialization option string for the template</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-parser">
  <title><structname>pg_ts_parser</structname></title>

  <indexterm zone="catalog-pg-ts-parser">
   <primary>pg_ts_parser</primary>
  </indexterm>

  <para>
   The <structname>pg_ts_parser</structname> catalog contains entries
   defining text search parsers.  A parser is responsible for splitting
   input text into lexemes and assigning a token type to each lexeme.
   Since a parser must be implemented by C-language-level functions,
   creation of new parsers is restricted to database superusers.
  </para>

  <para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch">.
  </para>

  <table>
   <title><structname>pg_ts_parser</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>prsname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Text search parser name</entry>
     </row>

     <row>
      <entry><structfield>prsnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this parser
      </entry>
     </row>

     <row>
      <entry><structfield>prsstart</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the parser's startup function</entry>
     </row>

     <row>
      <entry><structfield>prstoken</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the parser's next-token function</entry>
     </row>

     <row>
      <entry><structfield>prsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the parser's shutdown function</entry>
     </row>

     <row>
      <entry><structfield>prsheadline</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the parser's headline function</entry>
     </row>

     <row>
      <entry><structfield>prslextype</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the parser's lextype function</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-template">
  <title><structname>pg_ts_template</structname></title>

  <indexterm zone="catalog-pg-ts-template">
   <primary>pg_ts_template</primary>
  </indexterm>

  <para>
   The <structname>pg_ts_template</structname> catalog contains entries
   defining text search templates.  A template is the implementation
   skeleton for a class of text search dictionaries.
   Since a template must be implemented by C-language-level functions,
   creation of new templates is restricted to database superusers.
  </para>

  <para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch">.
  </para>

  <table>
   <title><structname>pg_ts_template</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Text search template name</entry>
     </row>

     <row>
      <entry><structfield>tmplnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this template
      </entry>
     </row>

     <row>
      <entry><structfield>tmplinit</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the template's initialization function</entry>
     </row>

     <row>
      <entry><structfield>tmpllexize</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the template's lexize function</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-type">
  <title><structname>pg_type</structname></title>

  <indexterm zone="catalog-pg-type">
   <primary>pg_type</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_type</structname> stores information about data
   types.  Base types (scalar types) are created with
   <xref linkend="sql-createtype" endterm="sql-createtype-title">, and
   domains with
   <xref linkend="sql-createdomain" endterm="sql-createdomain-title">.
   A composite type is automatically created for each table in the database, to
   represent the row structure of the table.  It is also possible to create
   composite types with <command>CREATE TYPE AS</command>.
  </para>

  <table>
   <title><structname>pg_type</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>typname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Data type name</entry>
     </row>

     <row>
      <entry><structfield>typnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this type
      </entry>
     </row>

     <row>
      <entry><structfield>typowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>Owner of the type</entry>
     </row>

     <row>
      <entry><structfield>typlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       For a fixed-size type, <structfield>typlen</structfield> is the number
       of bytes in the internal representation of the type.  But for a
       variable-length type, <structfield>typlen</structfield> is negative.
       -1 indicates a <quote>varlena</> type (one that has a length word),
       -2 indicates a null-terminated C string.
      </entry>
     </row>

     <row>
      <entry><structfield>typbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <structfield>typbyval</structfield> determines whether internal
       routines pass a value of this type by value or by reference.
       <structfield>typbyval</structfield> had better be false if
       <structfield>typlen</structfield> is not 1, 2, or 4 (or 8 on machines
       where Datum is 8 bytes).
       Variable-length types are always passed by reference. Note that
       <structfield>typbyval</structfield> can be false even if the
       length would allow pass-by-value; this is currently true for
       type <type>float4</type>, for example
      </entry>
     </row>

     <row>
      <entry><structfield>typtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typtype</structfield> is
       <literal>b</literal> for a base type,
       <literal>c</literal> for a composite type (e.g., a table's row type),
       <literal>d</literal> for a domain,
       <literal>e</literal> for an enum type,
       or <literal>p</literal> for a pseudo-type.
       See also <structfield>typrelid</structfield> and
       <structfield>typbasetype</structfield>
      </entry>
     </row>

     <row>
      <entry><structfield>typisdefined</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if the type is defined, false if this is a placeholder
       entry for a not-yet-defined type.  When
       <structfield>typisdefined</structfield> is false, nothing
       except the type name, namespace, and OID can be relied on
      </entry>
     </row>

     <row>
      <entry><structfield>typdelim</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Character that separates two values of this type when parsing
       array input.  Note that the delimiter is associated with the array
       element data type, not the array data type
      </entry>
     </row>

     <row>
      <entry><structfield>typrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       If this is a composite type (see
       <structfield>typtype</structfield>), then this column points to
       the <structname>pg_class</structname> entry that defines the
       corresponding table.  (For a free-standing composite type, the
       <structname>pg_class</structname> entry doesn't really represent
       a table, but it is needed anyway for the type's
       <structname>pg_attribute</structname> entries to link to.)
       Zero for non-composite types
      </entry>
     </row>

     <row>
      <entry><structfield>typelem</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       If <structfield>typelem</structfield> is not 0 then it
       identifies another row in <structname>pg_type</structname>.
       The current type can then be subscripted like an array yielding
       values of type <structfield>typelem</structfield>.  A
       <quote>true</quote> array type is variable length
       (<structfield>typlen</structfield> = -1),
       but some fixed-length (<structfield>typlen</structfield> &gt; 0) types
       also have nonzero <structfield>typelem</structfield>, for example
       <type>name</type> and <type>point</type>.
       If a fixed-length type has a <structfield>typelem</structfield> then
       its internal representation must be some number of values of the
       <structfield>typelem</structfield> data type with no other data.
       Variable-length array types have a header defined by the array
       subroutines
      </entry>
     </row>

     <row>
      <entry><structfield>typarray</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       If <structfield>typarray</structfield> is not 0 then it
       identifies another row in <structname>pg_type</structname>, which
       is the <quote>true</quote> array type having this type as element
      </entry>
     </row>

     <row>
      <entry><structfield>typinput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Input conversion function (text format)</entry>
     </row>

     <row>
      <entry><structfield>typoutput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Output conversion function (text format)</entry>
     </row>

     <row>
      <entry><structfield>typreceive</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Input conversion function (binary format), or 0 if none</entry>
     </row>

     <row>
      <entry><structfield>typsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Output conversion function (binary format), or 0 if none</entry>
     </row>

     <row>
      <entry><structfield>typmodin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Type modifier input function, or 0 if type does not support modifiers</entry>
     </row>

     <row>
      <entry><structfield>typmodout</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Type modifier output function, or 0 to use the standard format</entry>
     </row>

     <row>
      <entry><structfield>typanalyze</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Custom ANALYZE function, or 0 to use the standard function</entry>
     </row>

     <row>
      <entry><structfield>typalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>

       <structfield>typalign</structfield> is the alignment required
       when storing a value of this type.  It applies to storage on
       disk as well as most representations of the value inside
       <productname>PostgreSQL</>.
       When multiple values are stored consecutively, such
       as in the representation of a complete row on disk, padding is
       inserted before a datum of this type so that it begins on the
       specified boundary.  The alignment reference is the beginning
       of the first datum in the sequence.
      </para><para>
       Possible values are:
       <itemizedlist>
        <listitem>
         <para><literal>c</> = <type>char</type> alignment, i.e., no alignment needed.</para>
        </listitem>
        <listitem>
         <para><literal>s</> = <type>short</type> alignment (2 bytes on most machines).</para>
        </listitem>
        <listitem>
         <para><literal>i</> = <type>int</type> alignment (4 bytes on most machines).</para>
        </listitem>
        <listitem>
         <para><literal>d</> = <type>double</type> alignment (8 bytes on many machines, but by no means all).</para>
        </listitem>
       </itemizedlist>
      </para><note>
       <para>
        For types used in system tables, it is critical that the size
        and alignment defined in <structname>pg_type</structname>
        agree with the way that the compiler will lay out the column in
        a structure representing a table row.
       </para>
      </note></entry>
     </row>

     <row>
      <entry><structfield>typstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typstorage</structfield> tells for varlena
       types (those with <structfield>typlen</structfield> = -1) if
       the type is prepared for toasting and what the default strategy
       for attributes of this type should be.
       Possible values are
       <itemizedlist>
        <listitem>
         <para><literal>p</>: Value must always be stored plain.</para>
        </listitem>
        <listitem>
         <para>
          <literal>e</>: Value can be stored in a <quote>secondary</quote>
          relation (if relation has one, see
          <literal>pg_class.reltoastrelid</literal>).
         </para>
        </listitem>
        <listitem>
         <para><literal>m</>: Value can be stored compressed inline.</para>
        </listitem>
        <listitem>
         <para><literal>x</>: Value can be stored compressed inline or stored in <quote>secondary</quote> storage.</para>
        </listitem>
       </itemizedlist>
       Note that <literal>m</> columns can also be moved out to secondary
       storage, but only as a last resort (<literal>e</> and <literal>x</> columns are
       moved first).
      </para></entry>
     </row>

     <row>
      <entry><structfield>typnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typnotnull</structfield> represents a not-null
       constraint on a type.  Used for domains only
      </para></entry>
     </row>

     <row>
      <entry><structfield>typbasetype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry><para>
       If this is a domain (see <structfield>typtype</structfield>), then
       <structfield>typbasetype</structfield> identifies the type that this
       one is based on.  Zero if this type is not a domain
      </para></entry>
     </row>

     <row>
      <entry><structfield>typtypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       Domains use <structfield>typtypmod</structfield> to record the <literal>typmod</>
       to be applied to their base type (-1 if base type does not use a
       <literal>typmod</>).  -1 if this type is not a domain
      </para></entry>
     </row>

     <row>
      <entry><structfield>typndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typndims</structfield> is the number of array dimensions
       for a domain that is an array (that is, <structfield>typbasetype</> is
       an array type; the domain's <structfield>typelem</> will match the base
       type's <structfield>typelem</structfield>).
       Zero for types other than domains over array types
       </para></entry>
     </row>

     <row>
      <entry><structfield>typdefaultbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       If <structfield>typdefaultbin</> is not null, it is the <function>nodeToString()</function>
       representation of a default expression for the type.  This is
       only used for domains
      </para></entry>
     </row>

     <row>
      <entry><structfield>typdefault</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typdefault</> is null if the type has no associated
       default value. If <structfield>typdefaultbin</> is not null,
       <structfield>typdefault</> must contain a human-readable version of the
       default expression represented by <structfield>typdefaultbin</>.  If
       <structfield>typdefaultbin</> is null and <structfield>typdefault</> is
       not, then <structfield>typdefault</> is the external representation of
       the type's default value, which might be fed to the type's input
       converter to produce a constant
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="views-overview">
  <title>System Views</title>

  <para>
   In addition to the system catalogs, <productname>PostgreSQL</productname>
   provides a number of built-in views.  Some system views provide convenient
   access to some commonly used queries on the system catalogs.  Other views
   provide access to internal server state.
  </para>

  <para>
   The information schema (<xref linkend="information-schema">) provides
   an alternative set of views which overlap the functionality of the system
   views.  Since the information schema is SQL-standard whereas the views
   described here are <productname>PostgreSQL</productname>-specific,
   it's usually better to use the information schema if it provides all
   the information you need.
  </para>

  <para>
   <xref linkend="view-table"> lists the system views described here.
   More detailed documentation of each view follows below.
   There are some additional views that provide access to the results of
   the statistics collector; they are described in <xref
   linkend="monitoring-stats-views-table">.
  </para>

  <para>
   Except where noted, all the views described here are read-only.
  </para>

  <table id="view-table">
   <title>System Views</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>View Name</entry>
      <entry>Purpose</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="view-pg-cursors"><structname>pg_cursors</structname></link></entry>
      <entry>open cursors</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-group"><structname>pg_group</structname></link></entry>
      <entry>groups of database users</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-indexes"><structname>pg_indexes</structname></link></entry>
      <entry>indexes</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-locks"><structname>pg_locks</structname></link></entry>
      <entry>currently held locks</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-statements"><structname>pg_prepared_statements</structname></link></entry>
      <entry>prepared statements</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link></entry>
      <entry>prepared transactions</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-roles"><structname>pg_roles</structname></link></entry>
      <entry>database roles</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-rules"><structname>pg_rules</structname></link></entry>
      <entry>rules</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-settings"><structname>pg_settings</structname></link></entry>
      <entry>parameter settings</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-shadow"><structname>pg_shadow</structname></link></entry>
      <entry>database users</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-stats"><structname>pg_stats</structname></link></entry>
      <entry>planner statistics</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-tables"><structname>pg_tables</structname></link></entry>
      <entry>tables</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link></entry>
      <entry>time zone abbreviations</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-timezone-names"><structname>pg_timezone_names</structname></link></entry>
      <entry>time zone names</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user"><structname>pg_user</structname></link></entry>
      <entry>database users</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-views"><structname>pg_views</structname></link></entry>
      <entry>views</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-cursors">
  <title><structname>pg_cursors</structname></title>

  <indexterm zone="view-pg-cursors">
   <primary>pg_cursors</primary>
  </indexterm>

  <para>
   The <structname>pg_cursors</structname> view lists the cursors that
   are currently available. Cursors can be defined in several ways:
   <itemizedlist>
    <listitem>
     <para>
      via the <xref linkend="sql-declare" endterm="sql-declare-title">
      statement in SQL
     </para>
    </listitem>

    <listitem>
     <para>
      via the Bind message in the frontend/backend protocol, as
      described in <xref linkend="protocol-flow-ext-query">
     </para>
    </listitem>

    <listitem>
     <para>
      via the Server Programming Interface (SPI), as described in
      <xref linkend="spi-interface">
     </para>
    </listitem>
   </itemizedlist>

   The <structname>pg_cursors</structname> view displays cursors
   created by any of these means. Cursors only exist for the duration
   of the transaction that defines them, unless they have been
   declared <literal>WITH HOLD</literal>. Therefore non-holdable
   cursors are only present in the view until the end of their
   creating transaction.

   <note>
    <para>
     Cursors are used internally to implement some of the components
     of <productname>PostgreSQL</>, such as procedural languages.
     Therefore, the <structname>pg_cursors</> view might include cursors
     that have not been explicitly created by the user.
    </para>
   </note>
  </para>

  <table>
   <title><structname>pg_cursors</> Columns</title>

   <tgroup cols=3>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>The name of the cursor</entry>
     </row>

     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>The verbatim query string submitted to declare this cursor</entry>
     </row>

     <row>
      <entry><structfield>is_holdable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> if the cursor is holdable (that is, it
       can be accessed after the transaction that declared the cursor
       has committed); <literal>false</literal> otherwise
       </entry>
     </row>

     <row>
      <entry><structfield>is_binary</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> if the cursor was declared
       <literal>BINARY</literal>; <literal>false</literal>
       otherwise
       </entry>
     </row>

     <row>
      <entry><structfield>is_scrollable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</> if the cursor is scrollable (that is, it
       allows rows to be retrieved in a nonsequential manner);
       <literal>false</literal> otherwise
       </entry>
     </row>

     <row>
      <entry><structfield>creation_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>The time at which the cursor was declared</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_cursors</structname> view is read only.
  </para>

 </sect1>

 <sect1 id="view-pg-group">
  <title><structname>pg_group</structname></title>

  <indexterm zone="view-pg-group">
   <primary>pg_group</primary>
  </indexterm>

  <para>
   The view <structname>pg_group</structname> exists for backwards
   compatibility: it emulates a catalog that existed in
   <productname>PostgreSQL</productname> before version 8.1.
   It shows the names and members of all roles that are marked as not
   <structfield>rolcanlogin</>, which is an approximation to the set
   of roles that are being used as groups.
  </para>

  <table>
   <title><structname>pg_group</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>groname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Name of the group</entry>
     </row>

     <row>
      <entry><structfield>grosysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID of this group</entry>
     </row>

     <row>
      <entry><structfield>grolist</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>An array containing the IDs of the roles in this group</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-indexes">
  <title><structname>pg_indexes</structname></title>

  <indexterm zone="view-pg-indexes">
   <primary>pg_indexes</primary>
  </indexterm>

  <para>
   The view <structname>pg_indexes</structname> provides access to
   useful information about each index in the database.
  </para>

  <table>
   <title><structname>pg_indexes</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing table and index</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of table the index is for</entry>
     </row>
     <row>
      <entry><structfield>indexname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of index</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>Name of tablespace containing index (NULL if default for database)</entry>
     </row>
     <row>
      <entry><structfield>indexdef</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Index definition (a reconstructed <command>CREATE INDEX</command>
      command)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-locks">
  <title><structname>pg_locks</structname></title>

  <indexterm zone="view-pg-locks">
   <primary>pg_locks</primary>
  </indexterm>

  <para>
   The view <structname>pg_locks</structname> provides access to
   information about the locks held by open transactions within the
   database server.  See <xref linkend="mvcc"> for more discussion
   of locking.
  </para>

  <para>
   <structname>pg_locks</structname> contains one row per active lockable
   object, requested lock mode, and relevant transaction.  Thus, the same
   lockable object might
   appear many times, if multiple transactions are holding or waiting
   for locks on it.  However, an object that currently has no locks on it
   will not appear at all.
  </para>

  <para>
   There are several distinct types of lockable objects:
   whole relations (e.g., tables), individual pages of relations,
   individual tuples of relations,
   transaction IDs (both virtual and permanent IDs),
   and general database objects (identified by class OID and object OID,
   in the same way as in <structname>pg_description</structname> or
   <structname>pg_depend</structname>).  Also, the right to extend a
   relation is represented as a separate lockable object.
  </para>

  <table>
   <title><structname>pg_locks</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>locktype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       type of the lockable object:
       <literal>relation</>,
       <literal>extend</>,
       <literal>page</>,
       <literal>tuple</>,
       <literal>transactionid</>,
       <literal>virtualxid</>,
       <literal>object</>,
       <literal>userlock</>, or
       <literal>advisory</>
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>
       OID of the database in which the object exists, or
       zero if the object is a shared object, or
       NULL if the object is a transaction ID
      </entry>
     </row>
     <row>
      <entry><structfield>relation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID of the relation, or NULL if the object is not
       a relation or part of a relation
      </entry>
     </row>
     <row>
      <entry><structfield>page</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       Page number within the relation, or NULL if the object
       is not a tuple or relation page
      </entry>
     </row>
     <row>
      <entry><structfield>tuple</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       Tuple number within the page, or NULL if the object is not a tuple
      </entry>
     </row>
     <row>
      <entry><structfield>virtualxid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Virtual ID of a transaction, or NULL if the object is not a
       virtual transaction ID
      </entry>
     </row>
     <row>
      <entry><structfield>transactionid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       ID of a transaction, or NULL if the object is not a transaction ID
      </entry>
     </row>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID of the system catalog containing the object, or NULL if the
       object is not a general database object
      </entry>
     </row>
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>
       OID of the object within its system catalog, or NULL if the
       object is not a general database object
      </entry>
     </row>
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       For a table column, this is the column number (the
       <structfield>classid</> and <structfield>objid</> refer to the
       table itself).  For all other object types, this column is
       zero.  NULL if the object is not a general database object
      </entry>
     </row>
     <row>
      <entry><structfield>virtualtransaction</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Virtual ID of the transaction that is holding or awaiting this lock
      </entry>
     </row>
     <row>
      <entry><structfield>pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       Process ID of the server process holding or awaiting this
       lock.  NULL if the lock is held by a prepared transaction
      </entry>
     </row>
     <row>
      <entry><structfield>mode</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Name of the lock mode held or desired by this process (see <xref
      linkend="locking-tables">)</entry>
     </row>
     <row>
      <entry><structfield>granted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>True if lock is held, false if lock is awaited</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structfield>granted</structfield> is true in a row representing a lock
   held by the indicated transaction.  False indicates that this transaction is
   currently waiting to acquire this lock, which implies that some other
   transaction is holding a conflicting lock mode on the same lockable object.
   The waiting transaction will sleep until the other lock is released (or a
   deadlock situation is detected). A single transaction can be waiting to
   acquire at most one lock at a time.
  </para>

  <para>
   Every transaction holds an exclusive lock on its virtual transaction ID for
   its entire duration.  If a permanent ID is assigned to the transaction
   (which normally happens only if the transaction changes the state of the
   database), it also holds an exclusive lock on its permanent transaction ID
   until it ends.  When one transaction finds it necessary to wait specifically
   for another transaction, it does so by attempting to acquire share lock on
   the other transaction ID (either virtual or permanent ID depending on the
   situation). That will succeed only when the other transaction
   terminates and releases its locks. 
  </para>

  <para>
   Although tuples are a lockable type of object,
   information about row-level locks is stored on disk, not in memory,
   and therefore row-level locks normally do not appear in this view.
   If a transaction is waiting for a
   row-level lock, it will usually appear in the view as waiting for the
   permanent transaction ID of the current holder of that row lock.
  </para>

  <para>
   Advisory locks can be acquired on keys consisting of either a single
   <type>bigint</type> value or two integer values.  A <type>bigint</type> key is displayed with its
   high-order half in the <structfield>classid</> column, its low-order half
   in the <structfield>objid</> column, and <structfield>objsubid</> equal
   to 1.  Integer keys are displayed with the first key in the
   <structfield>classid</> column, the second key in the <structfield>objid</>
   column, and <structfield>objsubid</> equal to 2.  The actual meaning of
   the keys is up to the user.  Advisory locks are local to each database,
   so the <structfield>database</> column is meaningful for an advisory lock.
  </para>

  <para>
   When the <structname>pg_locks</structname> view is accessed, the
   internal lock manager data structures are momentarily locked, and
   a copy is made for the view to display.  This ensures that the
   view produces a consistent set of results, while not blocking
   normal lock manager operations longer than necessary.  Nonetheless
   there could be some impact on database performance if this view is
   frequently accessed.
  </para>

  <para>
   <structname>pg_locks</structname> provides a global view of all locks
   in the database cluster, not only those relevant to the current database.
   Although its <structfield>relation</structfield> column can be joined
   against <structname>pg_class</>.<structfield>oid</> to identify locked
   relations, this will only work correctly for relations in the current
   database (those for which the <structfield>database</structfield> column
   is either the current database's OID or zero).
  </para>

  <para>
   The <structfield>pid</structfield> column can be joined to the
   <structfield>procpid</structfield> column of the
   <structname>pg_stat_activity</structname> view to get more
   information on the session holding or waiting to hold each lock.
   Also, if you are using prepared transactions, the
   <structfield>transaction</> column can be joined to the
   <structfield>transaction</structfield> column of the
   <structname>pg_prepared_xacts</structname> view to get more
   information on prepared transactions that hold locks.
   (A prepared transaction can never be waiting for a lock,
   but it continues to hold the locks it acquired while running.)
  </para>

 </sect1>

 <sect1 id="view-pg-prepared-statements">
  <title><structname>pg_prepared_statements</structname></title>

  <indexterm zone="view-pg-prepared-statements">
   <primary>pg_prepared_statements</primary>
  </indexterm>

  <para>
   The <structname>pg_prepared_statements</structname> view displays
   all the prepared statements that are available in the current
   session. See <xref linkend="sql-prepare"
   endterm="sql-prepare-title"> for more information about prepared
   statements.
  </para>

  <para>
   <structname>pg_prepared_statements</structname> contains one row
   for each prepared statement. Rows are added to the view when a new
   prepared statement is created and removed when a prepared statement
   is released (for example, via the <xref linkend="sql-deallocate"
   endterm="sql-deallocate-title"> command).
  </para>

  <table>
   <title><structname>pg_prepared_statements</> Columns</title>

   <tgroup cols=3>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       The identifier of the prepared statement
      </entry>
     </row>
     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       The query string submitted by the client to create this
       prepared statement. For prepared statements created via SQL,
       this is the <command>PREPARE</command> statement submitted by
       the client. For prepared statements created via the
       frontend/backend protocol, this is the text of the prepared
       statement itself
      </entry>
     </row>
     <row>
      <entry><structfield>prepare_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       The time at which the prepared statement was created
      </entry>
     </row>
     <row>
      <entry><structfield>parameter_types</structfield></entry>
      <entry><type>regtype[]</type></entry>
      <entry>
       The expected parameter types for the prepared statement in the
       form of an array of <type>regtype</type>. The OID corresponding
       to an element of this array can be obtained by casting the
       <type>regtype</type> value to <type>oid</type>
      </entry>
     </row>
     <row>
      <entry><structfield>from_sql</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <literal>true</literal> if the prepared statement was created
       via the <command>PREPARE</command> SQL statement;
       <literal>false</literal> if the statement was prepared via the
       frontend/backend protocol
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_prepared_statements</structname> view is read only.
  </para>
 </sect1>

 <sect1 id="view-pg-prepared-xacts">
  <title><structname>pg_prepared_xacts</structname></title>

  <indexterm zone="view-pg-prepared-xacts">
   <primary>pg_prepared_xacts</primary>
  </indexterm>

  <para>
   The view <structname>pg_prepared_xacts</structname> displays
   information about transactions that are currently prepared for two-phase
   commit (see <xref linkend="sql-prepare-transaction"
   endterm="sql-prepare-transaction-title"> for details).
  </para>

  <para>
   <structname>pg_prepared_xacts</structname> contains one row per prepared
   transaction.  An entry is removed when the transaction is committed or
   rolled back.
  </para>

  <table>
   <title><structname>pg_prepared_xacts</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       Numeric transaction identifier of the prepared transaction
      </entry>
     </row>
     <row>
      <entry><structfield>gid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Global transaction identifier that was assigned to the transaction
      </entry>
     </row>
     <row>
      <entry><structfield>prepared</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry></entry>
      <entry>
       Time at which the transaction was prepared for commit
      </entry>
     </row>
     <row>
      <entry><structfield>owner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>
       Name of the user that executed the transaction
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>
       Name of the database in which the transaction was executed
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   When the <structname>pg_prepared_xacts</structname> view is accessed, the
   internal transaction manager data structures are momentarily locked, and
   a copy is made for the view to display.  This ensures that the
   view produces a consistent set of results, while not blocking
   normal operations longer than necessary.  Nonetheless
   there could be some impact on database performance if this view is
   frequently accessed.
  </para>

 </sect1>

 <sect1 id="view-pg-roles">
  <title><structname>pg_roles</structname></title>

  <indexterm zone="view-pg-roles">
   <primary>pg_roles</primary>
  </indexterm>

  <para>
   The view <structname>pg_roles</structname> provides access to
   information about database roles.  This is simply a publicly
   readable view of 
   <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
   that blanks out the password field.
  </para>

  <para>
   This view explicitly exposes the OID column of the underlying table,
   since that is needed to do joins to other catalogs.
  </para>

  <table>
   <title><structname>pg_roles</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Role name</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Role has superuser privileges</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Role automatically inherits privileges of roles it is a
       member of</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Role can create more roles</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Role can create databases</entry>
     </row>

     <row>
      <entry><structfield>rolcatupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Role can update system catalogs directly.  (Even a superuser cannot do
       this unless this column is true.)
      </entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Role can log in. That is, this role can be given as the initial
       session authorization identifier
      </entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For roles that can log in, this sets maximum number of concurrent 
       connections this role can make.  -1 means no limit
      </entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Not the password (always reads as <literal>********</>)</entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry></entry>
      <entry>Password expiry time (only used for password authentication);
       NULL if no expiration</entry>
     </row>

     <row>
      <entry><structfield>rolconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Session defaults for run-time configuration variables</entry>
     </row>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID of role</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-rules">
  <title><structname>pg_rules</structname></title>

  <indexterm zone="view-pg-rules">
   <primary>pg_rules</primary>
  </indexterm>

  <para>
   The view <structname>pg_rules</structname> provides access to
   useful information about query rewrite rules.
  </para>

  <table>
   <title><structname>pg_rules</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing table</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of table the rule is for</entry>
     </row>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.rulename</literal></entry>
      <entry>Name of rule</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Rule definition (a reconstructed creation command)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_rules</> view excludes the <literal>ON SELECT</> rules
   of views; those can be seen in <structname>pg_views</>.
  </para>

 </sect1>

 <sect1 id="view-pg-settings">
  <title><structname>pg_settings</structname></title>

  <indexterm zone="view-pg-settings">
   <primary>pg_settings</primary>
  </indexterm>

  <para>
   The view <structname>pg_settings</structname> provides access to
   run-time parameters of the server.  It is essentially an alternative
   interface to the <command>SHOW</> and <command>SET</> commands.
   It also provides access to some facts about each parameter that are
   not directly available from <command>SHOW</>, such as minimum and
   maximum values.
  </para>

  <table>
   <title><structname>pg_settings</> Columns</title>

   <tgroup cols=3>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Run-time configuration parameter name</entry>
     </row>
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Current value of the parameter</entry>
     </row>
     <row>
      <entry><structfield>unit</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Implicit unit of the parameter</entry>
     </row>
     <row>
      <entry><structfield>category</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Logical group of the parameter</entry>
     </row>
     <row>
      <entry><structfield>short_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>A brief description of the parameter</entry>
     </row>
     <row>
      <entry><structfield>extra_desc</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Additional, more detailed, information about the parameter</entry>
     </row>
     <row>
      <entry><structfield>context</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Context required to set the parameter's value</entry>
     </row>
     <row>
      <entry><structfield>vartype</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Parameter type (<literal>bool</>, <literal>integer</>,
       <literal>real</>, or <literal>string</>)
      </entry>
     </row>
     <row>
      <entry><structfield>source</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Source of the current parameter value</entry>
     </row>
     <row>
      <entry><structfield>min_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Minimum allowed value of the parameter (NULL for non-numeric
      values)</entry>
     </row>
     <row>
      <entry><structfield>max_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Maximum allowed value of the parameter (NULL for non-numeric
      values)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  
  <para>
   The <structname>pg_settings</structname> view cannot be inserted into or
   deleted from, but it can be updated.  An <command>UPDATE</command> applied
   to a row of <structname>pg_settings</structname> is equivalent to executing
   the <xref linkend="sql-set" endterm="sql-set-title"> command on that named
   parameter. The change only affects the value used by the current
   session. If an <command>UPDATE</command> is issued within a transaction
   that is later aborted, the effects of the <command>UPDATE</command> command
   disappear when the transaction is rolled back. Once the surrounding
   transaction is committed, the effects will persist until the end of the
   session, unless overridden by another <command>UPDATE</command> or
   <command>SET</command>.
  </para>

 </sect1>

 <sect1 id="view-pg-shadow">
  <title><structname>pg_shadow</structname></title>

  <indexterm zone="view-pg-shadow">
   <primary>pg_shadow</primary>
  </indexterm>

  <para>
   The view <structname>pg_shadow</structname> exists for backwards
   compatibility: it emulates a catalog that existed in
   <productname>PostgreSQL</productname> before version 8.1.
   It shows properties of all roles that are marked as
   <structfield>rolcanlogin</>.
  </para>

  <para>
   The name stems from the fact that this table
   should not be readable by the public since it contains passwords.
   <link linkend="view-pg-user"><structname>pg_user</structname></link>
   is a publicly readable view on
   <structname>pg_shadow</structname> that blanks out the password field.
  </para>

  <table>
   <title><structname>pg_shadow</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>User name</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>ID of this user</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>User can create databases</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>User is a superuser</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       User can update system catalogs.  (Even a superuser cannot do
       this unless this column is true.)
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Password (possibly encrypted)</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <entry>Password expiry time (only used for password authentication)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Session defaults for run-time configuration variables</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-stats">
  <title><structname>pg_stats</structname></title>

  <indexterm zone="view-pg-stats">
   <primary>pg_stats</primary>
  </indexterm>

  <para>
   The view <structname>pg_stats</structname> provides access to
   the information stored in the <link
   linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>
   catalog.  This view allows access only to rows of
   <structname>pg_statistic</structname> that correspond to tables the
   user has permission to read, and therefore it is safe to allow public
   read access to this view.
  </para>

  <para>
   <structname>pg_stats</structname> is also designed to present the
   information in a more readable format than the underlying catalog
   &mdash; at the cost that its schema must be extended whenever new slot types
   are defined for <structname>pg_statistic</structname>.
  </para>

  <table>
   <title><structname>pg_stats</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing table</entry>
     </row>

     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of table</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attname</literal></entry>
      <entry>Name of the column described by this row</entry>
     </row>

     <row>
      <entry><structfield>null_frac</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Fraction of column entries that are null</entry>
     </row>

     <row>
      <entry><structfield>avg_width</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>Average width in bytes of column's entries</entry>
     </row>

     <row>
      <entry><structfield>n_distinct</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>
       If greater than zero, the estimated number of distinct values in the
       column.  If less than zero, the negative of the number of distinct
       values divided by the number of rows.  (The negated form is used when
       <command>ANALYZE</> believes that the number of distinct values is
       likely to increase as the table grows; the positive form is used when
       the column seems to have a fixed number of possible values.)  For
       example, -1 indicates a unique column in which the number of distinct
       values is the same as the number of rows
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_vals</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       A list of the most common values in the column. (NULL if
       no values seem to be more common than any others.)
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       A list of the frequencies of the most common values,
       i.e., number of occurrences of each divided by total number of rows.
       (NULL when <structfield>most_common_vals</structfield> is.)
     </entry>
     </row>

     <row>
      <entry><structfield>histogram_bounds</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       A list of values that divide the column's values into groups of
       approximately equal population.  The values in
       <structfield>most_common_vals</>, if present, are omitted from this
       histogram calculation.  (This column is NULL if the column data type
       does not have a <literal>&lt;</> operator or if the
       <structfield>most_common_vals</> list accounts for the entire
       population.)
      </entry>
     </row>

     <row>
      <entry><structfield>correlation</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>
       Statistical correlation between physical row ordering and
       logical ordering of the column values.  This ranges from -1 to +1.
       When the value is near -1 or +1, an index scan on the column will
       be estimated to be cheaper than when it is near zero, due to reduction
       of random access to the disk.  (This column is NULL if the column data
       type does not have a <literal>&lt;</> operator.)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The maximum number of entries in the <structfield>most_common_vals</>
   and <structfield>histogram_bounds</> arrays can be set on a
   column-by-column basis using the <command>ALTER TABLE SET STATISTICS</>
   command, or globally by setting the
   <xref linkend="guc-default-statistics-target"> run-time parameter.
  </para>

 </sect1>

 <sect1 id="view-pg-tables">
  <title><structname>pg_tables</structname></title>

  <indexterm zone="view-pg-tables">
   <primary>pg_tables</primary>
  </indexterm>

  <para>
   The view <structname>pg_tables</structname> provides access to
   useful information about each table in the database.
  </para>

  <table>
   <title><structname>pg_tables</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing table</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of table</entry>
     </row>
     <row>
      <entry><structfield>tableowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Name of table's owner</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <entry>Name of tablespace containing table (NULL if default for database)</entry>
     </row>
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasindex</literal></entry>
      <entry>true if table has (or recently had) any indexes</entry>
     </row>
     <row>
      <entry><structfield>hasrules</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasrules</literal></entry>
      <entry>true if table has rules</entry>
     </row>
     <row>
      <entry><structfield>hastriggers</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.reltriggers</literal></entry>
      <entry>true if table has triggers</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-timezone-abbrevs">
  <title><structname>pg_timezone_abbrevs</structname></title>

  <indexterm zone="view-pg-timezone-abbrevs">
   <primary>pg_timezone_abbrevs</primary>
  </indexterm>

  <para>
   The view <structname>pg_timezone_abbrevs</structname> provides a list
   of time zone abbreviations that are currently recognized by the datetime
   input routines.  The contents of this view change when the
   <xref linkend="guc-timezone-abbreviations"> run-time parameter is modified.
  </para>

  <table>
   <title><structname>pg_timezone_abbrevs</> Columns</title>

   <tgroup cols=3>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Time zone abbreviation</entry>
     </row>
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>Offset from UTC (positive means east of Greenwich)</entry>
     </row>
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True if this is a daylight-savings abbreviation</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-timezone-names">
  <title><structname>pg_timezone_names</structname></title>

  <indexterm zone="view-pg-timezone-names">
   <primary>pg_timezone_names</primary>
  </indexterm>

  <para>
   The view <structname>pg_timezone_names</structname> provides a list
   of time zone names that are recognized by <command>SET TIMEZONE</>,
   along with their associated abbreviations, UTC offsets,
   and daylight-savings status.
   Unlike the abbreviations shown in <link
   linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link>, many of these names imply a set of daylight-savings transition
   date rules.  Therefore, the associated information changes across local DST
   boundaries.  The displayed information is computed based on the current
   value of <function>CURRENT_TIMESTAMP</>.
  </para>

  <table>
   <title><structname>pg_timezone_names</> Columns</title>

   <tgroup cols=3>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Time zone name</entry>
     </row>
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Time zone abbreviation</entry>
     </row>
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <entry>Offset from UTC (positive means east of Greenwich)</entry>
     </row>
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>True if currently observing daylight savings</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user">
  <title><structname>pg_user</structname></title>

  <indexterm zone="view-pg-user">
   <primary>pg_user</primary>
  </indexterm>

  <para>
   The view <structname>pg_user</structname> provides access to
   information about database users.  This is simply a publicly
   readable view of 
   <link linkend="view-pg-shadow"><structname>pg_shadow</structname></link>
   that blanks out the password field.
  </para>

  <table>
   <title><structname>pg_user</> Columns</title>

   <tgroup cols=3>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry>User name</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>User ID (arbitrary number used to reference this user)</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>User can create databases</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>User is a superuser</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       User can update system catalogs.  (Even a superuser cannot do
       this unless this column is true.)
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry>Not the password (always reads as <literal>********</>)</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry>Password expiry time (only used for password authentication)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry>Session defaults for run-time configuration variables</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-views">
  <title><structname>pg_views</structname></title>

  <indexterm zone="view-pg-views">
   <primary>pg_views</primary>
  </indexterm>

  <para>
   The view <structname>pg_views</structname> provides access to
   useful information about each view in the database.
  </para>

  <table>
   <title><structname>pg_views</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>Name of schema containing view</entry>
     </row>
     <row>
      <entry><structfield>viewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>Name of view</entry>
     </row>
     <row>
      <entry><structfield>viewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>Name of view's owner</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>View definition (a reconstructed <command>SELECT</command> query)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

</chapter>
