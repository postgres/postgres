--
-- Tests for psql features that aren't closely connected to any
-- specific server features
--
-- \set
-- fail: invalid name
\set invalid/name foo
invalid variable name: "invalid/name"
-- fail: invalid value for special variable
\set AUTOCOMMIT foo
unrecognized value "foo" for "AUTOCOMMIT": Boolean expected
\set FETCH_COUNT foo
invalid value "foo" for "FETCH_COUNT": integer expected
-- check handling of built-in boolean variable
\echo :ON_ERROR_ROLLBACK
off
\set ON_ERROR_ROLLBACK
\echo :ON_ERROR_ROLLBACK
on
\set ON_ERROR_ROLLBACK foo
unrecognized value "foo" for "ON_ERROR_ROLLBACK"
Available values are: on, off, interactive.
\echo :ON_ERROR_ROLLBACK
on
\set ON_ERROR_ROLLBACK on
\echo :ON_ERROR_ROLLBACK
on
\unset ON_ERROR_ROLLBACK
\echo :ON_ERROR_ROLLBACK
off
-- \g and \gx
SELECT 1 as one, 2 as two \g
 one | two 
-----+-----
   1 |   2
(1 row)

\gx
-[ RECORD 1 ]
one | 1
two | 2

SELECT 3 as three, 4 as four \gx
-[ RECORD 1 ]
three | 3
four  | 4

\g
 three | four 
-------+------
     3 |    4
(1 row)

-- \gx should work in FETCH_COUNT mode too
\set FETCH_COUNT 1
SELECT 1 as one, 2 as two \g
 one | two 
-----+-----
   1 |   2
(1 row)

\gx
-[ RECORD 1 ]
one | 1
two | 2

SELECT 3 as three, 4 as four \gx
-[ RECORD 1 ]
three | 3
four  | 4

\g
 three | four 
-------+------
     3 |    4
(1 row)

\unset FETCH_COUNT
-- \g/\gx with pset options
SELECT 1 as one, 2 as two \g (format=csv csv_fieldsep='\t')
one	two
1	2
\g
 one | two 
-----+-----
   1 |   2
(1 row)

SELECT 1 as one, 2 as two \gx (title='foo bar')
foo bar
-[ RECORD 1 ]
one | 1
two | 2

\g
 one | two 
-----+-----
   1 |   2
(1 row)

-- \parse (extended query protocol)
\parse
\parse: missing required argument
SELECT 1 \parse ''
SELECT 2 \parse stmt1
SELECT $1 \parse stmt2
SELECT $1, $2 \parse stmt3
-- \bind_named (extended query protocol)
\bind_named
\bind_named: missing required argument
\bind_named '' \g
 ?column? 
----------
        1
(1 row)

\bind_named stmt1 \g
 ?column? 
----------
        2
(1 row)

\bind_named stmt2 'foo' \g
 ?column? 
----------
 foo
(1 row)

\bind_named stmt3 'foo' 'bar' \g
 ?column? | ?column? 
----------+----------
 foo      | bar
(1 row)

-- Repeated calls.  The second call generates an error, cleaning up the
-- statement name set by the first call.
\bind_named stmt4
\bind_named
\bind_named: missing required argument
\g
ERROR:  there is no parameter $1
LINE 1: SELECT $1, $2 
               ^
-- Last \bind_named wins
\bind_named stmt2 'foo' \bind_named stmt3 'foo2' 'bar2' \g
 ?column? | ?column? 
----------+----------
 foo2     | bar2
(1 row)

-- Multiple \g calls mean multiple executions
\bind_named stmt2 'foo3' \g \bind_named stmt3 'foo4' 'bar4' \g
 ?column? 
----------
 foo3
(1 row)

 ?column? | ?column? 
----------+----------
 foo4     | bar4
(1 row)

-- \close (extended query protocol)
\close
\close: missing required argument
\close ''
\close stmt2
\close stmt2
SELECT name, statement FROM pg_prepared_statements ORDER BY name;
 name  |   statement    
-------+----------------
 stmt1 | SELECT 2 
 stmt3 | SELECT $1, $2 
(2 rows)

-- \bind (extended query protocol)
SELECT 1 \bind \g
 ?column? 
----------
        1
(1 row)

SELECT $1 \bind 'foo' \g
 ?column? 
----------
 foo
(1 row)

SELECT $1, $2 \bind 'foo' 'bar' \g
 ?column? | ?column? 
----------+----------
 foo      | bar
(1 row)

-- last \bind wins
select $1::int as col \bind 'foo' \bind 2 \g
 col 
-----
   2
(1 row)

-- Multiple \g calls mean multiple executions
select $1::int as col \bind 1 \g \bind 2 \g
 col 
-----
   1
(1 row)

 col 
-----
   2
(1 row)

-- errors
-- parse error
SELECT foo \bind \g
ERROR:  column "foo" does not exist
LINE 1: SELECT foo 
               ^
-- tcop error
SELECT 1 \; SELECT 2 \bind \g
ERROR:  cannot insert multiple commands into a prepared statement
-- bind error
SELECT $1, $2 \bind 'foo' \g
ERROR:  bind message supplies 1 parameters, but prepared statement "" requires 2
-- bind_named error
\bind_named stmt2 'baz' \g
ERROR:  prepared statement "stmt2" does not exist
\bind_named stmt3 'baz' \g
ERROR:  bind message supplies 1 parameters, but prepared statement "stmt3" requires 2
-- \gset
select 10 as test01, 20 as test02, 'Hello' as test03 \gset pref01_
\echo :pref01_test01 :pref01_test02 :pref01_test03
10 20 Hello
-- should fail: bad variable name
select 10 as "bad name"
\gset
invalid variable name: "bad name"
select 97 as "EOF", 'ok' as _foo \gset IGNORE
attempt to \gset into specially treated variable "IGNOREEOF" ignored
\echo :IGNORE_foo :IGNOREEOF
ok 0
-- multiple backslash commands in one line
select 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_x
1
select 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_y
3
4
select 5 as x, 6 as y \gset pref01_ \\ \g \echo :pref01_x :pref01_y
 x | y 
---+---
 5 | 6
(1 row)

5 6
select 7 as x, 8 as y \g \gset pref01_ \echo :pref01_x :pref01_y
 x | y 
---+---
 7 | 8
(1 row)

7 8
-- NULL should unset the variable
\set var2 xyz
select 1 as var1, NULL as var2, 3 as var3 \gset
\echo :var1 :var2 :var3
1 :var2 3
-- \gset requires just one tuple
select 10 as test01, 20 as test02 from generate_series(1,3) \gset
more than one row returned for \gset
select 10 as test01, 20 as test02 from generate_series(1,0) \gset
no rows returned for \gset
-- \gset returns no tuples
select a from generate_series(1, 10) as a where a = 11 \gset
no rows returned for \gset
\echo :ROW_COUNT
0
-- \gset should work in FETCH_COUNT mode too
\set FETCH_COUNT 1
select 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_x
1
select 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_y
3
4
select 10 as test01, 20 as test02 from generate_series(1,3) \gset
more than one row returned for \gset
select 10 as test01, 20 as test02 from generate_series(1,0) \gset
no rows returned for \gset
\unset FETCH_COUNT
-- \gdesc
SELECT
    NULL AS zero,
    1 AS one,
    2.0 AS two,
    'three' AS three,
    $1 AS four,
    sin($2) as five,
    'foo'::varchar(4) as six,
    CURRENT_DATE AS now
\gdesc
 Column |         Type         
--------+----------------------
 zero   | text
 one    | integer
 two    | numeric
 three  | text
 four   | text
 five   | double precision
 six    | character varying(4)
 now    | date
(8 rows)

-- should work with tuple-returning utilities, such as EXECUTE
PREPARE test AS SELECT 1 AS first, 2 AS second;
EXECUTE test \gdesc
 Column |  Type   
--------+---------
 first  | integer
 second | integer
(2 rows)

EXPLAIN EXECUTE test \gdesc
   Column   | Type 
------------+------
 QUERY PLAN | text
(1 row)

-- should fail cleanly - syntax error
SELECT 1 + \gdesc
ERROR:  syntax error at end of input
LINE 1: SELECT 1 + 
                   ^
-- check behavior with empty results
SELECT \gdesc
The command has no result, or the result has no columns.
CREATE TABLE bububu(a int) \gdesc
The command has no result, or the result has no columns.
-- subject command should not have executed
TABLE bububu;  -- fail
ERROR:  relation "bububu" does not exist
LINE 1: TABLE bububu;
              ^
-- query buffer should remain unchanged
SELECT 1 AS x, 'Hello', 2 AS y, true AS "dirty\name"
\gdesc
   Column   |  Type   
------------+---------
 x          | integer
 ?column?   | text
 y          | integer
 dirty\name | boolean
(4 rows)

\g
 x | ?column? | y | dirty\name 
---+----------+---+------------
 1 | Hello    | 2 | t
(1 row)

-- all on one line
SELECT 3 AS x, 'Hello', 4 AS y, true AS "dirty\name" \gdesc \g
   Column   |  Type   
------------+---------
 x          | integer
 ?column?   | text
 y          | integer
 dirty\name | boolean
(4 rows)

 x | ?column? | y | dirty\name 
---+----------+---+------------
 3 | Hello    | 4 | t
(1 row)

-- test for server bug #17983 with empty statement in aborted transaction
set search_path = default;
begin;
bogus;
ERROR:  syntax error at or near "bogus"
LINE 1: bogus;
        ^
;
\gdesc
The command has no result, or the result has no columns.
rollback;
-- \gexec
create temporary table gexec_test(a int, b text, c date, d float);
select format('create index on gexec_test(%I)', attname)
from pg_attribute
where attrelid = 'gexec_test'::regclass and attnum > 0
order by attnum
\gexec
create index on gexec_test(a)
create index on gexec_test(b)
create index on gexec_test(c)
create index on gexec_test(d)
-- \gexec should work in FETCH_COUNT mode too
-- (though the fetch limit applies to the executed queries not the meta query)
\set FETCH_COUNT 1
select 'select 1 as ones', 'select x.y, x.y*2 as double from generate_series(1,4) as x(y)'
union all
select 'drop table gexec_test', NULL
union all
select 'drop table gexec_test', 'select ''2000-01-01''::date as party_over'
\gexec
select 1 as ones
 ones 
------
    1
(1 row)

select x.y, x.y*2 as double from generate_series(1,4) as x(y)
 y | double 
---+--------
 1 |      2
 2 |      4
 3 |      6
 4 |      8
(4 rows)

drop table gexec_test
drop table gexec_test
ERROR:  table "gexec_test" does not exist
select '2000-01-01'::date as party_over
 party_over 
------------
 01-01-2000
(1 row)

\unset FETCH_COUNT
-- \setenv, \getenv
-- ensure MYVAR isn't set
\setenv MYVAR
-- in which case, reading it doesn't change the target
\getenv res MYVAR
\echo :res
:res
-- now set it
\setenv MYVAR 'environment value'
\getenv res MYVAR
\echo :res
environment value
-- show all pset options
\pset
border                   1
columns                  0
csv_fieldsep             ','
expanded                 off
fieldsep                 '|'
fieldsep_zero            off
footer                   on
format                   aligned
linestyle                ascii
null                     ''
numericlocale            off
pager                    1
pager_min_lines          0
recordsep                '\n'
recordsep_zero           off
tableattr                
title                    
tuples_only              off
unicode_border_linestyle single
unicode_column_linestyle single
unicode_header_linestyle single
xheader_width            full
-- test multi-line headers, wrapping, and newline indicators
-- in aligned, unaligned, and wrapped formats
prepare q as select array_to_string(array_agg(repeat('x',2*n)),E'\n') as "ab

c", array_to_string(array_agg(repeat('y',20-2*n)),E'\n') as "a
bc" from generate_series(1,10) as n(n) group by n>1 order by n>1;
\pset linestyle ascii
\pset expanded off
\pset columns 40
\pset border 0
\pset format unaligned
execute q;
ab

c|a
bc
xx|yyyyyyyyyyyyyyyyyy
xxxx
xxxxxx
xxxxxxxx
xxxxxxxxxx
xxxxxxxxxxxx
xxxxxxxxxxxxxx
xxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
yyyyyyyyyyyyyy
yyyyyyyyyyyy
yyyyyyyyyy
yyyyyyyy
yyyyyy
yyyy
yy

(2 rows)
\pset format aligned
execute q;
         ab         +        a         +
                    +        bc         
         c                              
-------------------- ------------------
xx                   yyyyyyyyyyyyyyyyyy
xxxx                +yyyyyyyyyyyyyyyy  +
xxxxxx              +yyyyyyyyyyyyyy    +
xxxxxxxx            +yyyyyyyyyyyy      +
xxxxxxxxxx          +yyyyyyyyyy        +
xxxxxxxxxxxx        +yyyyyyyy          +
xxxxxxxxxxxxxx      +yyyyyy            +
xxxxxxxxxxxxxxxx    +yyyy              +
xxxxxxxxxxxxxxxxxx  +yy                +
xxxxxxxxxxxxxxxxxxxx 
(2 rows)

\pset format wrapped
execute q;
         ab         +        a         +
                    +        bc         
         c                              
-------------------- ------------------
xx                   yyyyyyyyyyyyyyyyyy
xxxx                +yyyyyyyyyyyyyyyy  +
xxxxxx              +yyyyyyyyyyyyyy    +
xxxxxxxx            +yyyyyyyyyyyy      +
xxxxxxxxxx          +yyyyyyyyyy        +
xxxxxxxxxxxx        +yyyyyyyy          +
xxxxxxxxxxxxxx      +yyyyyy            +
xxxxxxxxxxxxxxxx    +yyyy              +
xxxxxxxxxxxxxxxxxx  +yy                +
xxxxxxxxxxxxxxxxxxxx 
(2 rows)

\pset border 1
\pset format unaligned
execute q;
ab

c|a
bc
xx|yyyyyyyyyyyyyyyyyy
xxxx
xxxxxx
xxxxxxxx
xxxxxxxxxx
xxxxxxxxxxxx
xxxxxxxxxxxxxx
xxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
yyyyyyyyyyyyyy
yyyyyyyyyyyy
yyyyyyyyyy
yyyyyyyy
yyyyyy
yyyy
yy

(2 rows)
\pset format aligned
execute q;
          ab         +|         a         +
                     +|         bc         
          c           |                    
----------------------+--------------------
 xx                   | yyyyyyyyyyyyyyyyyy
 xxxx                +| yyyyyyyyyyyyyyyy  +
 xxxxxx              +| yyyyyyyyyyyyyy    +
 xxxxxxxx            +| yyyyyyyyyyyy      +
 xxxxxxxxxx          +| yyyyyyyyyy        +
 xxxxxxxxxxxx        +| yyyyyyyy          +
 xxxxxxxxxxxxxx      +| yyyyyy            +
 xxxxxxxxxxxxxxxx    +| yyyy              +
 xxxxxxxxxxxxxxxxxx  +| yy                +
 xxxxxxxxxxxxxxxxxxxx | 
(2 rows)

\pset format wrapped
execute q;
        ab        +|         a         +
                  +|         bc         
         c         |                    
-------------------+--------------------
 xx                | yyyyyyyyyyyyyyyyyy
 xxxx             +| yyyyyyyyyyyyyyyy  +
 xxxxxx           +| yyyyyyyyyyyyyy    +
 xxxxxxxx         +| yyyyyyyyyyyy      +
 xxxxxxxxxx       +| yyyyyyyyyy        +
 xxxxxxxxxxxx     +| yyyyyyyy          +
 xxxxxxxxxxxxxx   +| yyyyyy            +
 xxxxxxxxxxxxxxxx +| yyyy              +
 xxxxxxxxxxxxxxxxx.| yy                +
.x                +| 
 xxxxxxxxxxxxxxxxx.| 
.xxx               | 
(2 rows)

\pset border 2
\pset format unaligned
execute q;
ab

c|a
bc
xx|yyyyyyyyyyyyyyyyyy
xxxx
xxxxxx
xxxxxxxx
xxxxxxxxxx
xxxxxxxxxxxx
xxxxxxxxxxxxxx
xxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
yyyyyyyyyyyyyy
yyyyyyyyyyyy
yyyyyyyyyy
yyyyyyyy
yyyyyy
yyyy
yy

(2 rows)
\pset format aligned
execute q;
+----------------------+--------------------+
|          ab         +|         a         +|
|                     +|         bc         |
|          c           |                    |
+----------------------+--------------------+
| xx                   | yyyyyyyyyyyyyyyyyy |
| xxxx                +| yyyyyyyyyyyyyyyy  +|
| xxxxxx              +| yyyyyyyyyyyyyy    +|
| xxxxxxxx            +| yyyyyyyyyyyy      +|
| xxxxxxxxxx          +| yyyyyyyyyy        +|
| xxxxxxxxxxxx        +| yyyyyyyy          +|
| xxxxxxxxxxxxxx      +| yyyyyy            +|
| xxxxxxxxxxxxxxxx    +| yyyy              +|
| xxxxxxxxxxxxxxxxxx  +| yy                +|
| xxxxxxxxxxxxxxxxxxxx |                    |
+----------------------+--------------------+
(2 rows)

\pset format wrapped
execute q;
+-----------------+--------------------+
|       ab       +|         a         +|
|                +|         bc         |
|        c        |                    |
+-----------------+--------------------+
| xx              | yyyyyyyyyyyyyyyyyy |
| xxxx           +| yyyyyyyyyyyyyyyy  +|
| xxxxxx         +| yyyyyyyyyyyyyy    +|
| xxxxxxxx       +| yyyyyyyyyyyy      +|
| xxxxxxxxxx     +| yyyyyyyyyy        +|
| xxxxxxxxxxxx   +| yyyyyyyy          +|
| xxxxxxxxxxxxxx +| yyyyyy            +|
| xxxxxxxxxxxxxxx.| yyyy              +|
|.x              +| yy                +|
| xxxxxxxxxxxxxxx.|                    |
|.xxx            +|                    |
| xxxxxxxxxxxxxxx.|                    |
|.xxxxx           |                    |
+-----------------+--------------------+
(2 rows)

\pset expanded on
\pset columns 20
\pset border 0
\pset format unaligned
execute q;
ab

c|xx
a
bc|yyyyyyyyyyyyyyyyyy

ab

c|xxxx
xxxxxx
xxxxxxxx
xxxxxxxxxx
xxxxxxxxxxxx
xxxxxxxxxxxxxx
xxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxx
a
bc|yyyyyyyyyyyyyyyy
yyyyyyyyyyyyyy
yyyyyyyyyyyy
yyyyyyyyyy
yyyyyyyy
yyyyyy
yyyy
yy

\pset format aligned
execute q;
* Record 1            
ab+ xx
  +
c  
a + yyyyyyyyyyyyyyyyyy
bc 
* Record 2            
ab+ xxxx                +
  + xxxxxx              +
c   xxxxxxxx            +
    xxxxxxxxxx          +
    xxxxxxxxxxxx        +
    xxxxxxxxxxxxxx      +
    xxxxxxxxxxxxxxxx    +
    xxxxxxxxxxxxxxxxxx  +
    xxxxxxxxxxxxxxxxxxxx
a + yyyyyyyyyyyyyyyy    +
bc  yyyyyyyyyyyyyy      +
    yyyyyyyyyyyy        +
    yyyyyyyyyy          +
    yyyyyyyy            +
    yyyyyy              +
    yyyy                +
    yy                  +
    

\pset format wrapped
execute q;
* Record 1       
ab+ xx
  +
c  
a + yyyyyyyyyyyyyyy.
bc .yyy
* Record 2       
ab+ xxxx           +
  + xxxxxx         +
c   xxxxxxxx       +
    xxxxxxxxxx     +
    xxxxxxxxxxxx   +
    xxxxxxxxxxxxxx +
    xxxxxxxxxxxxxxx.
   .x              +
    xxxxxxxxxxxxxxx.
   .xxx            +
    xxxxxxxxxxxxxxx.
   .xxxxx
a + yyyyyyyyyyyyyyy.
bc .y              +
    yyyyyyyyyyyyyy +
    yyyyyyyyyyyy   +
    yyyyyyyyyy     +
    yyyyyyyy       +
    yyyyyy         +
    yyyy           +
    yy             +
    

\pset border 1
\pset format unaligned
execute q;
ab

c|xx
a
bc|yyyyyyyyyyyyyyyyyy

ab

c|xxxx
xxxxxx
xxxxxxxx
xxxxxxxxxx
xxxxxxxxxxxx
xxxxxxxxxxxxxx
xxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxx
a
bc|yyyyyyyyyyyyyyyy
yyyyyyyyyyyyyy
yyyyyyyyyyyy
yyyyyyyyyy
yyyyyyyy
yyyyyy
yyyy
yy

\pset format aligned
execute q;
-[ RECORD 1 ]------------
ab+| xx
  +|
c  |
a +| yyyyyyyyyyyyyyyyyy
bc |
-[ RECORD 2 ]------------
ab+| xxxx                +
  +| xxxxxx              +
c  | xxxxxxxx            +
   | xxxxxxxxxx          +
   | xxxxxxxxxxxx        +
   | xxxxxxxxxxxxxx      +
   | xxxxxxxxxxxxxxxx    +
   | xxxxxxxxxxxxxxxxxx  +
   | xxxxxxxxxxxxxxxxxxxx
a +| yyyyyyyyyyyyyyyy    +
bc | yyyyyyyyyyyyyy      +
   | yyyyyyyyyyyy        +
   | yyyyyyyyyy          +
   | yyyyyyyy            +
   | yyyyyy              +
   | yyyy                +
   | yy                  +
   | 

\pset format wrapped
execute q;
-[ RECORD 1 ]------
ab+| xx
  +|
c  |
a +| yyyyyyyyyyyyyy.
bc |.yyyy
-[ RECORD 2 ]------
ab+| xxxx          +
  +| xxxxxx        +
c  | xxxxxxxx      +
   | xxxxxxxxxx    +
   | xxxxxxxxxxxx  +
   | xxxxxxxxxxxxxx+
   | xxxxxxxxxxxxxx.
   |.xx            +
   | xxxxxxxxxxxxxx.
   |.xxxx          +
   | xxxxxxxxxxxxxx.
   |.xxxxxx
a +| yyyyyyyyyyyyyy.
bc |.yy            +
   | yyyyyyyyyyyyyy+
   | yyyyyyyyyyyy  +
   | yyyyyyyyyy    +
   | yyyyyyyy      +
   | yyyyyy        +
   | yyyy          +
   | yy            +
   | 

\pset border 2
\pset format unaligned
execute q;
ab

c|xx
a
bc|yyyyyyyyyyyyyyyyyy

ab

c|xxxx
xxxxxx
xxxxxxxx
xxxxxxxxxx
xxxxxxxxxxxx
xxxxxxxxxxxxxx
xxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxx
a
bc|yyyyyyyyyyyyyyyy
yyyyyyyyyyyyyy
yyyyyyyyyyyy
yyyyyyyyyy
yyyyyyyy
yyyyyy
yyyy
yy

\pset format aligned
execute q;
+-[ RECORD 1 ]--------------+
| ab+| xx                   |
|   +|                      |
| c  |                      |
| a +| yyyyyyyyyyyyyyyyyy   |
| bc |                      |
+-[ RECORD 2 ]--------------+
| ab+| xxxx                +|
|   +| xxxxxx              +|
| c  | xxxxxxxx            +|
|    | xxxxxxxxxx          +|
|    | xxxxxxxxxxxx        +|
|    | xxxxxxxxxxxxxx      +|
|    | xxxxxxxxxxxxxxxx    +|
|    | xxxxxxxxxxxxxxxxxx  +|
|    | xxxxxxxxxxxxxxxxxxxx |
| a +| yyyyyyyyyyyyyyyy    +|
| bc | yyyyyyyyyyyyyy      +|
|    | yyyyyyyyyyyy        +|
|    | yyyyyyyyyy          +|
|    | yyyyyyyy            +|
|    | yyyyyy              +|
|    | yyyy                +|
|    | yy                  +|
|    |                      |
+----+----------------------+

\pset format wrapped
execute q;
+-[ RECORD 1 ]-----+
| ab+| xx          |
|   +|             |
| c  |             |
| a +| yyyyyyyyyyy.|
| bc |.yyyyyyy     |
+-[ RECORD 2 ]-----+
| ab+| xxxx       +|
|   +| xxxxxx     +|
| c  | xxxxxxxx   +|
|    | xxxxxxxxxx +|
|    | xxxxxxxxxxx.|
|    |.x          +|
|    | xxxxxxxxxxx.|
|    |.xxx        +|
|    | xxxxxxxxxxx.|
|    |.xxxxx      +|
|    | xxxxxxxxxxx.|
|    |.xxxxxxx    +|
|    | xxxxxxxxxxx.|
|    |.xxxxxxxxx   |
| a +| yyyyyyyyyyy.|
| bc |.yyyyy      +|
|    | yyyyyyyyyyy.|
|    |.yyy        +|
|    | yyyyyyyyyyy.|
|    |.y          +|
|    | yyyyyyyyyy +|
|    | yyyyyyyy   +|
|    | yyyyyy     +|
|    | yyyy       +|
|    | yy         +|
|    |             |
+----+-------------+

\pset linestyle old-ascii
\pset expanded off
\pset columns 40
\pset border 0
\pset format unaligned
execute q;
ab

c|a
bc
xx|yyyyyyyyyyyyyyyyyy
xxxx
xxxxxx
xxxxxxxx
xxxxxxxxxx
xxxxxxxxxxxx
xxxxxxxxxxxxxx
xxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
yyyyyyyyyyyyyy
yyyyyyyyyyyy
yyyyyyyyyy
yyyyyyyy
yyyyyy
yyyy
yy

(2 rows)
\pset format aligned
execute q;
         ab                  a         
                    +        bc        
         c          +                  
-------------------- ------------------
xx                   yyyyyyyyyyyyyyyyyy
xxxx                 yyyyyyyyyyyyyyyy   
xxxxxx               yyyyyyyyyyyyyy     
xxxxxxxx             yyyyyyyyyyyy       
xxxxxxxxxx           yyyyyyyyyy         
xxxxxxxxxxxx         yyyyyyyy           
xxxxxxxxxxxxxx       yyyyyy             
xxxxxxxxxxxxxxxx     yyyy               
xxxxxxxxxxxxxxxxxx   yy                 
xxxxxxxxxxxxxxxxxxxx 
(2 rows)

\pset format wrapped
execute q;
         ab                  a         
                    +        bc        
         c          +                  
-------------------- ------------------
xx                   yyyyyyyyyyyyyyyyyy
xxxx                 yyyyyyyyyyyyyyyy   
xxxxxx               yyyyyyyyyyyyyy     
xxxxxxxx             yyyyyyyyyyyy       
xxxxxxxxxx           yyyyyyyyyy         
xxxxxxxxxxxx         yyyyyyyy           
xxxxxxxxxxxxxx       yyyyyy             
xxxxxxxxxxxxxxxx     yyyy               
xxxxxxxxxxxxxxxxxx   yy                 
xxxxxxxxxxxxxxxxxxxx 
(2 rows)

\pset border 1
\pset format unaligned
execute q;
ab

c|a
bc
xx|yyyyyyyyyyyyyyyyyy
xxxx
xxxxxx
xxxxxxxx
xxxxxxxxxx
xxxxxxxxxxxx
xxxxxxxxxxxxxx
xxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
yyyyyyyyyyyyyy
yyyyyyyyyyyy
yyyyyyyyyy
yyyyyyyy
yyyyyy
yyyy
yy

(2 rows)
\pset format aligned
execute q;
          ab          |         a          
+                     |+        bc         
+         c           |+                   
----------------------+--------------------
 xx                   | yyyyyyyyyyyyyyyyyy
 xxxx                 | yyyyyyyyyyyyyyyy   
 xxxxxx               : yyyyyyyyyyyyyy     
 xxxxxxxx             : yyyyyyyyyyyy       
 xxxxxxxxxx           : yyyyyyyyyy         
 xxxxxxxxxxxx         : yyyyyyyy           
 xxxxxxxxxxxxxx       : yyyyyy             
 xxxxxxxxxxxxxxxx     : yyyy               
 xxxxxxxxxxxxxxxxxx   : yy                 
 xxxxxxxxxxxxxxxxxxxx : 
(2 rows)

\pset format wrapped
execute q;
        ab         |         a          
+                  |+        bc         
+        c         |+                   
-------------------+--------------------
 xx                | yyyyyyyyyyyyyyyyyy
 xxxx              | yyyyyyyyyyyyyyyy   
 xxxxxx            : yyyyyyyyyyyyyy     
 xxxxxxxx          : yyyyyyyyyyyy       
 xxxxxxxxxx        : yyyyyyyyyy         
 xxxxxxxxxxxx      : yyyyyyyy           
 xxxxxxxxxxxxxx    : yyyyyy             
 xxxxxxxxxxxxxxxx  : yyyy               
 xxxxxxxxxxxxxxxxx : yy                 
 x                 : 
 xxxxxxxxxxxxxxxxx   
 xxx                 
(2 rows)

\pset border 2
\pset format unaligned
execute q;
ab

c|a
bc
xx|yyyyyyyyyyyyyyyyyy
xxxx
xxxxxx
xxxxxxxx
xxxxxxxxxx
xxxxxxxxxxxx
xxxxxxxxxxxxxx
xxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxx|yyyyyyyyyyyyyyyy
yyyyyyyyyyyyyy
yyyyyyyyyyyy
yyyyyyyyyy
yyyyyyyy
yyyyyy
yyyy
yy

(2 rows)
\pset format aligned
execute q;
+----------------------+--------------------+
|          ab          |         a          |
|+                     |+        bc         |
|+         c           |+                   |
+----------------------+--------------------+
| xx                   | yyyyyyyyyyyyyyyyyy |
| xxxx                 | yyyyyyyyyyyyyyyy   |
| xxxxxx               : yyyyyyyyyyyyyy     |
| xxxxxxxx             : yyyyyyyyyyyy       |
| xxxxxxxxxx           : yyyyyyyyyy         |
| xxxxxxxxxxxx         : yyyyyyyy           |
| xxxxxxxxxxxxxx       : yyyyyy             |
| xxxxxxxxxxxxxxxx     : yyyy               |
| xxxxxxxxxxxxxxxxxx   : yy                 |
| xxxxxxxxxxxxxxxxxxxx :                    |
+----------------------+--------------------+
(2 rows)

\pset format wrapped
execute q;
+-----------------+--------------------+
|       ab        |         a          |
|+                |+        bc         |
|+       c        |+                   |
+-----------------+--------------------+
| xx              | yyyyyyyyyyyyyyyyyy |
| xxxx            | yyyyyyyyyyyyyyyy   |
| xxxxxx          : yyyyyyyyyyyyyy     |
| xxxxxxxx        : yyyyyyyyyyyy       |
| xxxxxxxxxx      : yyyyyyyyyy         |
| xxxxxxxxxxxx    : yyyyyyyy           |
| xxxxxxxxxxxxxx  : yyyyyy             |
| xxxxxxxxxxxxxxx : yyyy               |
| x               : yy                 |
| xxxxxxxxxxxxxxx :                    |
| xxx                                  |
| xxxxxxxxxxxxxxx                      |
| xxxxx                                |
+-----------------+--------------------+
(2 rows)

\pset expanded on
\pset columns 20
\pset border 0
\pset format unaligned
execute q;
ab

c|xx
a
bc|yyyyyyyyyyyyyyyyyy

ab

c|xxxx
xxxxxx
xxxxxxxx
xxxxxxxxxx
xxxxxxxxxxxx
xxxxxxxxxxxxxx
xxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxx
a
bc|yyyyyyyyyyyyyyyy
yyyyyyyyyyyyyy
yyyyyyyyyyyy
yyyyyyyyyy
yyyyyyyy
yyyyyy
yyyy
yy

\pset format aligned
execute q;
* Record 1             
 ab xx
+  
+c 
 a  yyyyyyyyyyyyyyyyyy
+bc
* Record 2             
 ab xxxx
+   xxxxxx
+c  xxxxxxxx
    xxxxxxxxxx
    xxxxxxxxxxxx
    xxxxxxxxxxxxxx
    xxxxxxxxxxxxxxxx
    xxxxxxxxxxxxxxxxxx
    xxxxxxxxxxxxxxxxxxxx
 a  yyyyyyyyyyyyyyyy
+bc yyyyyyyyyyyyyy
    yyyyyyyyyyyy
    yyyyyyyyyy
    yyyyyyyy
    yyyyyy
    yyyy
    yy
    

\pset format wrapped
execute q;
* Record 1         
 ab xx
+  
+c 
 a  yyyyyyyyyyyyyyyy
+bc yy
* Record 2         
 ab xxxx
+   xxxxxx
+c  xxxxxxxx
    xxxxxxxxxx
    xxxxxxxxxxxx
    xxxxxxxxxxxxxx
    xxxxxxxxxxxxxxxx
    xxxxxxxxxxxxxxxx
    xx
    xxxxxxxxxxxxxxxx
    xxxx
 a  yyyyyyyyyyyyyyyy
+bc yyyyyyyyyyyyyy
    yyyyyyyyyyyy
    yyyyyyyyyy
    yyyyyyyy
    yyyyyy
    yyyy
    yy
    

\pset border 1
\pset format unaligned
execute q;
ab

c|xx
a
bc|yyyyyyyyyyyyyyyyyy

ab

c|xxxx
xxxxxx
xxxxxxxx
xxxxxxxxxx
xxxxxxxxxxxx
xxxxxxxxxxxxxx
xxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxx
a
bc|yyyyyyyyyyyyyyyy
yyyyyyyyyyyyyy
yyyyyyyyyyyy
yyyyyyyyyy
yyyyyyyy
yyyyyy
yyyy
yy

\pset format aligned
execute q;
-[ RECORD 1 ]-------------
 ab | xx
+   ;
+c  ;
 a  | yyyyyyyyyyyyyyyyyy
+bc ;
-[ RECORD 2 ]-------------
 ab | xxxx
+   : xxxxxx
+c  : xxxxxxxx
    : xxxxxxxxxx
    : xxxxxxxxxxxx
    : xxxxxxxxxxxxxx
    : xxxxxxxxxxxxxxxx
    : xxxxxxxxxxxxxxxxxx
    : xxxxxxxxxxxxxxxxxxxx
 a  | yyyyyyyyyyyyyyyy
+bc : yyyyyyyyyyyyyy
    : yyyyyyyyyyyy
    : yyyyyyyyyy
    : yyyyyyyy
    : yyyyyy
    : yyyy
    : yy
    : 

\pset format wrapped
execute q;
-[ RECORD 1 ]-------
 ab | xx
+   ;
+c  ;
 a  | yyyyyyyyyyyyyy
+bc ; yyyy
-[ RECORD 2 ]-------
 ab | xxxx
+   : xxxxxx
+c  : xxxxxxxx
    : xxxxxxxxxx
    : xxxxxxxxxxxx
    : xxxxxxxxxxxxxx
    : xxxxxxxxxxxxxx
    ; xx
    : xxxxxxxxxxxxxx
    ; xxxx
    : xxxxxxxxxxxxxx
    ; xxxxxx
 a  | yyyyyyyyyyyyyy
+bc ; yy
    : yyyyyyyyyyyyyy
    : yyyyyyyyyyyy
    : yyyyyyyyyy
    : yyyyyyyy
    : yyyyyy
    : yyyy
    : yy
    : 

\pset border 2
\pset format unaligned
execute q;
ab

c|xx
a
bc|yyyyyyyyyyyyyyyyyy

ab

c|xxxx
xxxxxx
xxxxxxxx
xxxxxxxxxx
xxxxxxxxxxxx
xxxxxxxxxxxxxx
xxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxx
a
bc|yyyyyyyyyyyyyyyy
yyyyyyyyyyyyyy
yyyyyyyyyyyy
yyyyyyyyyy
yyyyyyyy
yyyyyy
yyyy
yy

\pset format aligned
execute q;
+-[ RECORD 1 ]--------------+
| ab | xx                   |
|+   ;                      |
|+c  ;                      |
| a  | yyyyyyyyyyyyyyyyyy   |
|+bc ;                      |
+-[ RECORD 2 ]--------------+
| ab | xxxx                 |
|+   : xxxxxx               |
|+c  : xxxxxxxx             |
|    : xxxxxxxxxx           |
|    : xxxxxxxxxxxx         |
|    : xxxxxxxxxxxxxx       |
|    : xxxxxxxxxxxxxxxx     |
|    : xxxxxxxxxxxxxxxxxx   |
|    : xxxxxxxxxxxxxxxxxxxx |
| a  | yyyyyyyyyyyyyyyy     |
|+bc : yyyyyyyyyyyyyy       |
|    : yyyyyyyyyyyy         |
|    : yyyyyyyyyy           |
|    : yyyyyyyy             |
|    : yyyyyy               |
|    : yyyy                 |
|    : yy                   |
|    :                      |
+----+----------------------+

\pset format wrapped
execute q;
+-[ RECORD 1 ]-----+
| ab | xx          |
|+   ;             |
|+c  ;             |
| a  | yyyyyyyyyyy |
|+bc ; yyyyyyy     |
+-[ RECORD 2 ]-----+
| ab | xxxx        |
|+   : xxxxxx      |
|+c  : xxxxxxxx    |
|    : xxxxxxxxxx  |
|    : xxxxxxxxxxx |
|    ; x           |
|    : xxxxxxxxxxx |
|    ; xxx         |
|    : xxxxxxxxxxx |
|    ; xxxxx       |
|    : xxxxxxxxxxx |
|    ; xxxxxxx     |
|    : xxxxxxxxxxx |
|    ; xxxxxxxxx   |
| a  | yyyyyyyyyyy |
|+bc ; yyyyy       |
|    : yyyyyyyyyyy |
|    ; yyy         |
|    : yyyyyyyyyyy |
|    ; y           |
|    : yyyyyyyyyy  |
|    : yyyyyyyy    |
|    : yyyyyy      |
|    : yyyy        |
|    : yy          |
|    :             |
+----+-------------+

deallocate q;
-- test single-line header and data
prepare q as select repeat('x',2*n) as "0123456789abcdef", repeat('y',20-2*n) as "0123456789" from generate_series(1,10) as n;
\pset linestyle ascii
\pset expanded off
\pset columns 40
\pset border 0
\pset format unaligned
execute q;
0123456789abcdef|0123456789
xx|yyyyyyyyyyyyyyyyyy
xxxx|yyyyyyyyyyyyyyyy
xxxxxx|yyyyyyyyyyyyyy
xxxxxxxx|yyyyyyyyyyyy
xxxxxxxxxx|yyyyyyyyyy
xxxxxxxxxxxx|yyyyyyyy
xxxxxxxxxxxxxx|yyyyyy
xxxxxxxxxxxxxxxx|yyyy
xxxxxxxxxxxxxxxxxx|yy
xxxxxxxxxxxxxxxxxxxx|
(10 rows)
\pset format aligned
execute q;
  0123456789abcdef       0123456789     
-------------------- ------------------
xx                   yyyyyyyyyyyyyyyyyy
xxxx                 yyyyyyyyyyyyyyyy
xxxxxx               yyyyyyyyyyyyyy
xxxxxxxx             yyyyyyyyyyyy
xxxxxxxxxx           yyyyyyyyyy
xxxxxxxxxxxx         yyyyyyyy
xxxxxxxxxxxxxx       yyyyyy
xxxxxxxxxxxxxxxx     yyyy
xxxxxxxxxxxxxxxxxx   yy
xxxxxxxxxxxxxxxxxxxx 
(10 rows)

\pset format wrapped
execute q;
  0123456789abcdef       0123456789     
-------------------- ------------------
xx                   yyyyyyyyyyyyyyyyyy
xxxx                 yyyyyyyyyyyyyyyy
xxxxxx               yyyyyyyyyyyyyy
xxxxxxxx             yyyyyyyyyyyy
xxxxxxxxxx           yyyyyyyyyy
xxxxxxxxxxxx         yyyyyyyy
xxxxxxxxxxxxxx       yyyyyy
xxxxxxxxxxxxxxxx     yyyy
xxxxxxxxxxxxxxxxxx   yy
xxxxxxxxxxxxxxxxxxxx 
(10 rows)

\pset border 1
\pset format unaligned
execute q;
0123456789abcdef|0123456789
xx|yyyyyyyyyyyyyyyyyy
xxxx|yyyyyyyyyyyyyyyy
xxxxxx|yyyyyyyyyyyyyy
xxxxxxxx|yyyyyyyyyyyy
xxxxxxxxxx|yyyyyyyyyy
xxxxxxxxxxxx|yyyyyyyy
xxxxxxxxxxxxxx|yyyyyy
xxxxxxxxxxxxxxxx|yyyy
xxxxxxxxxxxxxxxxxx|yy
xxxxxxxxxxxxxxxxxxxx|
(10 rows)
\pset format aligned
execute q;
   0123456789abcdef   |     0123456789     
----------------------+--------------------
 xx                   | yyyyyyyyyyyyyyyyyy
 xxxx                 | yyyyyyyyyyyyyyyy
 xxxxxx               | yyyyyyyyyyyyyy
 xxxxxxxx             | yyyyyyyyyyyy
 xxxxxxxxxx           | yyyyyyyyyy
 xxxxxxxxxxxx         | yyyyyyyy
 xxxxxxxxxxxxxx       | yyyyyy
 xxxxxxxxxxxxxxxx     | yyyy
 xxxxxxxxxxxxxxxxxx   | yy
 xxxxxxxxxxxxxxxxxxxx | 
(10 rows)

\pset format wrapped
execute q;
  0123456789abcdef   |    0123456789    
---------------------+------------------
 xx                  | yyyyyyyyyyyyyyyy.
                     |.yy
 xxxx                | yyyyyyyyyyyyyyyy
 xxxxxx              | yyyyyyyyyyyyyy
 xxxxxxxx            | yyyyyyyyyyyy
 xxxxxxxxxx          | yyyyyyyyyy
 xxxxxxxxxxxx        | yyyyyyyy
 xxxxxxxxxxxxxx      | yyyyyy
 xxxxxxxxxxxxxxxx    | yyyy
 xxxxxxxxxxxxxxxxxx  | yy
 xxxxxxxxxxxxxxxxxxx.| 
.x                   | 
(10 rows)

\pset border 2
\pset format unaligned
execute q;
0123456789abcdef|0123456789
xx|yyyyyyyyyyyyyyyyyy
xxxx|yyyyyyyyyyyyyyyy
xxxxxx|yyyyyyyyyyyyyy
xxxxxxxx|yyyyyyyyyyyy
xxxxxxxxxx|yyyyyyyyyy
xxxxxxxxxxxx|yyyyyyyy
xxxxxxxxxxxxxx|yyyyyy
xxxxxxxxxxxxxxxx|yyyy
xxxxxxxxxxxxxxxxxx|yy
xxxxxxxxxxxxxxxxxxxx|
(10 rows)
\pset format aligned
execute q;
+----------------------+--------------------+
|   0123456789abcdef   |     0123456789     |
+----------------------+--------------------+
| xx                   | yyyyyyyyyyyyyyyyyy |
| xxxx                 | yyyyyyyyyyyyyyyy   |
| xxxxxx               | yyyyyyyyyyyyyy     |
| xxxxxxxx             | yyyyyyyyyyyy       |
| xxxxxxxxxx           | yyyyyyyyyy         |
| xxxxxxxxxxxx         | yyyyyyyy           |
| xxxxxxxxxxxxxx       | yyyyyy             |
| xxxxxxxxxxxxxxxx     | yyyy               |
| xxxxxxxxxxxxxxxxxx   | yy                 |
| xxxxxxxxxxxxxxxxxxxx |                    |
+----------------------+--------------------+
(10 rows)

\pset format wrapped
execute q;
+--------------------+-----------------+
|  0123456789abcdef  |   0123456789    |
+--------------------+-----------------+
| xx                 | yyyyyyyyyyyyyyy.|
|                    |.yyy             |
| xxxx               | yyyyyyyyyyyyyyy.|
|                    |.y               |
| xxxxxx             | yyyyyyyyyyyyyy  |
| xxxxxxxx           | yyyyyyyyyyyy    |
| xxxxxxxxxx         | yyyyyyyyyy      |
| xxxxxxxxxxxx       | yyyyyyyy        |
| xxxxxxxxxxxxxx     | yyyyyy          |
| xxxxxxxxxxxxxxxx   | yyyy            |
| xxxxxxxxxxxxxxxxxx | yy              |
| xxxxxxxxxxxxxxxxxx.|                 |
|.xx                 |                 |
+--------------------+-----------------+
(10 rows)

\pset expanded on
\pset columns 30
\pset border 0
\pset format unaligned
execute q;
0123456789abcdef|xx
0123456789|yyyyyyyyyyyyyyyyyy

0123456789abcdef|xxxx
0123456789|yyyyyyyyyyyyyyyy

0123456789abcdef|xxxxxx
0123456789|yyyyyyyyyyyyyy

0123456789abcdef|xxxxxxxx
0123456789|yyyyyyyyyyyy

0123456789abcdef|xxxxxxxxxx
0123456789|yyyyyyyyyy

0123456789abcdef|xxxxxxxxxxxx
0123456789|yyyyyyyy

0123456789abcdef|xxxxxxxxxxxxxx
0123456789|yyyyyy

0123456789abcdef|xxxxxxxxxxxxxxxx
0123456789|yyyy

0123456789abcdef|xxxxxxxxxxxxxxxxxx
0123456789|yy

0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
0123456789|
\pset format aligned
execute q;
* Record 1                          
0123456789abcdef xx
0123456789       yyyyyyyyyyyyyyyyyy
* Record 2                          
0123456789abcdef xxxx
0123456789       yyyyyyyyyyyyyyyy
* Record 3                          
0123456789abcdef xxxxxx
0123456789       yyyyyyyyyyyyyy
* Record 4                          
0123456789abcdef xxxxxxxx
0123456789       yyyyyyyyyyyy
* Record 5                          
0123456789abcdef xxxxxxxxxx
0123456789       yyyyyyyyyy
* Record 6                          
0123456789abcdef xxxxxxxxxxxx
0123456789       yyyyyyyy
* Record 7                          
0123456789abcdef xxxxxxxxxxxxxx
0123456789       yyyyyy
* Record 8                          
0123456789abcdef xxxxxxxxxxxxxxxx
0123456789       yyyy
* Record 9                          
0123456789abcdef xxxxxxxxxxxxxxxxxx
0123456789       yy
* Record 10                         
0123456789abcdef xxxxxxxxxxxxxxxxxxxx
0123456789       

\pset format wrapped
execute q;
* Record 1                  
0123456789abcdef xx
0123456789       yyyyyyyyyyyy.
                .yyyyyy
* Record 2                  
0123456789abcdef xxxx
0123456789       yyyyyyyyyyyy.
                .yyyy
* Record 3                  
0123456789abcdef xxxxxx
0123456789       yyyyyyyyyyyy.
                .yy
* Record 4                  
0123456789abcdef xxxxxxxx
0123456789       yyyyyyyyyyyy
* Record 5                  
0123456789abcdef xxxxxxxxxx
0123456789       yyyyyyyyyy
* Record 6                  
0123456789abcdef xxxxxxxxxxxx
0123456789       yyyyyyyy
* Record 7                  
0123456789abcdef xxxxxxxxxxxx.
                .xx
0123456789       yyyyyy
* Record 8                  
0123456789abcdef xxxxxxxxxxxx.
                .xxxx
0123456789       yyyy
* Record 9                  
0123456789abcdef xxxxxxxxxxxx.
                .xxxxxx
0123456789       yy
* Record 10                 
0123456789abcdef xxxxxxxxxxxx.
                .xxxxxxxx
0123456789       

\pset border 1
\pset format unaligned
execute q;
0123456789abcdef|xx
0123456789|yyyyyyyyyyyyyyyyyy

0123456789abcdef|xxxx
0123456789|yyyyyyyyyyyyyyyy

0123456789abcdef|xxxxxx
0123456789|yyyyyyyyyyyyyy

0123456789abcdef|xxxxxxxx
0123456789|yyyyyyyyyyyy

0123456789abcdef|xxxxxxxxxx
0123456789|yyyyyyyyyy

0123456789abcdef|xxxxxxxxxxxx
0123456789|yyyyyyyy

0123456789abcdef|xxxxxxxxxxxxxx
0123456789|yyyyyy

0123456789abcdef|xxxxxxxxxxxxxxxx
0123456789|yyyy

0123456789abcdef|xxxxxxxxxxxxxxxxxx
0123456789|yy

0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
0123456789|
\pset format aligned
execute q;
-[ RECORD 1 ]----+---------------------
0123456789abcdef | xx
0123456789       | yyyyyyyyyyyyyyyyyy
-[ RECORD 2 ]----+---------------------
0123456789abcdef | xxxx
0123456789       | yyyyyyyyyyyyyyyy
-[ RECORD 3 ]----+---------------------
0123456789abcdef | xxxxxx
0123456789       | yyyyyyyyyyyyyy
-[ RECORD 4 ]----+---------------------
0123456789abcdef | xxxxxxxx
0123456789       | yyyyyyyyyyyy
-[ RECORD 5 ]----+---------------------
0123456789abcdef | xxxxxxxxxx
0123456789       | yyyyyyyyyy
-[ RECORD 6 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxx
0123456789       | yyyyyyyy
-[ RECORD 7 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxxxx
0123456789       | yyyyyy
-[ RECORD 8 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxxxxxx
0123456789       | yyyy
-[ RECORD 9 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxxxxxxxx
0123456789       | yy
-[ RECORD 10 ]---+---------------------
0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
0123456789       | 

\pset format wrapped
execute q;
-[ RECORD 1 ]----+-----------
0123456789abcdef | xx
0123456789       | yyyyyyyyyy.
                 |.yyyyyyyy
-[ RECORD 2 ]----+-----------
0123456789abcdef | xxxx
0123456789       | yyyyyyyyyy.
                 |.yyyyyy
-[ RECORD 3 ]----+-----------
0123456789abcdef | xxxxxx
0123456789       | yyyyyyyyyy.
                 |.yyyy
-[ RECORD 4 ]----+-----------
0123456789abcdef | xxxxxxxx
0123456789       | yyyyyyyyyy.
                 |.yy
-[ RECORD 5 ]----+-----------
0123456789abcdef | xxxxxxxxxx
0123456789       | yyyyyyyyyy
-[ RECORD 6 ]----+-----------
0123456789abcdef | xxxxxxxxxx.
                 |.xx
0123456789       | yyyyyyyy
-[ RECORD 7 ]----+-----------
0123456789abcdef | xxxxxxxxxx.
                 |.xxxx
0123456789       | yyyyyy
-[ RECORD 8 ]----+-----------
0123456789abcdef | xxxxxxxxxx.
                 |.xxxxxx
0123456789       | yyyy
-[ RECORD 9 ]----+-----------
0123456789abcdef | xxxxxxxxxx.
                 |.xxxxxxxx
0123456789       | yy
-[ RECORD 10 ]---+-----------
0123456789abcdef | xxxxxxxxxx.
                 |.xxxxxxxxxx
0123456789       | 

\pset border 2
\pset format unaligned
execute q;
0123456789abcdef|xx
0123456789|yyyyyyyyyyyyyyyyyy

0123456789abcdef|xxxx
0123456789|yyyyyyyyyyyyyyyy

0123456789abcdef|xxxxxx
0123456789|yyyyyyyyyyyyyy

0123456789abcdef|xxxxxxxx
0123456789|yyyyyyyyyyyy

0123456789abcdef|xxxxxxxxxx
0123456789|yyyyyyyyyy

0123456789abcdef|xxxxxxxxxxxx
0123456789|yyyyyyyy

0123456789abcdef|xxxxxxxxxxxxxx
0123456789|yyyyyy

0123456789abcdef|xxxxxxxxxxxxxxxx
0123456789|yyyy

0123456789abcdef|xxxxxxxxxxxxxxxxxx
0123456789|yy

0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
0123456789|
\pset format aligned
execute q;
+-[ RECORD 1 ]-----+----------------------+
| 0123456789abcdef | xx                   |
| 0123456789       | yyyyyyyyyyyyyyyyyy   |
+-[ RECORD 2 ]-----+----------------------+
| 0123456789abcdef | xxxx                 |
| 0123456789       | yyyyyyyyyyyyyyyy     |
+-[ RECORD 3 ]-----+----------------------+
| 0123456789abcdef | xxxxxx               |
| 0123456789       | yyyyyyyyyyyyyy       |
+-[ RECORD 4 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxx             |
| 0123456789       | yyyyyyyyyyyy         |
+-[ RECORD 5 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxx           |
| 0123456789       | yyyyyyyyyy           |
+-[ RECORD 6 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxx         |
| 0123456789       | yyyyyyyy             |
+-[ RECORD 7 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxxxx       |
| 0123456789       | yyyyyy               |
+-[ RECORD 8 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxxxxxx     |
| 0123456789       | yyyy                 |
+-[ RECORD 9 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxxxxxxxx   |
| 0123456789       | yy                   |
+-[ RECORD 10 ]----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx |
| 0123456789       |                      |
+------------------+----------------------+

\pset format wrapped
execute q;
+-[ RECORD 1 ]-----+---------+
| 0123456789abcdef | xx      |
| 0123456789       | yyyyyyy.|
|                  |.yyyyyyy.|
|                  |.yyyy    |
+-[ RECORD 2 ]-----+---------+
| 0123456789abcdef | xxxx    |
| 0123456789       | yyyyyyy.|
|                  |.yyyyyyy.|
|                  |.yy      |
+-[ RECORD 3 ]-----+---------+
| 0123456789abcdef | xxxxxx  |
| 0123456789       | yyyyyyy.|
|                  |.yyyyyyy |
+-[ RECORD 4 ]-----+---------+
| 0123456789abcdef | xxxxxxx.|
|                  |.x       |
| 0123456789       | yyyyyyy.|
|                  |.yyyyy   |
+-[ RECORD 5 ]-----+---------+
| 0123456789abcdef | xxxxxxx.|
|                  |.xxx     |
| 0123456789       | yyyyyyy.|
|                  |.yyy     |
+-[ RECORD 6 ]-----+---------+
| 0123456789abcdef | xxxxxxx.|
|                  |.xxxxx   |
| 0123456789       | yyyyyyy.|
|                  |.y       |
+-[ RECORD 7 ]-----+---------+
| 0123456789abcdef | xxxxxxx.|
|                  |.xxxxxxx |
| 0123456789       | yyyyyy  |
+-[ RECORD 8 ]-----+---------+
| 0123456789abcdef | xxxxxxx.|
|                  |.xxxxxxx.|
|                  |.xx      |
| 0123456789       | yyyy    |
+-[ RECORD 9 ]-----+---------+
| 0123456789abcdef | xxxxxxx.|
|                  |.xxxxxxx.|
|                  |.xxxx    |
| 0123456789       | yy      |
+-[ RECORD 10 ]----+---------+
| 0123456789abcdef | xxxxxxx.|
|                  |.xxxxxxx.|
|                  |.xxxxxx  |
| 0123456789       |         |
+------------------+---------+

\pset expanded on
\pset columns 20
\pset border 0
\pset format unaligned
execute q;
0123456789abcdef|xx
0123456789|yyyyyyyyyyyyyyyyyy

0123456789abcdef|xxxx
0123456789|yyyyyyyyyyyyyyyy

0123456789abcdef|xxxxxx
0123456789|yyyyyyyyyyyyyy

0123456789abcdef|xxxxxxxx
0123456789|yyyyyyyyyyyy

0123456789abcdef|xxxxxxxxxx
0123456789|yyyyyyyyyy

0123456789abcdef|xxxxxxxxxxxx
0123456789|yyyyyyyy

0123456789abcdef|xxxxxxxxxxxxxx
0123456789|yyyyyy

0123456789abcdef|xxxxxxxxxxxxxxxx
0123456789|yyyy

0123456789abcdef|xxxxxxxxxxxxxxxxxx
0123456789|yy

0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
0123456789|
\pset format aligned
execute q;
* Record 1                          
0123456789abcdef xx
0123456789       yyyyyyyyyyyyyyyyyy
* Record 2                          
0123456789abcdef xxxx
0123456789       yyyyyyyyyyyyyyyy
* Record 3                          
0123456789abcdef xxxxxx
0123456789       yyyyyyyyyyyyyy
* Record 4                          
0123456789abcdef xxxxxxxx
0123456789       yyyyyyyyyyyy
* Record 5                          
0123456789abcdef xxxxxxxxxx
0123456789       yyyyyyyyyy
* Record 6                          
0123456789abcdef xxxxxxxxxxxx
0123456789       yyyyyyyy
* Record 7                          
0123456789abcdef xxxxxxxxxxxxxx
0123456789       yyyyyy
* Record 8                          
0123456789abcdef xxxxxxxxxxxxxxxx
0123456789       yyyy
* Record 9                          
0123456789abcdef xxxxxxxxxxxxxxxxxx
0123456789       yy
* Record 10                         
0123456789abcdef xxxxxxxxxxxxxxxxxxxx
0123456789       

\pset format wrapped
execute q;
* Record 1         
0123456789abcdef xx
0123456789       yyy.
                .yyy.
                .yyy.
                .yyy.
                .yyy.
                .yyy
* Record 2         
0123456789abcdef xxx.
                .x
0123456789       yyy.
                .yyy.
                .yyy.
                .yyy.
                .yyy.
                .y
* Record 3         
0123456789abcdef xxx.
                .xxx
0123456789       yyy.
                .yyy.
                .yyy.
                .yyy.
                .yy
* Record 4         
0123456789abcdef xxx.
                .xxx.
                .xx
0123456789       yyy.
                .yyy.
                .yyy.
                .yyy
* Record 5         
0123456789abcdef xxx.
                .xxx.
                .xxx.
                .x
0123456789       yyy.
                .yyy.
                .yyy.
                .y
* Record 6         
0123456789abcdef xxx.
                .xxx.
                .xxx.
                .xxx
0123456789       yyy.
                .yyy.
                .yy
* Record 7         
0123456789abcdef xxx.
                .xxx.
                .xxx.
                .xxx.
                .xx
0123456789       yyy.
                .yyy
* Record 8         
0123456789abcdef xxx.
                .xxx.
                .xxx.
                .xxx.
                .xxx.
                .x
0123456789       yyy.
                .y
* Record 9         
0123456789abcdef xxx.
                .xxx.
                .xxx.
                .xxx.
                .xxx.
                .xxx
0123456789       yy
* Record 10        
0123456789abcdef xxx.
                .xxx.
                .xxx.
                .xxx.
                .xxx.
                .xxx.
                .xx
0123456789       

\pset border 1
\pset format unaligned
execute q;
0123456789abcdef|xx
0123456789|yyyyyyyyyyyyyyyyyy

0123456789abcdef|xxxx
0123456789|yyyyyyyyyyyyyyyy

0123456789abcdef|xxxxxx
0123456789|yyyyyyyyyyyyyy

0123456789abcdef|xxxxxxxx
0123456789|yyyyyyyyyyyy

0123456789abcdef|xxxxxxxxxx
0123456789|yyyyyyyyyy

0123456789abcdef|xxxxxxxxxxxx
0123456789|yyyyyyyy

0123456789abcdef|xxxxxxxxxxxxxx
0123456789|yyyyyy

0123456789abcdef|xxxxxxxxxxxxxxxx
0123456789|yyyy

0123456789abcdef|xxxxxxxxxxxxxxxxxx
0123456789|yy

0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
0123456789|
\pset format aligned
execute q;
-[ RECORD 1 ]----+---------------------
0123456789abcdef | xx
0123456789       | yyyyyyyyyyyyyyyyyy
-[ RECORD 2 ]----+---------------------
0123456789abcdef | xxxx
0123456789       | yyyyyyyyyyyyyyyy
-[ RECORD 3 ]----+---------------------
0123456789abcdef | xxxxxx
0123456789       | yyyyyyyyyyyyyy
-[ RECORD 4 ]----+---------------------
0123456789abcdef | xxxxxxxx
0123456789       | yyyyyyyyyyyy
-[ RECORD 5 ]----+---------------------
0123456789abcdef | xxxxxxxxxx
0123456789       | yyyyyyyyyy
-[ RECORD 6 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxx
0123456789       | yyyyyyyy
-[ RECORD 7 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxxxx
0123456789       | yyyyyy
-[ RECORD 8 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxxxxxx
0123456789       | yyyy
-[ RECORD 9 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxxxxxxxx
0123456789       | yy
-[ RECORD 10 ]---+---------------------
0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
0123456789       | 

\pset format wrapped
execute q;
-[ RECORD 1 ]----+----
0123456789abcdef | xx
0123456789       | yyy.
                 |.yyy.
                 |.yyy.
                 |.yyy.
                 |.yyy.
                 |.yyy
-[ RECORD 2 ]----+----
0123456789abcdef | xxx.
                 |.x
0123456789       | yyy.
                 |.yyy.
                 |.yyy.
                 |.yyy.
                 |.yyy.
                 |.y
-[ RECORD 3 ]----+----
0123456789abcdef | xxx.
                 |.xxx
0123456789       | yyy.
                 |.yyy.
                 |.yyy.
                 |.yyy.
                 |.yy
-[ RECORD 4 ]----+----
0123456789abcdef | xxx.
                 |.xxx.
                 |.xx
0123456789       | yyy.
                 |.yyy.
                 |.yyy.
                 |.yyy
-[ RECORD 5 ]----+----
0123456789abcdef | xxx.
                 |.xxx.
                 |.xxx.
                 |.x
0123456789       | yyy.
                 |.yyy.
                 |.yyy.
                 |.y
-[ RECORD 6 ]----+----
0123456789abcdef | xxx.
                 |.xxx.
                 |.xxx.
                 |.xxx
0123456789       | yyy.
                 |.yyy.
                 |.yy
-[ RECORD 7 ]----+----
0123456789abcdef | xxx.
                 |.xxx.
                 |.xxx.
                 |.xxx.
                 |.xx
0123456789       | yyy.
                 |.yyy
-[ RECORD 8 ]----+----
0123456789abcdef | xxx.
                 |.xxx.
                 |.xxx.
                 |.xxx.
                 |.xxx.
                 |.x
0123456789       | yyy.
                 |.y
-[ RECORD 9 ]----+----
0123456789abcdef | xxx.
                 |.xxx.
                 |.xxx.
                 |.xxx.
                 |.xxx.
                 |.xxx
0123456789       | yy
-[ RECORD 10 ]---+----
0123456789abcdef | xxx.
                 |.xxx.
                 |.xxx.
                 |.xxx.
                 |.xxx.
                 |.xxx.
                 |.xx
0123456789       | 

\pset border 2
\pset format unaligned
execute q;
0123456789abcdef|xx
0123456789|yyyyyyyyyyyyyyyyyy

0123456789abcdef|xxxx
0123456789|yyyyyyyyyyyyyyyy

0123456789abcdef|xxxxxx
0123456789|yyyyyyyyyyyyyy

0123456789abcdef|xxxxxxxx
0123456789|yyyyyyyyyyyy

0123456789abcdef|xxxxxxxxxx
0123456789|yyyyyyyyyy

0123456789abcdef|xxxxxxxxxxxx
0123456789|yyyyyyyy

0123456789abcdef|xxxxxxxxxxxxxx
0123456789|yyyyyy

0123456789abcdef|xxxxxxxxxxxxxxxx
0123456789|yyyy

0123456789abcdef|xxxxxxxxxxxxxxxxxx
0123456789|yy

0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
0123456789|
\pset format aligned
execute q;
+-[ RECORD 1 ]-----+----------------------+
| 0123456789abcdef | xx                   |
| 0123456789       | yyyyyyyyyyyyyyyyyy   |
+-[ RECORD 2 ]-----+----------------------+
| 0123456789abcdef | xxxx                 |
| 0123456789       | yyyyyyyyyyyyyyyy     |
+-[ RECORD 3 ]-----+----------------------+
| 0123456789abcdef | xxxxxx               |
| 0123456789       | yyyyyyyyyyyyyy       |
+-[ RECORD 4 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxx             |
| 0123456789       | yyyyyyyyyyyy         |
+-[ RECORD 5 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxx           |
| 0123456789       | yyyyyyyyyy           |
+-[ RECORD 6 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxx         |
| 0123456789       | yyyyyyyy             |
+-[ RECORD 7 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxxxx       |
| 0123456789       | yyyyyy               |
+-[ RECORD 8 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxxxxxx     |
| 0123456789       | yyyy                 |
+-[ RECORD 9 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxxxxxxxx   |
| 0123456789       | yy                   |
+-[ RECORD 10 ]----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx |
| 0123456789       |                      |
+------------------+----------------------+

\pset format wrapped
execute q;
+-[ RECORD 1 ]-----+-----+
| 0123456789abcdef | xx  |
| 0123456789       | yyy.|
|                  |.yyy.|
|                  |.yyy.|
|                  |.yyy.|
|                  |.yyy.|
|                  |.yyy |
+-[ RECORD 2 ]-----+-----+
| 0123456789abcdef | xxx.|
|                  |.x   |
| 0123456789       | yyy.|
|                  |.yyy.|
|                  |.yyy.|
|                  |.yyy.|
|                  |.yyy.|
|                  |.y   |
+-[ RECORD 3 ]-----+-----+
| 0123456789abcdef | xxx.|
|                  |.xxx |
| 0123456789       | yyy.|
|                  |.yyy.|
|                  |.yyy.|
|                  |.yyy.|
|                  |.yy  |
+-[ RECORD 4 ]-----+-----+
| 0123456789abcdef | xxx.|
|                  |.xxx.|
|                  |.xx  |
| 0123456789       | yyy.|
|                  |.yyy.|
|                  |.yyy.|
|                  |.yyy |
+-[ RECORD 5 ]-----+-----+
| 0123456789abcdef | xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.x   |
| 0123456789       | yyy.|
|                  |.yyy.|
|                  |.yyy.|
|                  |.y   |
+-[ RECORD 6 ]-----+-----+
| 0123456789abcdef | xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.xxx |
| 0123456789       | yyy.|
|                  |.yyy.|
|                  |.yy  |
+-[ RECORD 7 ]-----+-----+
| 0123456789abcdef | xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.xx  |
| 0123456789       | yyy.|
|                  |.yyy |
+-[ RECORD 8 ]-----+-----+
| 0123456789abcdef | xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.x   |
| 0123456789       | yyy.|
|                  |.y   |
+-[ RECORD 9 ]-----+-----+
| 0123456789abcdef | xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.xxx |
| 0123456789       | yy  |
+-[ RECORD 10 ]----+-----+
| 0123456789abcdef | xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.xxx.|
|                  |.xx  |
| 0123456789       |     |
+------------------+-----+

\pset linestyle old-ascii
\pset expanded off
\pset columns 40
\pset border 0
\pset format unaligned
execute q;
0123456789abcdef|0123456789
xx|yyyyyyyyyyyyyyyyyy
xxxx|yyyyyyyyyyyyyyyy
xxxxxx|yyyyyyyyyyyyyy
xxxxxxxx|yyyyyyyyyyyy
xxxxxxxxxx|yyyyyyyyyy
xxxxxxxxxxxx|yyyyyyyy
xxxxxxxxxxxxxx|yyyyyy
xxxxxxxxxxxxxxxx|yyyy
xxxxxxxxxxxxxxxxxx|yy
xxxxxxxxxxxxxxxxxxxx|
(10 rows)
\pset format aligned
execute q;
  0123456789abcdef       0123456789    
-------------------- ------------------
xx                   yyyyyyyyyyyyyyyyyy
xxxx                 yyyyyyyyyyyyyyyy
xxxxxx               yyyyyyyyyyyyyy
xxxxxxxx             yyyyyyyyyyyy
xxxxxxxxxx           yyyyyyyyyy
xxxxxxxxxxxx         yyyyyyyy
xxxxxxxxxxxxxx       yyyyyy
xxxxxxxxxxxxxxxx     yyyy
xxxxxxxxxxxxxxxxxx   yy
xxxxxxxxxxxxxxxxxxxx 
(10 rows)

\pset format wrapped
execute q;
  0123456789abcdef       0123456789    
-------------------- ------------------
xx                   yyyyyyyyyyyyyyyyyy
xxxx                 yyyyyyyyyyyyyyyy
xxxxxx               yyyyyyyyyyyyyy
xxxxxxxx             yyyyyyyyyyyy
xxxxxxxxxx           yyyyyyyyyy
xxxxxxxxxxxx         yyyyyyyy
xxxxxxxxxxxxxx       yyyyyy
xxxxxxxxxxxxxxxx     yyyy
xxxxxxxxxxxxxxxxxx   yy
xxxxxxxxxxxxxxxxxxxx 
(10 rows)

\pset border 1
\pset format unaligned
execute q;
0123456789abcdef|0123456789
xx|yyyyyyyyyyyyyyyyyy
xxxx|yyyyyyyyyyyyyyyy
xxxxxx|yyyyyyyyyyyyyy
xxxxxxxx|yyyyyyyyyyyy
xxxxxxxxxx|yyyyyyyyyy
xxxxxxxxxxxx|yyyyyyyy
xxxxxxxxxxxxxx|yyyyyy
xxxxxxxxxxxxxxxx|yyyy
xxxxxxxxxxxxxxxxxx|yy
xxxxxxxxxxxxxxxxxxxx|
(10 rows)
\pset format aligned
execute q;
   0123456789abcdef   |     0123456789     
----------------------+--------------------
 xx                   | yyyyyyyyyyyyyyyyyy
 xxxx                 | yyyyyyyyyyyyyyyy
 xxxxxx               | yyyyyyyyyyyyyy
 xxxxxxxx             | yyyyyyyyyyyy
 xxxxxxxxxx           | yyyyyyyyyy
 xxxxxxxxxxxx         | yyyyyyyy
 xxxxxxxxxxxxxx       | yyyyyy
 xxxxxxxxxxxxxxxx     | yyyy
 xxxxxxxxxxxxxxxxxx   | yy
 xxxxxxxxxxxxxxxxxxxx | 
(10 rows)

\pset format wrapped
execute q;
  0123456789abcdef   |    0123456789    
---------------------+------------------
 xx                  | yyyyyyyyyyyyyyyy 
                     ; yy
 xxxx                | yyyyyyyyyyyyyyyy
 xxxxxx              | yyyyyyyyyyyyyy
 xxxxxxxx            | yyyyyyyyyyyy
 xxxxxxxxxx          | yyyyyyyyyy
 xxxxxxxxxxxx        | yyyyyyyy
 xxxxxxxxxxxxxx      | yyyyyy
 xxxxxxxxxxxxxxxx    | yyyy
 xxxxxxxxxxxxxxxxxx  | yy
 xxxxxxxxxxxxxxxxxxx | 
 x                     
(10 rows)

\pset border 2
\pset format unaligned
execute q;
0123456789abcdef|0123456789
xx|yyyyyyyyyyyyyyyyyy
xxxx|yyyyyyyyyyyyyyyy
xxxxxx|yyyyyyyyyyyyyy
xxxxxxxx|yyyyyyyyyyyy
xxxxxxxxxx|yyyyyyyyyy
xxxxxxxxxxxx|yyyyyyyy
xxxxxxxxxxxxxx|yyyyyy
xxxxxxxxxxxxxxxx|yyyy
xxxxxxxxxxxxxxxxxx|yy
xxxxxxxxxxxxxxxxxxxx|
(10 rows)
\pset format aligned
execute q;
+----------------------+--------------------+
|   0123456789abcdef   |     0123456789     |
+----------------------+--------------------+
| xx                   | yyyyyyyyyyyyyyyyyy |
| xxxx                 | yyyyyyyyyyyyyyyy   |
| xxxxxx               | yyyyyyyyyyyyyy     |
| xxxxxxxx             | yyyyyyyyyyyy       |
| xxxxxxxxxx           | yyyyyyyyyy         |
| xxxxxxxxxxxx         | yyyyyyyy           |
| xxxxxxxxxxxxxx       | yyyyyy             |
| xxxxxxxxxxxxxxxx     | yyyy               |
| xxxxxxxxxxxxxxxxxx   | yy                 |
| xxxxxxxxxxxxxxxxxxxx |                    |
+----------------------+--------------------+
(10 rows)

\pset format wrapped
execute q;
+--------------------+-----------------+
|  0123456789abcdef  |   0123456789    |
+--------------------+-----------------+
| xx                 | yyyyyyyyyyyyyyy |
|                    ; yyy             |
| xxxx               | yyyyyyyyyyyyyyy |
|                    ; y               |
| xxxxxx             | yyyyyyyyyyyyyy  |
| xxxxxxxx           | yyyyyyyyyyyy    |
| xxxxxxxxxx         | yyyyyyyyyy      |
| xxxxxxxxxxxx       | yyyyyyyy        |
| xxxxxxxxxxxxxx     | yyyyyy          |
| xxxxxxxxxxxxxxxx   | yyyy            |
| xxxxxxxxxxxxxxxxxx | yy              |
| xxxxxxxxxxxxxxxxxx |                 |
| xx                                   |
+--------------------+-----------------+
(10 rows)

\pset expanded on
\pset border 0
\pset format unaligned
execute q;
0123456789abcdef|xx
0123456789|yyyyyyyyyyyyyyyyyy

0123456789abcdef|xxxx
0123456789|yyyyyyyyyyyyyyyy

0123456789abcdef|xxxxxx
0123456789|yyyyyyyyyyyyyy

0123456789abcdef|xxxxxxxx
0123456789|yyyyyyyyyyyy

0123456789abcdef|xxxxxxxxxx
0123456789|yyyyyyyyyy

0123456789abcdef|xxxxxxxxxxxx
0123456789|yyyyyyyy

0123456789abcdef|xxxxxxxxxxxxxx
0123456789|yyyyyy

0123456789abcdef|xxxxxxxxxxxxxxxx
0123456789|yyyy

0123456789abcdef|xxxxxxxxxxxxxxxxxx
0123456789|yy

0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
0123456789|
\pset format aligned
execute q;
* Record 1                          
0123456789abcdef xx
0123456789       yyyyyyyyyyyyyyyyyy
* Record 2                          
0123456789abcdef xxxx
0123456789       yyyyyyyyyyyyyyyy
* Record 3                          
0123456789abcdef xxxxxx
0123456789       yyyyyyyyyyyyyy
* Record 4                          
0123456789abcdef xxxxxxxx
0123456789       yyyyyyyyyyyy
* Record 5                          
0123456789abcdef xxxxxxxxxx
0123456789       yyyyyyyyyy
* Record 6                          
0123456789abcdef xxxxxxxxxxxx
0123456789       yyyyyyyy
* Record 7                          
0123456789abcdef xxxxxxxxxxxxxx
0123456789       yyyyyy
* Record 8                          
0123456789abcdef xxxxxxxxxxxxxxxx
0123456789       yyyy
* Record 9                          
0123456789abcdef xxxxxxxxxxxxxxxxxx
0123456789       yy
* Record 10                         
0123456789abcdef xxxxxxxxxxxxxxxxxxxx
0123456789       

\pset format wrapped
execute q;
* Record 1                          
0123456789abcdef xx
0123456789       yyyyyyyyyyyyyyyyyy
* Record 2                          
0123456789abcdef xxxx
0123456789       yyyyyyyyyyyyyyyy
* Record 3                          
0123456789abcdef xxxxxx
0123456789       yyyyyyyyyyyyyy
* Record 4                          
0123456789abcdef xxxxxxxx
0123456789       yyyyyyyyyyyy
* Record 5                          
0123456789abcdef xxxxxxxxxx
0123456789       yyyyyyyyyy
* Record 6                          
0123456789abcdef xxxxxxxxxxxx
0123456789       yyyyyyyy
* Record 7                          
0123456789abcdef xxxxxxxxxxxxxx
0123456789       yyyyyy
* Record 8                          
0123456789abcdef xxxxxxxxxxxxxxxx
0123456789       yyyy
* Record 9                          
0123456789abcdef xxxxxxxxxxxxxxxxxx
0123456789       yy
* Record 10                         
0123456789abcdef xxxxxxxxxxxxxxxxxxxx
0123456789       

\pset border 1
\pset format unaligned
execute q;
0123456789abcdef|xx
0123456789|yyyyyyyyyyyyyyyyyy

0123456789abcdef|xxxx
0123456789|yyyyyyyyyyyyyyyy

0123456789abcdef|xxxxxx
0123456789|yyyyyyyyyyyyyy

0123456789abcdef|xxxxxxxx
0123456789|yyyyyyyyyyyy

0123456789abcdef|xxxxxxxxxx
0123456789|yyyyyyyyyy

0123456789abcdef|xxxxxxxxxxxx
0123456789|yyyyyyyy

0123456789abcdef|xxxxxxxxxxxxxx
0123456789|yyyyyy

0123456789abcdef|xxxxxxxxxxxxxxxx
0123456789|yyyy

0123456789abcdef|xxxxxxxxxxxxxxxxxx
0123456789|yy

0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
0123456789|
\pset format aligned
execute q;
-[ RECORD 1 ]----+---------------------
0123456789abcdef | xx
0123456789       | yyyyyyyyyyyyyyyyyy
-[ RECORD 2 ]----+---------------------
0123456789abcdef | xxxx
0123456789       | yyyyyyyyyyyyyyyy
-[ RECORD 3 ]----+---------------------
0123456789abcdef | xxxxxx
0123456789       | yyyyyyyyyyyyyy
-[ RECORD 4 ]----+---------------------
0123456789abcdef | xxxxxxxx
0123456789       | yyyyyyyyyyyy
-[ RECORD 5 ]----+---------------------
0123456789abcdef | xxxxxxxxxx
0123456789       | yyyyyyyyyy
-[ RECORD 6 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxx
0123456789       | yyyyyyyy
-[ RECORD 7 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxxxx
0123456789       | yyyyyy
-[ RECORD 8 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxxxxxx
0123456789       | yyyy
-[ RECORD 9 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxxxxxxxx
0123456789       | yy
-[ RECORD 10 ]---+---------------------
0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
0123456789       | 

\pset format wrapped
execute q;
-[ RECORD 1 ]----+---------------------
0123456789abcdef | xx
0123456789       | yyyyyyyyyyyyyyyyyy
-[ RECORD 2 ]----+---------------------
0123456789abcdef | xxxx
0123456789       | yyyyyyyyyyyyyyyy
-[ RECORD 3 ]----+---------------------
0123456789abcdef | xxxxxx
0123456789       | yyyyyyyyyyyyyy
-[ RECORD 4 ]----+---------------------
0123456789abcdef | xxxxxxxx
0123456789       | yyyyyyyyyyyy
-[ RECORD 5 ]----+---------------------
0123456789abcdef | xxxxxxxxxx
0123456789       | yyyyyyyyyy
-[ RECORD 6 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxx
0123456789       | yyyyyyyy
-[ RECORD 7 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxxxx
0123456789       | yyyyyy
-[ RECORD 8 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxxxxxx
0123456789       | yyyy
-[ RECORD 9 ]----+---------------------
0123456789abcdef | xxxxxxxxxxxxxxxxxx
0123456789       | yy
-[ RECORD 10 ]---+---------------------
0123456789abcdef | xxxxxxxxxxxxxxxxxxxx
0123456789       | 

\pset border 2
\pset format unaligned
execute q;
0123456789abcdef|xx
0123456789|yyyyyyyyyyyyyyyyyy

0123456789abcdef|xxxx
0123456789|yyyyyyyyyyyyyyyy

0123456789abcdef|xxxxxx
0123456789|yyyyyyyyyyyyyy

0123456789abcdef|xxxxxxxx
0123456789|yyyyyyyyyyyy

0123456789abcdef|xxxxxxxxxx
0123456789|yyyyyyyyyy

0123456789abcdef|xxxxxxxxxxxx
0123456789|yyyyyyyy

0123456789abcdef|xxxxxxxxxxxxxx
0123456789|yyyyyy

0123456789abcdef|xxxxxxxxxxxxxxxx
0123456789|yyyy

0123456789abcdef|xxxxxxxxxxxxxxxxxx
0123456789|yy

0123456789abcdef|xxxxxxxxxxxxxxxxxxxx
0123456789|
\pset format aligned
execute q;
+-[ RECORD 1 ]-----+----------------------+
| 0123456789abcdef | xx                   |
| 0123456789       | yyyyyyyyyyyyyyyyyy   |
+-[ RECORD 2 ]-----+----------------------+
| 0123456789abcdef | xxxx                 |
| 0123456789       | yyyyyyyyyyyyyyyy     |
+-[ RECORD 3 ]-----+----------------------+
| 0123456789abcdef | xxxxxx               |
| 0123456789       | yyyyyyyyyyyyyy       |
+-[ RECORD 4 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxx             |
| 0123456789       | yyyyyyyyyyyy         |
+-[ RECORD 5 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxx           |
| 0123456789       | yyyyyyyyyy           |
+-[ RECORD 6 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxx         |
| 0123456789       | yyyyyyyy             |
+-[ RECORD 7 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxxxx       |
| 0123456789       | yyyyyy               |
+-[ RECORD 8 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxxxxxx     |
| 0123456789       | yyyy                 |
+-[ RECORD 9 ]-----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxxxxxxxx   |
| 0123456789       | yy                   |
+-[ RECORD 10 ]----+----------------------+
| 0123456789abcdef | xxxxxxxxxxxxxxxxxxxx |
| 0123456789       |                      |
+------------------+----------------------+

\pset format wrapped
execute q;
+-[ RECORD 1 ]-----+-------------------+
| 0123456789abcdef | xx                |
| 0123456789       | yyyyyyyyyyyyyyyyy |
|                  ; y                 |
+-[ RECORD 2 ]-----+-------------------+
| 0123456789abcdef | xxxx              |
| 0123456789       | yyyyyyyyyyyyyyyy  |
+-[ RECORD 3 ]-----+-------------------+
| 0123456789abcdef | xxxxxx            |
| 0123456789       | yyyyyyyyyyyyyy    |
+-[ RECORD 4 ]-----+-------------------+
| 0123456789abcdef | xxxxxxxx          |
| 0123456789       | yyyyyyyyyyyy      |
+-[ RECORD 5 ]-----+-------------------+
| 0123456789abcdef | xxxxxxxxxx        |
| 0123456789       | yyyyyyyyyy        |
+-[ RECORD 6 ]-----+-------------------+
| 0123456789abcdef | xxxxxxxxxxxx      |
| 0123456789       | yyyyyyyy          |
+-[ RECORD 7 ]-----+-------------------+
| 0123456789abcdef | xxxxxxxxxxxxxx    |
| 0123456789       | yyyyyy            |
+-[ RECORD 8 ]-----+-------------------+
| 0123456789abcdef | xxxxxxxxxxxxxxxx  |
| 0123456789       | yyyy              |
+-[ RECORD 9 ]-----+-------------------+
| 0123456789abcdef | xxxxxxxxxxxxxxxxx |
|                  ; x                 |
| 0123456789       | yy                |
+-[ RECORD 10 ]----+-------------------+
| 0123456789abcdef | xxxxxxxxxxxxxxxxx |
|                  ; xxx               |
| 0123456789       |                   |
+------------------+-------------------+

deallocate q;
\pset linestyle ascii
\pset border 1
-- support table for output-format tests (useful to create a footer)
create table psql_serial_tab (id serial);
-- test header/footer/tuples_only behavior in aligned/unaligned/wrapped cases
\pset format aligned
\pset expanded off
\d psql_serial_tab_id_seq
               Sequence "public.psql_serial_tab_id_seq"
  Type   | Start | Minimum |  Maximum   | Increment | Cycles? | Cache 
---------+-------+---------+------------+-----------+---------+-------
 integer |     1 |       1 | 2147483647 |         1 | no      |     1
Owned by: public.psql_serial_tab.id

\pset tuples_only true
\df exp
 pg_catalog | exp  | double precision | double precision    | func
 pg_catalog | exp  | numeric          | numeric             | func

\dfx exp
Schema              | pg_catalog
Name                | exp
Result data type    | double precision
Argument data types | double precision
Type                | func
--------------------+-----------------
Schema              | pg_catalog
Name                | exp
Result data type    | numeric
Argument data types | numeric
Type                | func

\pset tuples_only false
\pset expanded on
\d psql_serial_tab_id_seq
Sequence "public.psql_serial_tab_id_seq"
-[ RECORD 1 ]---------
Type      | integer
Start     | 1
Minimum   | 1
Maximum   | 2147483647
Increment | 1
Cycles?   | no
Cache     | 1

Owned by: public.psql_serial_tab.id

\pset tuples_only true
\df exp
Schema              | pg_catalog
Name                | exp
Result data type    | double precision
Argument data types | double precision
Type                | func
--------------------+-----------------
Schema              | pg_catalog
Name                | exp
Result data type    | numeric
Argument data types | numeric
Type                | func

\pset tuples_only false
-- empty table is a special case for this format
select 1 where false;
(0 rows)

\pset format unaligned
\pset expanded off
\d psql_serial_tab_id_seq
Sequence "public.psql_serial_tab_id_seq"
Type|Start|Minimum|Maximum|Increment|Cycles?|Cache
integer|1|1|2147483647|1|no|1
Owned by: public.psql_serial_tab.id
\pset tuples_only true
\df exp
pg_catalog|exp|double precision|double precision|func
pg_catalog|exp|numeric|numeric|func
\pset tuples_only false
\pset expanded on
\d psql_serial_tab_id_seq
Sequence "public.psql_serial_tab_id_seq"

Type|integer
Start|1
Minimum|1
Maximum|2147483647
Increment|1
Cycles?|no
Cache|1

Owned by: public.psql_serial_tab.id
\pset tuples_only true
\df exp
Schema|pg_catalog
Name|exp
Result data type|double precision
Argument data types|double precision
Type|func

Schema|pg_catalog
Name|exp
Result data type|numeric
Argument data types|numeric
Type|func
\pset tuples_only false
\pset format wrapped
\pset expanded off
\d psql_serial_tab_id_seq
               Sequence "public.psql_serial_tab_id_seq"
  Type   | Start | Minimum |  Maximum   | Increment | Cycles? | Cache 
---------+-------+---------+------------+-----------+---------+-------
 integer |     1 |       1 | 2147483647 |         1 | no      |     1
Owned by: public.psql_serial_tab.id

\pset tuples_only true
\df exp
 pg_catalog | exp  | double precision | double precision    | func
 pg_catalog | exp  | numeric          | numeric             | func

\pset tuples_only false
\pset expanded on
\d psql_serial_tab_id_seq
Sequence "public.psql_serial_tab_id_seq"
-[ RECORD 1 ]---------
Type      | integer
Start     | 1
Minimum   | 1
Maximum   | 2147483647
Increment | 1
Cycles?   | no
Cache     | 1

Owned by: public.psql_serial_tab.id

\pset tuples_only true
\df exp
Schema              | pg_catalog
Name                | exp
Result data type    | double precision
Argument data types | double precision
Type                | func
--------------------+-----------------
Schema              | pg_catalog
Name                | exp
Result data type    | numeric
Argument data types | numeric
Type                | func

\pset tuples_only false
-- check conditional am display
\pset expanded off
CREATE SCHEMA tableam_display;
CREATE ROLE regress_display_role;
ALTER SCHEMA tableam_display OWNER TO regress_display_role;
SET search_path TO tableam_display;
CREATE ACCESS METHOD heap_psql TYPE TABLE HANDLER heap_tableam_handler;
SET ROLE TO regress_display_role;
-- Use only relations with a physical size of zero.
CREATE TABLE tbl_heap_psql(f1 int, f2 char(100)) using heap_psql;
CREATE TABLE tbl_heap(f1 int, f2 char(100)) using heap;
CREATE VIEW view_heap_psql AS SELECT f1 from tbl_heap_psql;
CREATE MATERIALIZED VIEW mat_view_heap_psql USING heap_psql AS SELECT f1 from tbl_heap_psql;
\d+ tbl_heap_psql
                              Table "tableam_display.tbl_heap_psql"
 Column |      Type      | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+----------------+-----------+----------+---------+----------+--------------+-------------
 f1     | integer        |           |          |         | plain    |              | 
 f2     | character(100) |           |          |         | extended |              | 

\d+ tbl_heap
                                 Table "tableam_display.tbl_heap"
 Column |      Type      | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+----------------+-----------+----------+---------+----------+--------------+-------------
 f1     | integer        |           |          |         | plain    |              | 
 f2     | character(100) |           |          |         | extended |              | 

\set HIDE_TABLEAM off
\d+ tbl_heap_psql
                              Table "tableam_display.tbl_heap_psql"
 Column |      Type      | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+----------------+-----------+----------+---------+----------+--------------+-------------
 f1     | integer        |           |          |         | plain    |              | 
 f2     | character(100) |           |          |         | extended |              | 
Access method: heap_psql

\d+ tbl_heap
                                 Table "tableam_display.tbl_heap"
 Column |      Type      | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+----------------+-----------+----------+---------+----------+--------------+-------------
 f1     | integer        |           |          |         | plain    |              | 
 f2     | character(100) |           |          |         | extended |              | 
Access method: heap

-- AM is displayed for tables, indexes and materialized views.
\d+
                                                           List of relations
     Schema      |        Name        |       Type        |        Owner         | Persistence | Access method |  Size   | Description 
-----------------+--------------------+-------------------+----------------------+-------------+---------------+---------+-------------
 tableam_display | mat_view_heap_psql | materialized view | regress_display_role | permanent   | heap_psql     | 0 bytes | 
 tableam_display | tbl_heap           | table             | regress_display_role | permanent   | heap          | 0 bytes | 
 tableam_display | tbl_heap_psql      | table             | regress_display_role | permanent   | heap_psql     | 0 bytes | 
 tableam_display | view_heap_psql     | view              | regress_display_role | permanent   |               | 0 bytes | 
(4 rows)

\dt+
                                                    List of tables
     Schema      |     Name      | Type  |        Owner         | Persistence | Access method |  Size   | Description 
-----------------+---------------+-------+----------------------+-------------+---------------+---------+-------------
 tableam_display | tbl_heap      | table | regress_display_role | permanent   | heap          | 0 bytes | 
 tableam_display | tbl_heap_psql | table | regress_display_role | permanent   | heap_psql     | 0 bytes | 
(2 rows)

\dm+
                                                      List of materialized views
     Schema      |        Name        |       Type        |        Owner         | Persistence | Access method |  Size   | Description 
-----------------+--------------------+-------------------+----------------------+-------------+---------------+---------+-------------
 tableam_display | mat_view_heap_psql | materialized view | regress_display_role | permanent   | heap_psql     | 0 bytes | 
(1 row)

-- But not for views and sequences.
\dv+
                                            List of views
     Schema      |      Name      | Type |        Owner         | Persistence |  Size   | Description 
-----------------+----------------+------+----------------------+-------------+---------+-------------
 tableam_display | view_heap_psql | view | regress_display_role | permanent   | 0 bytes | 
(1 row)

\set HIDE_TABLEAM on
\d+
                                                   List of relations
     Schema      |        Name        |       Type        |        Owner         | Persistence |  Size   | Description 
-----------------+--------------------+-------------------+----------------------+-------------+---------+-------------
 tableam_display | mat_view_heap_psql | materialized view | regress_display_role | permanent   | 0 bytes | 
 tableam_display | tbl_heap           | table             | regress_display_role | permanent   | 0 bytes | 
 tableam_display | tbl_heap_psql      | table             | regress_display_role | permanent   | 0 bytes | 
 tableam_display | view_heap_psql     | view              | regress_display_role | permanent   | 0 bytes | 
(4 rows)

-- \d with 'x' enables expanded mode, but only without a pattern
\d+x tbl_heap
                                 Table "tableam_display.tbl_heap"
 Column |      Type      | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+----------------+-----------+----------+---------+----------+--------------+-------------
 f1     | integer        |           |          |         | plain    |              | 
 f2     | character(100) |           |          |         | extended |              | 

\d+x
List of relations
-[ RECORD 1 ]---------------------
Schema      | tableam_display
Name        | mat_view_heap_psql
Type        | materialized view
Owner       | regress_display_role
Persistence | permanent
Size        | 0 bytes
Description | 
-[ RECORD 2 ]---------------------
Schema      | tableam_display
Name        | tbl_heap
Type        | table
Owner       | regress_display_role
Persistence | permanent
Size        | 0 bytes
Description | 
-[ RECORD 3 ]---------------------
Schema      | tableam_display
Name        | tbl_heap_psql
Type        | table
Owner       | regress_display_role
Persistence | permanent
Size        | 0 bytes
Description | 
-[ RECORD 4 ]---------------------
Schema      | tableam_display
Name        | view_heap_psql
Type        | view
Owner       | regress_display_role
Persistence | permanent
Size        | 0 bytes
Description | 

RESET ROLE;
RESET search_path;
DROP SCHEMA tableam_display CASCADE;
NOTICE:  drop cascades to 4 other objects
DETAIL:  drop cascades to table tableam_display.tbl_heap_psql
drop cascades to table tableam_display.tbl_heap
drop cascades to view tableam_display.view_heap_psql
drop cascades to materialized view tableam_display.mat_view_heap_psql
DROP ACCESS METHOD heap_psql;
DROP ROLE regress_display_role;
-- test numericlocale (as best we can without control of psql's locale)
\pset format aligned
\pset expanded off
\pset numericlocale true
select n, -n as m, n * 111 as x, '1e90'::float8 as f
from generate_series(0,3) n;
 n | m  |  x  |   f   
---+----+-----+-------
 0 |  0 |   0 | 1e+90
 1 | -1 | 111 | 1e+90
 2 | -2 | 222 | 1e+90
 3 | -3 | 333 | 1e+90
(4 rows)

\pset numericlocale false
-- test asciidoc output format
\pset format asciidoc
\pset border 1
\pset expanded off
\d psql_serial_tab_id_seq

.Sequence "public.psql_serial_tab_id_seq"
[options="header",cols="<l,>l,>l,>l,>l,<l,>l",frame="none"]
|====
^l|Type ^l|Start ^l|Minimum ^l|Maximum ^l|Increment ^l|Cycles? ^l|Cache
|integer |1 |1 |2147483647 |1 |no |1
|====

....
Owned by: public.psql_serial_tab.id
....
\pset tuples_only true
\df exp

[cols="<l,<l,<l,<l,<l",frame="none"]
|====
|pg_catalog |exp |double precision |double precision |func
|pg_catalog |exp |numeric |numeric |func
|====
\pset tuples_only false
\pset expanded on
\d psql_serial_tab_id_seq

.Sequence "public.psql_serial_tab_id_seq"
[cols="h,l",frame="none"]
|====
2+^|Record 1
<l|Type <l|integer
<l|Start >l|1
<l|Minimum >l|1
<l|Maximum >l|2147483647
<l|Increment >l|1
<l|Cycles? <l|no
<l|Cache >l|1
|====

....
Owned by: public.psql_serial_tab.id
....
\pset tuples_only true
\df exp

[cols="h,l",frame="none"]
|====
2+|
<l|Schema <l|pg_catalog
<l|Name <l|exp
<l|Result data type <l|double precision
<l|Argument data types <l|double precision
<l|Type <l|func
2+|
<l|Schema <l|pg_catalog
<l|Name <l|exp
<l|Result data type <l|numeric
<l|Argument data types <l|numeric
<l|Type <l|func
|====
\pset tuples_only false
prepare q as
  select 'some|text' as "a|title", '        ' as "empty ", n as int
  from generate_series(1,2) as n;
\pset expanded off
\pset border 0
execute q;

[options="header",cols="<l,<l,>l",frame="none",grid="none"]
|====
^l|a\|title ^l|empty  ^l|int
|some\|text |  |1
|some\|text |  |2
|====

....
(2 rows)
....
\pset border 1
execute q;

[options="header",cols="<l,<l,>l",frame="none"]
|====
^l|a\|title ^l|empty  ^l|int
|some\|text |  |1
|some\|text |  |2
|====

....
(2 rows)
....
\pset border 2
execute q;

[options="header",cols="<l,<l,>l",frame="all",grid="all"]
|====
^l|a\|title ^l|empty  ^l|int
|some\|text |  |1
|some\|text |  |2
|====

....
(2 rows)
....
\pset expanded on
\pset border 0
execute q;

[cols="h,l",frame="none",grid="none"]
|====
2+^|Record 1
<l|a\|title <l|some\|text
<l|empty  <l| 
<l|int >l|1
2+^|Record 2
<l|a\|title <l|some\|text
<l|empty  <l| 
<l|int >l|2
|====
\pset border 1
execute q;

[cols="h,l",frame="none"]
|====
2+^|Record 1
<l|a\|title <l|some\|text
<l|empty  <l| 
<l|int >l|1
2+^|Record 2
<l|a\|title <l|some\|text
<l|empty  <l| 
<l|int >l|2
|====
\pset border 2
execute q;

[cols="h,l",frame="all",grid="all"]
|====
2+^|Record 1
<l|a\|title <l|some\|text
<l|empty  <l| 
<l|int >l|1
2+^|Record 2
<l|a\|title <l|some\|text
<l|empty  <l| 
<l|int >l|2
|====
deallocate q;
-- test csv output format
\pset format csv
\pset border 1
\pset expanded off
\d psql_serial_tab_id_seq
Type,Start,Minimum,Maximum,Increment,Cycles?,Cache
integer,1,1,2147483647,1,no,1
\pset tuples_only true
\df exp
pg_catalog,exp,double precision,double precision,func
pg_catalog,exp,numeric,numeric,func
\pset tuples_only false
\pset expanded on
\d psql_serial_tab_id_seq
Type,integer
Start,1
Minimum,1
Maximum,2147483647
Increment,1
Cycles?,no
Cache,1
\pset tuples_only true
\df exp
Schema,pg_catalog
Name,exp
Result data type,double precision
Argument data types,double precision
Type,func
Schema,pg_catalog
Name,exp
Result data type,numeric
Argument data types,numeric
Type,func
\pset tuples_only false
prepare q as
  select 'some"text' as "a""title", E'  <foo>\n<bar>' as "junk",
         '   ' as "empty", n as int
  from generate_series(1,2) as n;
\pset expanded off
execute q;
"a""title",junk,empty,int
"some""text","  <foo>
<bar>",   ,1
"some""text","  <foo>
<bar>",   ,2
\pset expanded on
execute q;
"a""title","some""text"
junk,"  <foo>
<bar>"
empty,   
int,1
"a""title","some""text"
junk,"  <foo>
<bar>"
empty,   
int,2
deallocate q;
-- special cases
\pset expanded off
select 'comma,comma' as comma, 'semi;semi' as semi;
comma,semi
"comma,comma",semi;semi
\pset csv_fieldsep ';'
select 'comma,comma' as comma, 'semi;semi' as semi;
comma;semi
comma,comma;"semi;semi"
select '\.' as data;
data
"\."
\pset csv_fieldsep '.'
select '\' as d1, '' as d2;
"d1"."d2"
"\".""
-- illegal csv separators
\pset csv_fieldsep ''
\pset: csv_fieldsep must be a single one-byte character
\pset csv_fieldsep '\0'
\pset: csv_fieldsep must be a single one-byte character
\pset csv_fieldsep '\n'
\pset: csv_fieldsep cannot be a double quote, a newline, or a carriage return
\pset csv_fieldsep '\r'
\pset: csv_fieldsep cannot be a double quote, a newline, or a carriage return
\pset csv_fieldsep '"'
\pset: csv_fieldsep cannot be a double quote, a newline, or a carriage return
\pset csv_fieldsep ',,'
\pset: csv_fieldsep must be a single one-byte character
\pset csv_fieldsep ','
-- test html output format
\pset format html
\pset border 1
\pset expanded off
\d psql_serial_tab_id_seq
<table border="1">
  <caption>Sequence &quot;public.psql_serial_tab_id_seq&quot;</caption>
  <tr>
    <th align="center">Type</th>
    <th align="center">Start</th>
    <th align="center">Minimum</th>
    <th align="center">Maximum</th>
    <th align="center">Increment</th>
    <th align="center">Cycles?</th>
    <th align="center">Cache</th>
  </tr>
  <tr valign="top">
    <td align="left">integer</td>
    <td align="right">1</td>
    <td align="right">1</td>
    <td align="right">2147483647</td>
    <td align="right">1</td>
    <td align="left">no</td>
    <td align="right">1</td>
  </tr>
</table>
<p>Owned by: public.psql_serial_tab.id<br />
</p>
\pset tuples_only true
\df exp
<table border="1">
  <tr valign="top">
    <td align="left">pg_catalog</td>
    <td align="left">exp</td>
    <td align="left">double precision</td>
    <td align="left">double precision</td>
    <td align="left">func</td>
  </tr>
  <tr valign="top">
    <td align="left">pg_catalog</td>
    <td align="left">exp</td>
    <td align="left">numeric</td>
    <td align="left">numeric</td>
    <td align="left">func</td>
  </tr>
</table>

\pset tuples_only false
\pset expanded on
\d psql_serial_tab_id_seq
<table border="1">
  <caption>Sequence &quot;public.psql_serial_tab_id_seq&quot;</caption>

  <tr><td colspan="2" align="center">Record 1</td></tr>
  <tr valign="top">
    <th>Type</th>
    <td align="left">integer</td>
  </tr>
  <tr valign="top">
    <th>Start</th>
    <td align="right">1</td>
  </tr>
  <tr valign="top">
    <th>Minimum</th>
    <td align="right">1</td>
  </tr>
  <tr valign="top">
    <th>Maximum</th>
    <td align="right">2147483647</td>
  </tr>
  <tr valign="top">
    <th>Increment</th>
    <td align="right">1</td>
  </tr>
  <tr valign="top">
    <th>Cycles?</th>
    <td align="left">no</td>
  </tr>
  <tr valign="top">
    <th>Cache</th>
    <td align="right">1</td>
  </tr>
</table>
<p>Owned by: public.psql_serial_tab.id<br />
</p>
\pset tuples_only true
\df exp
<table border="1">

  <tr><td colspan="2">&nbsp;</td></tr>
  <tr valign="top">
    <th>Schema</th>
    <td align="left">pg_catalog</td>
  </tr>
  <tr valign="top">
    <th>Name</th>
    <td align="left">exp</td>
  </tr>
  <tr valign="top">
    <th>Result data type</th>
    <td align="left">double precision</td>
  </tr>
  <tr valign="top">
    <th>Argument data types</th>
    <td align="left">double precision</td>
  </tr>
  <tr valign="top">
    <th>Type</th>
    <td align="left">func</td>
  </tr>

  <tr><td colspan="2">&nbsp;</td></tr>
  <tr valign="top">
    <th>Schema</th>
    <td align="left">pg_catalog</td>
  </tr>
  <tr valign="top">
    <th>Name</th>
    <td align="left">exp</td>
  </tr>
  <tr valign="top">
    <th>Result data type</th>
    <td align="left">numeric</td>
  </tr>
  <tr valign="top">
    <th>Argument data types</th>
    <td align="left">numeric</td>
  </tr>
  <tr valign="top">
    <th>Type</th>
    <td align="left">func</td>
  </tr>
</table>

\pset tuples_only false
prepare q as
  select 'some"text' as "a&title", E'  <foo>\n<bar>' as "junk",
         '   ' as "empty", n as int
  from generate_series(1,2) as n;
\pset expanded off
\pset border 0
execute q;
<table border="0">
  <tr>
    <th align="center">a&amp;title</th>
    <th align="center">junk</th>
    <th align="center">empty</th>
    <th align="center">int</th>
  </tr>
  <tr valign="top">
    <td align="left">some&quot;text</td>
    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
&lt;bar&gt;</td>
    <td align="left">&nbsp; </td>
    <td align="right">1</td>
  </tr>
  <tr valign="top">
    <td align="left">some&quot;text</td>
    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
&lt;bar&gt;</td>
    <td align="left">&nbsp; </td>
    <td align="right">2</td>
  </tr>
</table>
<p>(2 rows)<br />
</p>
\pset border 1
execute q;
<table border="1">
  <tr>
    <th align="center">a&amp;title</th>
    <th align="center">junk</th>
    <th align="center">empty</th>
    <th align="center">int</th>
  </tr>
  <tr valign="top">
    <td align="left">some&quot;text</td>
    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
&lt;bar&gt;</td>
    <td align="left">&nbsp; </td>
    <td align="right">1</td>
  </tr>
  <tr valign="top">
    <td align="left">some&quot;text</td>
    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
&lt;bar&gt;</td>
    <td align="left">&nbsp; </td>
    <td align="right">2</td>
  </tr>
</table>
<p>(2 rows)<br />
</p>
\pset tableattr foobar
execute q;
<table border="1" foobar>
  <tr>
    <th align="center">a&amp;title</th>
    <th align="center">junk</th>
    <th align="center">empty</th>
    <th align="center">int</th>
  </tr>
  <tr valign="top">
    <td align="left">some&quot;text</td>
    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
&lt;bar&gt;</td>
    <td align="left">&nbsp; </td>
    <td align="right">1</td>
  </tr>
  <tr valign="top">
    <td align="left">some&quot;text</td>
    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
&lt;bar&gt;</td>
    <td align="left">&nbsp; </td>
    <td align="right">2</td>
  </tr>
</table>
<p>(2 rows)<br />
</p>
\pset tableattr
\pset expanded on
\pset border 0
execute q;
<table border="0">

  <tr><td colspan="2" align="center">Record 1</td></tr>
  <tr valign="top">
    <th>a&amp;title</th>
    <td align="left">some&quot;text</td>
  </tr>
  <tr valign="top">
    <th>junk</th>
    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
&lt;bar&gt;</td>
  </tr>
  <tr valign="top">
    <th>empty</th>
    <td align="left">&nbsp; </td>
  </tr>
  <tr valign="top">
    <th>int</th>
    <td align="right">1</td>
  </tr>

  <tr><td colspan="2" align="center">Record 2</td></tr>
  <tr valign="top">
    <th>a&amp;title</th>
    <td align="left">some&quot;text</td>
  </tr>
  <tr valign="top">
    <th>junk</th>
    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
&lt;bar&gt;</td>
  </tr>
  <tr valign="top">
    <th>empty</th>
    <td align="left">&nbsp; </td>
  </tr>
  <tr valign="top">
    <th>int</th>
    <td align="right">2</td>
  </tr>
</table>

\pset border 1
execute q;
<table border="1">

  <tr><td colspan="2" align="center">Record 1</td></tr>
  <tr valign="top">
    <th>a&amp;title</th>
    <td align="left">some&quot;text</td>
  </tr>
  <tr valign="top">
    <th>junk</th>
    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
&lt;bar&gt;</td>
  </tr>
  <tr valign="top">
    <th>empty</th>
    <td align="left">&nbsp; </td>
  </tr>
  <tr valign="top">
    <th>int</th>
    <td align="right">1</td>
  </tr>

  <tr><td colspan="2" align="center">Record 2</td></tr>
  <tr valign="top">
    <th>a&amp;title</th>
    <td align="left">some&quot;text</td>
  </tr>
  <tr valign="top">
    <th>junk</th>
    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
&lt;bar&gt;</td>
  </tr>
  <tr valign="top">
    <th>empty</th>
    <td align="left">&nbsp; </td>
  </tr>
  <tr valign="top">
    <th>int</th>
    <td align="right">2</td>
  </tr>
</table>

\pset tableattr foobar
execute q;
<table border="1" foobar>

  <tr><td colspan="2" align="center">Record 1</td></tr>
  <tr valign="top">
    <th>a&amp;title</th>
    <td align="left">some&quot;text</td>
  </tr>
  <tr valign="top">
    <th>junk</th>
    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
&lt;bar&gt;</td>
  </tr>
  <tr valign="top">
    <th>empty</th>
    <td align="left">&nbsp; </td>
  </tr>
  <tr valign="top">
    <th>int</th>
    <td align="right">1</td>
  </tr>

  <tr><td colspan="2" align="center">Record 2</td></tr>
  <tr valign="top">
    <th>a&amp;title</th>
    <td align="left">some&quot;text</td>
  </tr>
  <tr valign="top">
    <th>junk</th>
    <td align="left">&nbsp;&nbsp;&lt;foo&gt;<br />
&lt;bar&gt;</td>
  </tr>
  <tr valign="top">
    <th>empty</th>
    <td align="left">&nbsp; </td>
  </tr>
  <tr valign="top">
    <th>int</th>
    <td align="right">2</td>
  </tr>
</table>

\pset tableattr
deallocate q;
-- test latex output format
\pset format latex
\pset border 1
\pset expanded off
\d psql_serial_tab_id_seq
\begin{center}
Sequence "public.psql\_serial\_tab\_id\_seq"
\end{center}

\begin{tabular}{l | r | r | r | r | l | r}
\textit{Type} & \textit{Start} & \textit{Minimum} & \textit{Maximum} & \textit{Increment} & \textit{Cycles?} & \textit{Cache} \\
\hline
integer & 1 & 1 & 2147483647 & 1 & no & 1 \\
\end{tabular}

\noindent Owned by: public.psql\_serial\_tab.id \\

\pset tuples_only true
\df exp
\begin{tabular}{l | l | l | l | l}
pg\_catalog & exp & double precision & double precision & func \\
pg\_catalog & exp & numeric & numeric & func \\
\end{tabular}

\noindent 
\pset tuples_only false
\pset expanded on
\d psql_serial_tab_id_seq
\begin{center}
Sequence "public.psql\_serial\_tab\_id\_seq"
\end{center}

\begin{tabular}{c|l}
\multicolumn{2}{c}{\textit{Record 1}} \\
\hline
Type & integer \\
Start & 1 \\
Minimum & 1 \\
Maximum & 2147483647 \\
Increment & 1 \\
Cycles? & no \\
Cache & 1 \\
\end{tabular}

\noindent Owned by: public.psql\_serial\_tab.id \\

\pset tuples_only true
\df exp
\begin{tabular}{c|l}
\hline
Schema & pg\_catalog \\
Name & exp \\
Result data type & double precision \\
Argument data types & double precision \\
Type & func \\
\hline
Schema & pg\_catalog \\
Name & exp \\
Result data type & numeric \\
Argument data types & numeric \\
Type & func \\
\end{tabular}

\noindent 
\pset tuples_only false
prepare q as
  select 'some\more_text' as "a$title", E'  #<foo>%&^~|\n{bar}' as "junk",
         '   ' as "empty", n as int
  from generate_series(1,2) as n;
\pset expanded off
\pset border 0
execute q;
\begin{tabular}{lllr}
\textit{a\$title} & \textit{junk} & \textit{empty} & \textit{int} \\
\hline
some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 1 \\
some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 2 \\
\end{tabular}

\noindent (2 rows) \\

\pset border 1
execute q;
\begin{tabular}{l | l | l | r}
\textit{a\$title} & \textit{junk} & \textit{empty} & \textit{int} \\
\hline
some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 1 \\
some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 2 \\
\end{tabular}

\noindent (2 rows) \\

\pset border 2
execute q;
\begin{tabular}{| l | l | l | r |}
\hline
\textit{a\$title} & \textit{junk} & \textit{empty} & \textit{int} \\
\hline
some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 1 \\
some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 2 \\
\hline
\end{tabular}

\noindent (2 rows) \\

\pset border 3
execute q;
\begin{tabular}{| l | l | l | r |}
\hline
\textit{a\$title} & \textit{junk} & \textit{empty} & \textit{int} \\
\hline
some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 1 \\
\hline
some\textbackslash{}more\_text &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} &     & 2 \\
\hline
\end{tabular}

\noindent (2 rows) \\

\pset expanded on
\pset border 0
execute q;
\begin{tabular}{cl}
\multicolumn{2}{c}{\textit{Record 1}} \\
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 1 \\
\multicolumn{2}{c}{\textit{Record 2}} \\
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 2 \\
\end{tabular}

\noindent 
\pset border 1
execute q;
\begin{tabular}{c|l}
\multicolumn{2}{c}{\textit{Record 1}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 1 \\
\multicolumn{2}{c}{\textit{Record 2}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 2 \\
\end{tabular}

\noindent 
\pset border 2
execute q;
\begin{tabular}{|c|l|}
\hline
\multicolumn{2}{|c|}{\textit{Record 1}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 1 \\
\hline
\multicolumn{2}{|c|}{\textit{Record 2}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 2 \\
\hline
\end{tabular}

\noindent 
\pset border 3
execute q;
\begin{tabular}{|c|l|}
\hline
\multicolumn{2}{|c|}{\textit{Record 1}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 1 \\
\hline
\multicolumn{2}{|c|}{\textit{Record 2}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 2 \\
\hline
\end{tabular}

\noindent 
deallocate q;
-- test latex-longtable output format
\pset format latex-longtable
\pset border 1
\pset expanded off
\d psql_serial_tab_id_seq
\begin{longtable}{l | r | r | r | r | l | r}
\small\textbf{\textit{Type}} & \small\textbf{\textit{Start}} & \small\textbf{\textit{Minimum}} & \small\textbf{\textit{Maximum}} & \small\textbf{\textit{Increment}} & \small\textbf{\textit{Cycles?}} & \small\textbf{\textit{Cache}} \\
\midrule
\endfirsthead
\small\textbf{\textit{Type}} & \small\textbf{\textit{Start}} & \small\textbf{\textit{Minimum}} & \small\textbf{\textit{Maximum}} & \small\textbf{\textit{Increment}} & \small\textbf{\textit{Cycles?}} & \small\textbf{\textit{Cache}} \\
\midrule
\endhead
\caption[Sequence "public.psql\_serial\_tab\_id\_seq" (Continued)]{Sequence "public.psql\_serial\_tab\_id\_seq"}
\endfoot
\caption[Sequence "public.psql\_serial\_tab\_id\_seq"]{Sequence "public.psql\_serial\_tab\_id\_seq"}
\endlastfoot
\raggedright{integer}
&
\raggedright{1}
&
\raggedright{1}
&
\raggedright{2147483647}
&
\raggedright{1}
&
\raggedright{no}
&
\raggedright{1} \tabularnewline
\end{longtable}
\pset tuples_only true
\df exp
\begin{longtable}{l | l | l | l | l}
\raggedright{pg\_catalog}
&
\raggedright{exp}
&
\raggedright{double precision}
&
\raggedright{double precision}
&
\raggedright{func} \tabularnewline
\raggedright{pg\_catalog}
&
\raggedright{exp}
&
\raggedright{numeric}
&
\raggedright{numeric}
&
\raggedright{func} \tabularnewline
\end{longtable}
\pset tuples_only false
\pset expanded on
\d psql_serial_tab_id_seq
\begin{center}
Sequence "public.psql\_serial\_tab\_id\_seq"
\end{center}

\begin{tabular}{c|l}
\multicolumn{2}{c}{\textit{Record 1}} \\
\hline
Type & integer \\
Start & 1 \\
Minimum & 1 \\
Maximum & 2147483647 \\
Increment & 1 \\
Cycles? & no \\
Cache & 1 \\
\end{tabular}

\noindent Owned by: public.psql\_serial\_tab.id \\

\pset tuples_only true
\df exp
\begin{tabular}{c|l}
\hline
Schema & pg\_catalog \\
Name & exp \\
Result data type & double precision \\
Argument data types & double precision \\
Type & func \\
\hline
Schema & pg\_catalog \\
Name & exp \\
Result data type & numeric \\
Argument data types & numeric \\
Type & func \\
\end{tabular}

\noindent 
\pset tuples_only false
prepare q as
  select 'some\more_text' as "a$title", E'  #<foo>%&^~|\n{bar}' as "junk",
         '   ' as "empty", n as int
  from generate_series(1,2) as n;
\pset expanded off
\pset border 0
execute q;
\begin{longtable}{lllr}
\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
\midrule
\endfirsthead
\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
\midrule
\endhead
\raggedright{some\textbackslash{}more\_text}
&
\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
&
\raggedright{   }
&
\raggedright{1} \tabularnewline
\raggedright{some\textbackslash{}more\_text}
&
\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
&
\raggedright{   }
&
\raggedright{2} \tabularnewline
\end{longtable}
\pset border 1
execute q;
\begin{longtable}{l | l | l | r}
\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
\midrule
\endfirsthead
\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
\midrule
\endhead
\raggedright{some\textbackslash{}more\_text}
&
\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
&
\raggedright{   }
&
\raggedright{1} \tabularnewline
\raggedright{some\textbackslash{}more\_text}
&
\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
&
\raggedright{   }
&
\raggedright{2} \tabularnewline
\end{longtable}
\pset border 2
execute q;
\begin{longtable}{| l | l | l | r |}
\toprule
\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
\midrule
\endfirsthead
\toprule
\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
\midrule
\endhead
\bottomrule
\endfoot
\bottomrule
\endlastfoot
\raggedright{some\textbackslash{}more\_text}
&
\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
&
\raggedright{   }
&
\raggedright{1} \tabularnewline
\raggedright{some\textbackslash{}more\_text}
&
\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
&
\raggedright{   }
&
\raggedright{2} \tabularnewline
\end{longtable}
\pset border 3
execute q;
\begin{longtable}{| l | l | l | r |}
\toprule
\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
\midrule
\endfirsthead
\toprule
\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
\endhead
\bottomrule
\endfoot
\bottomrule
\endlastfoot
\raggedright{some\textbackslash{}more\_text}
&
\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
&
\raggedright{   }
&
\raggedright{1} \tabularnewline
 \hline
\raggedright{some\textbackslash{}more\_text}
&
\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
&
\raggedright{   }
&
\raggedright{2} \tabularnewline
 \hline
\end{longtable}
\pset tableattr lr
execute q;
\begin{longtable}{| p{lr\textwidth} | p{lr\textwidth} | p{lr\textwidth} | r |}
\toprule
\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
\midrule
\endfirsthead
\toprule
\small\textbf{\textit{a\$title}} & \small\textbf{\textit{junk}} & \small\textbf{\textit{empty}} & \small\textbf{\textit{int}} \\
\endhead
\bottomrule
\endfoot
\bottomrule
\endlastfoot
\raggedright{some\textbackslash{}more\_text}
&
\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
&
\raggedright{   }
&
\raggedright{1} \tabularnewline
 \hline
\raggedright{some\textbackslash{}more\_text}
&
\raggedright{  \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\}}
&
\raggedright{   }
&
\raggedright{2} \tabularnewline
 \hline
\end{longtable}
\pset tableattr
\pset expanded on
\pset border 0
execute q;
\begin{tabular}{cl}
\multicolumn{2}{c}{\textit{Record 1}} \\
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 1 \\
\multicolumn{2}{c}{\textit{Record 2}} \\
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 2 \\
\end{tabular}

\noindent 
\pset border 1
execute q;
\begin{tabular}{c|l}
\multicolumn{2}{c}{\textit{Record 1}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 1 \\
\multicolumn{2}{c}{\textit{Record 2}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 2 \\
\end{tabular}

\noindent 
\pset border 2
execute q;
\begin{tabular}{|c|l|}
\hline
\multicolumn{2}{|c|}{\textit{Record 1}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 1 \\
\hline
\multicolumn{2}{|c|}{\textit{Record 2}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 2 \\
\hline
\end{tabular}

\noindent 
\pset border 3
execute q;
\begin{tabular}{|c|l|}
\hline
\multicolumn{2}{|c|}{\textit{Record 1}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 1 \\
\hline
\multicolumn{2}{|c|}{\textit{Record 2}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 2 \\
\hline
\end{tabular}

\noindent 
\pset tableattr lr
execute q;
\begin{tabular}{|c|l|}
\hline
\multicolumn{2}{|c|}{\textit{Record 1}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 1 \\
\hline
\multicolumn{2}{|c|}{\textit{Record 2}} \\
\hline
a\$title & some\textbackslash{}more\_text \\
junk &   \#\textless{}foo\textgreater{}\%\&\^{}\~{}\textbar{}\\\{bar\} \\
empty &     \\
int & 2 \\
\hline
\end{tabular}

\noindent 
\pset tableattr
deallocate q;
-- test troff-ms output format
\pset format troff-ms
\pset border 1
\pset expanded off
\d psql_serial_tab_id_seq
.LP
.DS C
Sequence "public.psql_serial_tab_id_seq"
.DE
.LP
.TS
center;
l | r | r | r | r | l | r.
\fIType\fP	\fIStart\fP	\fIMinimum\fP	\fIMaximum\fP	\fIIncrement\fP	\fICycles?\fP	\fICache\fP
_
integer	1	1	2147483647	1	no	1
.TE
.DS L
Owned by: public.psql_serial_tab.id
.DE
\pset tuples_only true
\df exp
.LP
.TS
center;
l | l | l | l | l.
pg_catalog	exp	double precision	double precision	func
pg_catalog	exp	numeric	numeric	func
.TE
.DS L
.DE
\pset tuples_only false
\pset expanded on
\d psql_serial_tab_id_seq
.LP
.DS C
Sequence "public.psql_serial_tab_id_seq"
.DE
.LP
.TS
center;
c s.
\fIRecord 1\fP
_
.T&
c | l.
Type	integer
Start	1
Minimum	1
Maximum	2147483647
Increment	1
Cycles?	no
Cache	1
.TE
.DS L
Owned by: public.psql_serial_tab.id
.DE
\pset tuples_only true
\df exp
.LP
.TS
center;
c l;
_
Schema	pg_catalog
Name	exp
Result data type	double precision
Argument data types	double precision
Type	func
_
Schema	pg_catalog
Name	exp
Result data type	numeric
Argument data types	numeric
Type	func
.TE
.DS L
.DE
\pset tuples_only false
prepare q as
  select 'some\text' as "a\title", E'  <foo>\n<bar>' as "junk",
         '   ' as "empty", n as int
  from generate_series(1,2) as n;
\pset expanded off
\pset border 0
execute q;
.LP
.TS
center;
lllr.
\fIa\(rstitle\fP	\fIjunk\fP	\fIempty\fP	\fIint\fP
_
some\(rstext	  <foo>
<bar>	   	1
some\(rstext	  <foo>
<bar>	   	2
.TE
.DS L
(2 rows)
.DE
\pset border 1
execute q;
.LP
.TS
center;
l | l | l | r.
\fIa\(rstitle\fP	\fIjunk\fP	\fIempty\fP	\fIint\fP
_
some\(rstext	  <foo>
<bar>	   	1
some\(rstext	  <foo>
<bar>	   	2
.TE
.DS L
(2 rows)
.DE
\pset border 2
execute q;
.LP
.TS
center box;
l | l | l | r.
\fIa\(rstitle\fP	\fIjunk\fP	\fIempty\fP	\fIint\fP
_
some\(rstext	  <foo>
<bar>	   	1
some\(rstext	  <foo>
<bar>	   	2
.TE
.DS L
(2 rows)
.DE
\pset expanded on
\pset border 0
execute q;
.LP
.TS
center;
c s.
\fIRecord 1\fP
.T&
c l.
a\(rstitle	some\(rstext
junk	  <foo>
<bar>
empty	   
int	1
.T&
c s.
\fIRecord 2\fP
.T&
c l.
a\(rstitle	some\(rstext
junk	  <foo>
<bar>
empty	   
int	2
.TE
.DS L
.DE
\pset border 1
execute q;
.LP
.TS
center;
c s.
\fIRecord 1\fP
_
.T&
c | l.
a\(rstitle	some\(rstext
junk	  <foo>
<bar>
empty	   
int	1
.T&
c s.
\fIRecord 2\fP
_
.T&
c | l.
a\(rstitle	some\(rstext
junk	  <foo>
<bar>
empty	   
int	2
.TE
.DS L
.DE
\pset border 2
execute q;
.LP
.TS
center box;
c s.
\fIRecord 1\fP
_
.T&
c l.
a\(rstitle	some\(rstext
junk	  <foo>
<bar>
empty	   
int	1
_
.T&
c s.
\fIRecord 2\fP
_
.T&
c l.
a\(rstitle	some\(rstext
junk	  <foo>
<bar>
empty	   
int	2
.TE
.DS L
.DE
deallocate q;
-- check ambiguous format requests
\pset format a
\pset: ambiguous abbreviation "a" matches both "aligned" and "asciidoc"
\pset format l
-- clean up after output format tests
drop table psql_serial_tab;
\pset format aligned
\pset expanded off
\pset border 1
-- \echo and allied features
\echo this is a test
this is a test
\echo -n without newline
without newline\echo with -n newline
with -n newline
\echo '-n' with newline
-n with newline
\set foo bar
\echo foo = :foo
foo = bar
\qecho this is a test
this is a test
\qecho foo = :foo
foo = bar
\warn this is a test
this is a test
\warn foo = :foo
foo = bar
-- tests for \if ... \endif
\if true
  select 'okay';
 ?column? 
----------
 okay
(1 row)

  select 'still okay';
  ?column?  
------------
 still okay
(1 row)

\else
  not okay;
  still not okay
\endif
-- at this point query buffer should still have last valid line
\g
  ?column?  
------------
 still okay
(1 row)

-- \if should work okay on part of a query
select
  \if true
    42
  \else
    (bogus
  \endif
  forty_two;
 forty_two 
-----------
        42
(1 row)

select \if false \\ (bogus \else \\ 42 \endif \\ forty_two;
 forty_two 
-----------
        42
(1 row)

-- test a large nested if using a variety of true-equivalents
\if true
	\if 1
		\if yes
			\if on
				\echo 'all true'
all true
			\else
				\echo 'should not print #1-1'
			\endif
		\else
			\echo 'should not print #1-2'
		\endif
	\else
		\echo 'should not print #1-3'
	\endif
\else
	\echo 'should not print #1-4'
\endif
-- test a variety of false-equivalents in an if/elif/else structure
\if false
	\echo 'should not print #2-1'
\elif 0
	\echo 'should not print #2-2'
\elif no
	\echo 'should not print #2-3'
\elif off
	\echo 'should not print #2-4'
\else
	\echo 'all false'
all false
\endif
-- test true-false elif after initial true branch
\if true
	\echo 'should print #2-5'
should print #2-5
\elif true
	\echo 'should not print #2-6'
\elif false
	\echo 'should not print #2-7'
\else
	\echo 'should not print #2-8'
\endif
-- test simple true-then-else
\if true
	\echo 'first thing true'
first thing true
\else
	\echo 'should not print #3-1'
\endif
-- test simple false-true-else
\if false
	\echo 'should not print #4-1'
\elif true
	\echo 'second thing true'
second thing true
\else
	\echo 'should not print #5-1'
\endif
-- invalid boolean expressions are false
\if invalid boolean expression
unrecognized value "invalid boolean expression" for "\if expression": Boolean expected
	\echo 'will not print #6-1'
\else
	\echo 'will print anyway #6-2'
will print anyway #6-2
\endif
-- test un-matched endif
\endif
\endif: no matching \if
-- test un-matched else
\else
\else: no matching \if
-- test un-matched elif
\elif
\elif: no matching \if
-- test double-else error
\if true
\else
\else
\else: cannot occur after \else
\endif
-- test elif out-of-order
\if false
\else
\elif
\elif: cannot occur after \else
\endif
-- test if-endif matching in a false branch
\if false
    \if false
        \echo 'should not print #7-1'
    \else
        \echo 'should not print #7-2'
    \endif
    \echo 'should not print #7-3'
\else
    \echo 'should print #7-4'
should print #7-4
\endif
-- show that vars and backticks are not expanded when ignoring extra args
\set foo bar
\echo :foo :'foo' :"foo"
bar 'bar' "bar"
\pset fieldsep | `nosuchcommand` :foo :'foo' :"foo"
\pset: extra argument "nosuchcommand" ignored
\pset: extra argument ":foo" ignored
\pset: extra argument ":'foo'" ignored
\pset: extra argument ":"foo"" ignored
-- show that vars and backticks are not expanded and commands are ignored
-- when in a false if-branch
\set try_to_quit '\\q'
\if false
	:try_to_quit
	\echo `nosuchcommand` :foo :'foo' :"foo"
	\pset fieldsep | `nosuchcommand` :foo :'foo' :"foo"
	\a
	SELECT $1 \bind 1 \g
	\bind_named stmt1 1 2 \g
	\C arg1
	\c arg1 arg2 arg3 arg4
	\cd arg1
	\close stmt1
	\conninfo
	\copy arg1 arg2 arg3 arg4 arg5 arg6
	\copyright
	SELECT 1 as one, 2, 3 \crosstabview
	\dt arg1
	\e arg1 arg2
	\ef whole_line
	\ev whole_line
	\echo arg1 arg2 arg3 arg4 arg5
	\echo arg1
	\encoding arg1
	\endpipeline
	\errverbose
	\f arg1
	\flush
	\flushrequest
	\g arg1
	\gx arg1
	\gexec
	\getresults
	SELECT 1 AS one \gset
	\h
	\?
	\html
	\i arg1
	\ir arg1
	\l arg1
	\lo arg1 arg2
invalid command \lo
	\lo_list
	\o arg1
	\p
	SELECT 1 \parse
	\password arg1
	\prompt arg1 arg2
	\pset arg1 arg2
	\q
	\reset
	\s arg1
	\set arg1 arg2 arg3 arg4 arg5 arg6 arg7
	\setenv arg1 arg2
	\sf whole_line
	\sv whole_line
	\startpipeline
	\syncpipeline
	\t arg1
	\T arg1
	\timing arg1
	\unset arg1
	\w arg1
	\watch arg1 arg2
	\x arg1
	-- \else here is eaten as part of OT_FILEPIPE argument
	\w |/no/such/file \else
	-- \endif here is eaten as part of whole-line argument
	\! whole_line \endif
	\z
\else
	\echo 'should print #8-1'
should print #8-1
\endif
-- :{?...} defined variable test
\set i 1
\if :{?i}
  \echo '#9-1 ok, variable i is defined'
#9-1 ok, variable i is defined
\else
  \echo 'should not print #9-2'
\endif
\if :{?no_such_variable}
  \echo 'should not print #10-1'
\else
  \echo '#10-2 ok, variable no_such_variable is not defined'
#10-2 ok, variable no_such_variable is not defined
\endif
SELECT :{?i} AS i_is_defined;
 i_is_defined 
--------------
 t
(1 row)

SELECT NOT :{?no_such_var} AS no_such_var_is_not_defined;
 no_such_var_is_not_defined 
----------------------------
 t
(1 row)

-- SHOW_CONTEXT
\set SHOW_CONTEXT never
do $$
begin
  raise notice 'foo';
  raise exception 'bar';
end $$;
NOTICE:  foo
ERROR:  bar
\set SHOW_CONTEXT errors
do $$
begin
  raise notice 'foo';
  raise exception 'bar';
end $$;
NOTICE:  foo
ERROR:  bar
CONTEXT:  PL/pgSQL function inline_code_block line 4 at RAISE
\set SHOW_CONTEXT always
do $$
begin
  raise notice 'foo';
  raise exception 'bar';
end $$;
NOTICE:  foo
CONTEXT:  PL/pgSQL function inline_code_block line 3 at RAISE
ERROR:  bar
CONTEXT:  PL/pgSQL function inline_code_block line 4 at RAISE
-- test printing and clearing the query buffer
SELECT 1;
 ?column? 
----------
        1
(1 row)

\p
SELECT 1;
SELECT 2 \r
\p
SELECT 1;
SELECT 3 \p
SELECT 3 
UNION SELECT 4 \p
SELECT 3 
UNION SELECT 4 
UNION SELECT 5
ORDER BY 1;
 ?column? 
----------
        3
        4
        5
(3 rows)

\r
\p
SELECT 3 
UNION SELECT 4 
UNION SELECT 5
ORDER BY 1;
-- tests for special result variables
-- working query, 2 rows selected
SELECT 1 AS stuff UNION SELECT 2;
 stuff 
-------
     1
     2
(2 rows)

\echo 'error:' :ERROR
error: false
\echo 'error code:' :SQLSTATE
error code: 00000
\echo 'number of rows:' :ROW_COUNT
number of rows: 2
-- syntax error
SELECT 1 UNION;
ERROR:  syntax error at or near ";"
LINE 1: SELECT 1 UNION;
                      ^
\echo 'error:' :ERROR
error: true
\echo 'error code:' :SQLSTATE
error code: 42601
\echo 'number of rows:' :ROW_COUNT
number of rows: 0
\echo 'last error message:' :LAST_ERROR_MESSAGE
last error message: syntax error at or near ";"
\echo 'last error code:' :LAST_ERROR_SQLSTATE
last error code: 42601
-- empty query
;
\echo 'error:' :ERROR
error: false
\echo 'error code:' :SQLSTATE
error code: 00000
\echo 'number of rows:' :ROW_COUNT
number of rows: 0
-- must have kept previous values
\echo 'last error message:' :LAST_ERROR_MESSAGE
last error message: syntax error at or near ";"
\echo 'last error code:' :LAST_ERROR_SQLSTATE
last error code: 42601
-- other query error
DROP TABLE this_table_does_not_exist;
ERROR:  table "this_table_does_not_exist" does not exist
\echo 'error:' :ERROR
error: true
\echo 'error code:' :SQLSTATE
error code: 42P01
\echo 'number of rows:' :ROW_COUNT
number of rows: 0
\echo 'last error message:' :LAST_ERROR_MESSAGE
last error message: table "this_table_does_not_exist" does not exist
\echo 'last error code:' :LAST_ERROR_SQLSTATE
last error code: 42P01
-- nondefault verbosity error settings (except verbose, which is too unstable)
\set VERBOSITY terse
SELECT 1 UNION;
ERROR:  syntax error at or near ";" at character 15
\echo 'error:' :ERROR
error: true
\echo 'error code:' :SQLSTATE
error code: 42601
\echo 'last error message:' :LAST_ERROR_MESSAGE
last error message: syntax error at or near ";"
\set VERBOSITY sqlstate
SELECT 1/0;
ERROR:  22012
\echo 'error:' :ERROR
error: true
\echo 'error code:' :SQLSTATE
error code: 22012
\echo 'last error message:' :LAST_ERROR_MESSAGE
last error message: division by zero
\set VERBOSITY default
-- working \gdesc
SELECT 3 AS three, 4 AS four \gdesc
 Column |  Type   
--------+---------
 three  | integer
 four   | integer
(2 rows)

\echo 'error:' :ERROR
error: false
\echo 'error code:' :SQLSTATE
error code: 00000
\echo 'number of rows:' :ROW_COUNT
number of rows: 2
-- \gdesc with an error
SELECT 4 AS \gdesc
ERROR:  syntax error at end of input
LINE 1: SELECT 4 AS 
                    ^
\echo 'error:' :ERROR
error: true
\echo 'error code:' :SQLSTATE
error code: 42601
\echo 'number of rows:' :ROW_COUNT
number of rows: 0
\echo 'last error message:' :LAST_ERROR_MESSAGE
last error message: syntax error at end of input
\echo 'last error code:' :LAST_ERROR_SQLSTATE
last error code: 42601
-- check row count for a query with chunked results
\set FETCH_COUNT 10
select unique2 from tenk1 order by unique2 limit 19;
 unique2 
---------
       0
       1
       2
       3
       4
       5
       6
       7
       8
       9
      10
      11
      12
      13
      14
      15
      16
      17
      18
(19 rows)

\echo 'error:' :ERROR
error: false
\echo 'error code:' :SQLSTATE
error code: 00000
\echo 'number of rows:' :ROW_COUNT
number of rows: 19
-- chunked results with an error after the first chunk
-- (we must disable parallel query here, else the behavior is timing-dependent)
set debug_parallel_query = off;
select 1/(15-unique2) from tenk1 order by unique2 limit 19;
 ?column? 
----------
        0
        0
        0
        0
        0
        0
        0
        0
        0
        0
ERROR:  division by zero
\echo 'error:' :ERROR
error: true
\echo 'error code:' :SQLSTATE
error code: 22012
\echo 'number of rows:' :ROW_COUNT
number of rows: 0
\echo 'last error message:' :LAST_ERROR_MESSAGE
last error message: division by zero
\echo 'last error code:' :LAST_ERROR_SQLSTATE
last error code: 22012
reset debug_parallel_query;
\unset FETCH_COUNT
create schema testpart;
create role regress_partitioning_role;
alter schema testpart owner to regress_partitioning_role;
set role to regress_partitioning_role;
-- run test inside own schema and hide other partitions
set search_path to testpart;
create table testtable_apple(logdate date);
create table testtable_orange(logdate date);
create index testtable_apple_index on testtable_apple(logdate);
create index testtable_orange_index on testtable_orange(logdate);
create table testpart_apple(logdate date) partition by range(logdate);
create table testpart_orange(logdate date) partition by range(logdate);
create index testpart_apple_index on testpart_apple(logdate);
create index testpart_orange_index on testpart_orange(logdate);
-- only partition related object should be displayed
\dP test*apple*
                                         List of partitioned relations
  Schema  |         Name         |           Owner           |       Type        | Parent name |     Table      
----------+----------------------+---------------------------+-------------------+-------------+----------------
 testpart | testpart_apple       | regress_partitioning_role | partitioned table |             | 
 testpart | testpart_apple_index | regress_partitioning_role | partitioned index |             | testpart_apple
(2 rows)

\dPt test*apple*
                     List of partitioned tables
  Schema  |      Name      |           Owner           | Parent name 
----------+----------------+---------------------------+-------------
 testpart | testpart_apple | regress_partitioning_role | 
(1 row)

\dPi test*apple*
                                List of partitioned indexes
  Schema  |         Name         |           Owner           | Parent name |     Table      
----------+----------------------+---------------------------+-------------+----------------
 testpart | testpart_apple_index | regress_partitioning_role |             | testpart_apple
(1 row)

drop table testtable_apple;
drop table testtable_orange;
drop table testpart_apple;
drop table testpart_orange;
create table parent_tab (id int) partition by range (id);
create index parent_index on parent_tab (id);
create table child_0_10 partition of parent_tab
  for values from (0) to (10);
create table child_10_20 partition of parent_tab
  for values from (10) to (20);
create table child_20_30 partition of parent_tab
  for values from (20) to (30);
insert into parent_tab values (generate_series(0,29));
create table child_30_40 partition of parent_tab
for values from (30) to (40)
  partition by range(id);
create table child_30_35 partition of child_30_40
  for values from (30) to (35);
create table child_35_40 partition of child_30_40
   for values from (35) to (40);
insert into parent_tab values (generate_series(30,39));
\dPt
            List of partitioned tables
  Schema  |    Name    |           Owner           
----------+------------+---------------------------
 testpart | parent_tab | regress_partitioning_role
(1 row)

\dPi
                   List of partitioned indexes
  Schema  |     Name     |           Owner           |   Table    
----------+--------------+---------------------------+------------
 testpart | parent_index | regress_partitioning_role | parent_tab
(1 row)

\dP testpart.*
                                       List of partitioned relations
  Schema  |        Name        |           Owner           |       Type        | Parent name  |    Table    
----------+--------------------+---------------------------+-------------------+--------------+-------------
 testpart | parent_tab         | regress_partitioning_role | partitioned table |              | 
 testpart | child_30_40        | regress_partitioning_role | partitioned table | parent_tab   | 
 testpart | parent_index       | regress_partitioning_role | partitioned index |              | parent_tab
 testpart | child_30_40_id_idx | regress_partitioning_role | partitioned index | parent_index | child_30_40
(4 rows)

\dP
                            List of partitioned relations
  Schema  |     Name     |           Owner           |       Type        |   Table    
----------+--------------+---------------------------+-------------------+------------
 testpart | parent_tab   | regress_partitioning_role | partitioned table | 
 testpart | parent_index | regress_partitioning_role | partitioned index | parent_tab
(2 rows)

\dPtn
                    List of partitioned tables
  Schema  |    Name     |           Owner           | Parent name 
----------+-------------+---------------------------+-------------
 testpart | parent_tab  | regress_partitioning_role | 
 testpart | child_30_40 | regress_partitioning_role | parent_tab
(2 rows)

\dPin
                              List of partitioned indexes
  Schema  |        Name        |           Owner           | Parent name  |    Table    
----------+--------------------+---------------------------+--------------+-------------
 testpart | parent_index       | regress_partitioning_role |              | parent_tab
 testpart | child_30_40_id_idx | regress_partitioning_role | parent_index | child_30_40
(2 rows)

\dPn
                                       List of partitioned relations
  Schema  |        Name        |           Owner           |       Type        | Parent name  |    Table    
----------+--------------------+---------------------------+-------------------+--------------+-------------
 testpart | parent_tab         | regress_partitioning_role | partitioned table |              | 
 testpart | child_30_40        | regress_partitioning_role | partitioned table | parent_tab   | 
 testpart | parent_index       | regress_partitioning_role | partitioned index |              | parent_tab
 testpart | child_30_40_id_idx | regress_partitioning_role | partitioned index | parent_index | child_30_40
(4 rows)

\dPn testpart.*
                                       List of partitioned relations
  Schema  |        Name        |           Owner           |       Type        | Parent name  |    Table    
----------+--------------------+---------------------------+-------------------+--------------+-------------
 testpart | parent_tab         | regress_partitioning_role | partitioned table |              | 
 testpart | child_30_40        | regress_partitioning_role | partitioned table | parent_tab   | 
 testpart | parent_index       | regress_partitioning_role | partitioned index |              | parent_tab
 testpart | child_30_40_id_idx | regress_partitioning_role | partitioned index | parent_index | child_30_40
(4 rows)

drop table parent_tab cascade;
drop schema testpart;
set search_path to default;
set role to default;
drop role regress_partitioning_role;
-- \d on toast table (use pg_statistic's toast table, which has a known name)
\d pg_toast.pg_toast_2619
TOAST table "pg_toast.pg_toast_2619"
   Column   |  Type   
------------+---------
 chunk_id   | oid
 chunk_seq  | integer
 chunk_data | bytea
Owning table: "pg_catalog.pg_statistic"
Indexes:
    "pg_toast_2619_index" PRIMARY KEY, btree (chunk_id, chunk_seq)

-- check printing info about access methods
\dA
List of access methods
  Name  | Type  
--------+-------
 brin   | Index
 btree  | Index
 gin    | Index
 gist   | Index
 hash   | Index
 heap   | Table
 heap2  | Table
 spgist | Index
(8 rows)

\dA *
List of access methods
  Name  | Type  
--------+-------
 brin   | Index
 btree  | Index
 gin    | Index
 gist   | Index
 hash   | Index
 heap   | Table
 heap2  | Table
 spgist | Index
(8 rows)

\dA h*
List of access methods
 Name  | Type  
-------+-------
 hash  | Index
 heap  | Table
 heap2 | Table
(3 rows)

\dA foo
List of access methods
 Name | Type 
------+------
(0 rows)

\dA foo bar
List of access methods
 Name | Type 
------+------
(0 rows)

\dA: extra argument "bar" ignored
\dA+
                             List of access methods
  Name  | Type  |       Handler        |              Description               
--------+-------+----------------------+----------------------------------------
 brin   | Index | brinhandler          | block range index (BRIN) access method
 btree  | Index | bthandler            | b-tree index access method
 gin    | Index | ginhandler           | GIN index access method
 gist   | Index | gisthandler          | GiST index access method
 hash   | Index | hashhandler          | hash index access method
 heap   | Table | heap_tableam_handler | heap table access method
 heap2  | Table | heap_tableam_handler | 
 spgist | Index | spghandler           | SP-GiST index access method
(8 rows)

\dA+ *
                             List of access methods
  Name  | Type  |       Handler        |              Description               
--------+-------+----------------------+----------------------------------------
 brin   | Index | brinhandler          | block range index (BRIN) access method
 btree  | Index | bthandler            | b-tree index access method
 gin    | Index | ginhandler           | GIN index access method
 gist   | Index | gisthandler          | GiST index access method
 hash   | Index | hashhandler          | hash index access method
 heap   | Table | heap_tableam_handler | heap table access method
 heap2  | Table | heap_tableam_handler | 
 spgist | Index | spghandler           | SP-GiST index access method
(8 rows)

\dA+ h*
                     List of access methods
 Name  | Type  |       Handler        |       Description        
-------+-------+----------------------+--------------------------
 hash  | Index | hashhandler          | hash index access method
 heap  | Table | heap_tableam_handler | heap table access method
 heap2 | Table | heap_tableam_handler | 
(3 rows)

\dA+ foo
       List of access methods
 Name | Type | Handler | Description 
------+------+---------+-------------
(0 rows)

\dAc brin pg*.oid*
                      List of operator classes
  AM  | Input type | Storage type |    Operator class    | Default? 
------+------------+--------------+----------------------+----------
 brin | oid        |              | oid_bloom_ops        | no
 brin | oid        |              | oid_minmax_multi_ops | no
 brin | oid        |              | oid_minmax_ops       | yes
(3 rows)

\dAf spgist
          List of operator families
   AM   | Operator family | Applicable types 
--------+-----------------+------------------
 spgist | box_ops         | box
 spgist | kd_point_ops    | point
 spgist | network_ops     | inet
 spgist | poly_ops        | polygon
 spgist | quad_point_ops  | point
 spgist | range_ops       | anyrange
 spgist | text_ops        | text
(7 rows)

\dAf btree int4
              List of operator families
  AM   | Operator family |     Applicable types      
-------+-----------------+---------------------------
 btree | integer_ops     | smallint, integer, bigint
(1 row)

\dAo+ btree array_ops|float_ops
                                      List of operators of operator families
  AM   | Operator family |               Operator                | Strategy | Purpose | Sort opfamily | Leakproof? 
-------+-----------------+---------------------------------------+----------+---------+---------------+------------
 btree | array_ops       | <(anyarray,anyarray)                  |        1 | search  |               | no
 btree | array_ops       | <=(anyarray,anyarray)                 |        2 | search  |               | no
 btree | array_ops       | =(anyarray,anyarray)                  |        3 | search  |               | no
 btree | array_ops       | >=(anyarray,anyarray)                 |        4 | search  |               | no
 btree | array_ops       | >(anyarray,anyarray)                  |        5 | search  |               | no
 btree | float_ops       | <(double precision,double precision)  |        1 | search  |               | yes
 btree | float_ops       | <=(double precision,double precision) |        2 | search  |               | yes
 btree | float_ops       | =(double precision,double precision)  |        3 | search  |               | yes
 btree | float_ops       | >=(double precision,double precision) |        4 | search  |               | yes
 btree | float_ops       | >(double precision,double precision)  |        5 | search  |               | yes
 btree | float_ops       | <(real,real)                          |        1 | search  |               | yes
 btree | float_ops       | <=(real,real)                         |        2 | search  |               | yes
 btree | float_ops       | =(real,real)                          |        3 | search  |               | yes
 btree | float_ops       | >=(real,real)                         |        4 | search  |               | yes
 btree | float_ops       | >(real,real)                          |        5 | search  |               | yes
 btree | float_ops       | <(double precision,real)              |        1 | search  |               | yes
 btree | float_ops       | <=(double precision,real)             |        2 | search  |               | yes
 btree | float_ops       | =(double precision,real)              |        3 | search  |               | yes
 btree | float_ops       | >=(double precision,real)             |        4 | search  |               | yes
 btree | float_ops       | >(double precision,real)              |        5 | search  |               | yes
 btree | float_ops       | <(real,double precision)              |        1 | search  |               | yes
 btree | float_ops       | <=(real,double precision)             |        2 | search  |               | yes
 btree | float_ops       | =(real,double precision)              |        3 | search  |               | yes
 btree | float_ops       | >=(real,double precision)             |        4 | search  |               | yes
 btree | float_ops       | >(real,double precision)              |        5 | search  |               | yes
(25 rows)

\dAo * pg_catalog.jsonb_path_ops
             List of operators of operator families
 AM  | Operator family |      Operator      | Strategy | Purpose 
-----+-----------------+--------------------+----------+---------
 gin | jsonb_path_ops  | @>(jsonb,jsonb)    |        7 | search
 gin | jsonb_path_ops  | @?(jsonb,jsonpath) |       15 | search
 gin | jsonb_path_ops  | @@(jsonb,jsonpath) |       16 | search
(3 rows)

\dAp+ btree float_ops
                                                         List of support functions of operator families
  AM   | Operator family | Registered left type | Registered right type | Number |                                   Function                                   
-------+-----------------+----------------------+-----------------------+--------+------------------------------------------------------------------------------
 btree | float_ops       | double precision     | double precision      |      1 | btfloat8cmp(double precision,double precision)
 btree | float_ops       | double precision     | double precision      |      2 | btfloat8sortsupport(internal)
 btree | float_ops       | double precision     | double precision      |      3 | in_range(double precision,double precision,double precision,boolean,boolean)
 btree | float_ops       | real                 | real                  |      1 | btfloat4cmp(real,real)
 btree | float_ops       | real                 | real                  |      2 | btfloat4sortsupport(internal)
 btree | float_ops       | double precision     | real                  |      1 | btfloat84cmp(double precision,real)
 btree | float_ops       | real                 | double precision      |      1 | btfloat48cmp(real,double precision)
 btree | float_ops       | real                 | double precision      |      3 | in_range(real,real,double precision,boolean,boolean)
(8 rows)

\dApx+ btree time_ops
List of support functions of operator families
-[ RECORD 1 ]---------+---------------------------------------------------------------------------------
AM                    | btree
Operator family       | time_ops
Registered left type  | time without time zone
Registered right type | time without time zone
Number                | 1
Function              | time_cmp(time without time zone,time without time zone)
-[ RECORD 2 ]---------+---------------------------------------------------------------------------------
AM                    | btree
Operator family       | time_ops
Registered left type  | time without time zone
Registered right type | time without time zone
Number                | 4
Function              | btequalimage(oid)
-[ RECORD 3 ]---------+---------------------------------------------------------------------------------
AM                    | btree
Operator family       | time_ops
Registered left type  | time without time zone
Registered right type | interval
Number                | 3
Function              | in_range(time without time zone,time without time zone,interval,boolean,boolean)

\dAp * pg_catalog.uuid_ops
                            List of support functions of operator families
  AM   | Operator family | Registered left type | Registered right type | Number |      Function      
-------+-----------------+----------------------+-----------------------+--------+--------------------
 btree | uuid_ops        | uuid                 | uuid                  |      1 | uuid_cmp
 btree | uuid_ops        | uuid                 | uuid                  |      2 | uuid_sortsupport
 btree | uuid_ops        | uuid                 | uuid                  |      4 | btequalimage
 hash  | uuid_ops        | uuid                 | uuid                  |      1 | uuid_hash
 hash  | uuid_ops        | uuid                 | uuid                  |      2 | uuid_hash_extended
(5 rows)

-- check \dconfig
set work_mem = 10240;
\dconfig work_mem
List of configuration parameters
 Parameter | Value 
-----------+-------
 work_mem  | 10MB
(1 row)

\dconfig+ work*
             List of configuration parameters
 Parameter | Value |  Type   | Context | Access privileges 
-----------+-------+---------+---------+-------------------
 work_mem  | 10MB  | integer | user    | 
(1 row)

reset work_mem;
-- check \df, \do with argument specifications
\df *sqrt
                             List of functions
   Schema   |     Name     | Result data type | Argument data types | Type 
------------+--------------+------------------+---------------------+------
 pg_catalog | dsqrt        | double precision | double precision    | func
 pg_catalog | numeric_sqrt | numeric          | numeric             | func
 pg_catalog | sqrt         | double precision | double precision    | func
 pg_catalog | sqrt         | numeric          | numeric             | func
(4 rows)

\df *sqrt num*
                             List of functions
   Schema   |     Name     | Result data type | Argument data types | Type 
------------+--------------+------------------+---------------------+------
 pg_catalog | numeric_sqrt | numeric          | numeric             | func
 pg_catalog | sqrt         | numeric          | numeric             | func
(2 rows)

\df int*pl
                            List of functions
   Schema   |    Name     | Result data type | Argument data types | Type 
------------+-------------+------------------+---------------------+------
 pg_catalog | int24pl     | integer          | smallint, integer   | func
 pg_catalog | int28pl     | bigint           | smallint, bigint    | func
 pg_catalog | int2pl      | smallint         | smallint, smallint  | func
 pg_catalog | int42pl     | integer          | integer, smallint   | func
 pg_catalog | int48pl     | bigint           | integer, bigint     | func
 pg_catalog | int4pl      | integer          | integer, integer    | func
 pg_catalog | int82pl     | bigint           | bigint, smallint    | func
 pg_catalog | int84pl     | bigint           | bigint, integer     | func
 pg_catalog | int8pl      | bigint           | bigint, bigint      | func
 pg_catalog | interval_pl | interval         | interval, interval  | func
(10 rows)

\df int*pl int4
                          List of functions
   Schema   |  Name   | Result data type | Argument data types | Type 
------------+---------+------------------+---------------------+------
 pg_catalog | int42pl | integer          | integer, smallint   | func
 pg_catalog | int48pl | bigint           | integer, bigint     | func
 pg_catalog | int4pl  | integer          | integer, integer    | func
(3 rows)

\df int*pl * pg_catalog.int8
                          List of functions
   Schema   |  Name   | Result data type | Argument data types | Type 
------------+---------+------------------+---------------------+------
 pg_catalog | int28pl | bigint           | smallint, bigint    | func
 pg_catalog | int48pl | bigint           | integer, bigint     | func
 pg_catalog | int8pl  | bigint           | bigint, bigint      | func
(3 rows)

\df acl* aclitem[]
                                                                    List of functions
   Schema   |    Name     | Result data type |                                        Argument data types                                         | Type 
------------+-------------+------------------+----------------------------------------------------------------------------------------------------+------
 pg_catalog | aclcontains | boolean          | aclitem[], aclitem                                                                                 | func
 pg_catalog | aclexplode  | SETOF record     | acl aclitem[], OUT grantor oid, OUT grantee oid, OUT privilege_type text, OUT is_grantable boolean | func
 pg_catalog | aclinsert   | aclitem[]        | aclitem[], aclitem                                                                                 | func
 pg_catalog | aclremove   | aclitem[]        | aclitem[], aclitem                                                                                 | func
(4 rows)

\df has_database_privilege oid text
                                  List of functions
   Schema   |          Name          | Result data type | Argument data types | Type 
------------+------------------------+------------------+---------------------+------
 pg_catalog | has_database_privilege | boolean          | oid, text           | func
 pg_catalog | has_database_privilege | boolean          | oid, text, text     | func
(2 rows)

\df has_database_privilege oid text -
                                  List of functions
   Schema   |          Name          | Result data type | Argument data types | Type 
------------+------------------------+------------------+---------------------+------
 pg_catalog | has_database_privilege | boolean          | oid, text           | func
(1 row)

\dfa bit* small*
                          List of functions
   Schema   |  Name   | Result data type | Argument data types | Type 
------------+---------+------------------+---------------------+------
 pg_catalog | bit_and | smallint         | smallint            | agg
 pg_catalog | bit_or  | smallint         | smallint            | agg
 pg_catalog | bit_xor | smallint         | smallint            | agg
(3 rows)

\df *._pg_expandarray
                                             List of functions
       Schema       |      Name       | Result data type |            Argument data types            | Type 
--------------------+-----------------+------------------+-------------------------------------------+------
 information_schema | _pg_expandarray | SETOF record     | anyarray, OUT x anyelement, OUT n integer | func
(1 row)

\do - pg_catalog.int4
                               List of operators
   Schema   | Name | Left arg type | Right arg type | Result type | Description 
------------+------+---------------+----------------+-------------+-------------
 pg_catalog | -    |               | integer        | integer     | negate
(1 row)

\do && anyarray *
                               List of operators
   Schema   | Name | Left arg type | Right arg type | Result type | Description 
------------+------+---------------+----------------+-------------+-------------
 pg_catalog | &&   | anyarray      | anyarray       | boolean     | overlaps
(1 row)

-- check \df+
-- we have to use functions with a predictable owner name, so make a role
create role regress_psql_user superuser;
begin;
set session authorization regress_psql_user;
create function psql_df_internal (float8)
  returns float8
  language internal immutable parallel safe strict
  as 'dsin';
create function psql_df_sql (x integer)
  returns integer
  security definer
  begin atomic select x + 1; end;
create function psql_df_plpgsql ()
  returns void
  language plpgsql
  as $$ begin return; end; $$;
comment on function psql_df_plpgsql () is 'some comment';
\df+ psql_df_*
                                                                                              List of functions
 Schema |       Name       | Result data type | Argument data types | Type | Volatility | Parallel |       Owner       | Security | Leakproof? | Access privileges | Language | Internal name | Description  
--------+------------------+------------------+---------------------+------+------------+----------+-------------------+----------+------------+-------------------+----------+---------------+--------------
 public | psql_df_internal | double precision | double precision    | func | immutable  | safe     | regress_psql_user | invoker  | no         |                   | internal | dsin          | 
 public | psql_df_plpgsql  | void             |                     | func | volatile   | unsafe   | regress_psql_user | invoker  | no         |                   | plpgsql  |               | some comment
 public | psql_df_sql      | integer          | x integer           | func | volatile   | unsafe   | regress_psql_user | definer  | no         |                   | sql      |               | 
(3 rows)

rollback;
drop role regress_psql_user;
-- check \sf
\sf information_schema._pg_index_position
CREATE OR REPLACE FUNCTION information_schema._pg_index_position(oid, smallint)
 RETURNS integer
 LANGUAGE sql
 STABLE STRICT
BEGIN ATOMIC
 SELECT (ss.a).n AS n
    FROM ( SELECT information_schema._pg_expandarray(pg_index.indkey) AS a
            FROM pg_index
           WHERE (pg_index.indexrelid = $1)) ss
   WHERE ((ss.a).x = $2);
END
\sf+ information_schema._pg_index_position
        CREATE OR REPLACE FUNCTION information_schema._pg_index_position(oid, smallint)
         RETURNS integer
         LANGUAGE sql
         STABLE STRICT
1       BEGIN ATOMIC
2        SELECT (ss.a).n AS n
3           FROM ( SELECT information_schema._pg_expandarray(pg_index.indkey) AS a
4                   FROM pg_index
5                  WHERE (pg_index.indexrelid = $1)) ss
6          WHERE ((ss.a).x = $2);
7       END
\sf+ interval_pl_time
        CREATE OR REPLACE FUNCTION pg_catalog.interval_pl_time(interval, time without time zone)
         RETURNS time without time zone
         LANGUAGE sql
         IMMUTABLE PARALLEL SAFE STRICT COST 1
1       RETURN ($2 + $1)
\sf ts_debug(text);
CREATE OR REPLACE FUNCTION pg_catalog.ts_debug(document text, OUT alias text, OUT description text, OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary, OUT lexemes text[])
 RETURNS SETOF record
 LANGUAGE sql
 STABLE PARALLEL SAFE STRICT
BEGIN ATOMIC
 SELECT ts_debug.alias,
     ts_debug.description,
     ts_debug.token,
     ts_debug.dictionaries,
     ts_debug.dictionary,
     ts_debug.lexemes
    FROM ts_debug(get_current_ts_config(), ts_debug.document) ts_debug(alias, description, token, dictionaries, dictionary, lexemes);
END
\sf+ ts_debug(text)
        CREATE OR REPLACE FUNCTION pg_catalog.ts_debug(document text, OUT alias text, OUT description text, OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary, OUT lexemes text[])
         RETURNS SETOF record
         LANGUAGE sql
         STABLE PARALLEL SAFE STRICT
1       BEGIN ATOMIC
2        SELECT ts_debug.alias,
3            ts_debug.description,
4            ts_debug.token,
5            ts_debug.dictionaries,
6            ts_debug.dictionary,
7            ts_debug.lexemes
8           FROM ts_debug(get_current_ts_config(), ts_debug.document) ts_debug(alias, description, token, dictionaries, dictionary, lexemes);
9       END
-- AUTOCOMMIT
CREATE TABLE ac_test (a int);
\set AUTOCOMMIT off
INSERT INTO ac_test VALUES (1);
COMMIT;
SELECT * FROM ac_test;
 a 
---
 1
(1 row)

COMMIT;
INSERT INTO ac_test VALUES (2);
ROLLBACK;
SELECT * FROM ac_test;
 a 
---
 1
(1 row)

COMMIT;
BEGIN;
INSERT INTO ac_test VALUES (3);
COMMIT;
SELECT * FROM ac_test;
 a 
---
 1
 3
(2 rows)

COMMIT;
BEGIN;
INSERT INTO ac_test VALUES (4);
ROLLBACK;
SELECT * FROM ac_test;
 a 
---
 1
 3
(2 rows)

COMMIT;
\set AUTOCOMMIT on
DROP TABLE ac_test;
SELECT * FROM ac_test;  -- should be gone now
ERROR:  relation "ac_test" does not exist
LINE 1: SELECT * FROM ac_test;
                      ^
-- ON_ERROR_ROLLBACK
\set ON_ERROR_ROLLBACK on
CREATE TABLE oer_test (a int);
BEGIN;
INSERT INTO oer_test VALUES (1);
INSERT INTO oer_test VALUES ('foo');
ERROR:  invalid input syntax for type integer: "foo"
LINE 1: INSERT INTO oer_test VALUES ('foo');
                                     ^
INSERT INTO oer_test VALUES (3);
COMMIT;
SELECT * FROM oer_test;
 a 
---
 1
 3
(2 rows)

BEGIN;
INSERT INTO oer_test VALUES (4);
ROLLBACK;
SELECT * FROM oer_test;
 a 
---
 1
 3
(2 rows)

BEGIN;
INSERT INTO oer_test VALUES (5);
COMMIT AND CHAIN;
INSERT INTO oer_test VALUES (6);
COMMIT;
SELECT * FROM oer_test;
 a 
---
 1
 3
 5
 6
(4 rows)

DROP TABLE oer_test;
\set ON_ERROR_ROLLBACK off
-- ECHO errors
\set ECHO errors
ERROR:  relation "notexists" does not exist
LINE 1: SELECT * FROM notexists;
                      ^
STATEMENT:  SELECT * FROM notexists;
--
-- combined queries
--
CREATE FUNCTION warn(msg TEXT) RETURNS BOOLEAN LANGUAGE plpgsql
AS $$
  BEGIN RAISE NOTICE 'warn %', msg ; RETURN TRUE ; END
$$;
-- show both
SELECT 1 AS one \; SELECT warn('1.5') \; SELECT 2 AS two ;
NOTICE:  warn 1.5
CONTEXT:  PL/pgSQL function warn(text) line 2 at RAISE
 one 
-----
   1
(1 row)

 warn 
------
 t
(1 row)

 two 
-----
   2
(1 row)

-- \gset applies to last query only
SELECT 3 AS three \; SELECT warn('3.5') \; SELECT 4 AS four \gset
NOTICE:  warn 3.5
CONTEXT:  PL/pgSQL function warn(text) line 2 at RAISE
 three 
-------
     3
(1 row)

 warn 
------
 t
(1 row)

\echo :three :four
:three 4
-- syntax error stops all processing
SELECT 5 \; SELECT 6 + \; SELECT warn('6.5') \; SELECT 7 ;
ERROR:  syntax error at or near ";"
LINE 1: SELECT 5 ; SELECT 6 + ; SELECT warn('6.5') ; SELECT 7 ;
                              ^
-- with aborted transaction, stop on first error
BEGIN \; SELECT 8 AS eight \; SELECT 9/0 AS nine \; ROLLBACK \; SELECT 10 AS ten ;
 eight 
-------
     8
(1 row)

ERROR:  division by zero
-- close previously aborted transaction
ROLLBACK;
-- miscellaneous SQL commands
-- (non SELECT output is sent to stderr, thus is not shown in expected results)
SELECT 'ok' AS "begin" \;
CREATE TABLE psql_comics(s TEXT) \;
INSERT INTO psql_comics VALUES ('Calvin'), ('hobbes') \;
COPY psql_comics FROM STDIN \;
UPDATE psql_comics SET s = 'Hobbes' WHERE s = 'hobbes' \;
DELETE FROM psql_comics WHERE s = 'Moe' \;
COPY psql_comics TO STDOUT \;
TRUNCATE psql_comics \;
DROP TABLE psql_comics \;
SELECT 'ok' AS "done" ;
 begin 
-------
 ok
(1 row)

Calvin
Susie
Hobbes
 done 
------
 ok
(1 row)

\set SHOW_ALL_RESULTS off
SELECT 1 AS one \; SELECT warn('1.5') \; SELECT 2 AS two ;
NOTICE:  warn 1.5
CONTEXT:  PL/pgSQL function warn(text) line 2 at RAISE
 two 
-----
   2
(1 row)

\set SHOW_ALL_RESULTS on
DROP FUNCTION warn(TEXT);
--
-- \g with file
--
\getenv abs_builddir PG_ABS_BUILDDIR
\set g_out_file :abs_builddir '/results/psql-output1'
CREATE TEMPORARY TABLE reload_output(
  lineno int NOT NULL GENERATED ALWAYS AS IDENTITY,
  line text
);
SELECT 1 AS a \g :g_out_file
COPY reload_output(line) FROM :'g_out_file';
SELECT 2 AS b\; SELECT 3 AS c\; SELECT 4 AS d \g :g_out_file
COPY reload_output(line) FROM :'g_out_file';
COPY (SELECT 'foo') TO STDOUT \; COPY (SELECT 'bar') TO STDOUT \g :g_out_file
COPY reload_output(line) FROM :'g_out_file';
SELECT line FROM reload_output ORDER BY lineno;
  line   
---------
  a 
 ---
  1
 (1 row)
 
  b 
 ---
  2
 (1 row)
 
  c 
 ---
  3
 (1 row)
 
  d 
 ---
  4
 (1 row)
 
 foo
 bar
(22 rows)

TRUNCATE TABLE reload_output;
--
-- \o with file
--
\set o_out_file :abs_builddir '/results/psql-output2'
\o :o_out_file
SELECT max(unique1) FROM onek;
SELECT 1 AS a\; SELECT 2 AS b\; SELECT 3 AS c;
-- COPY TO file
-- The data goes to :g_out_file and the status to :o_out_file
\set QUIET false
COPY (SELECT unique1 FROM onek ORDER BY unique1 LIMIT 10) TO :'g_out_file';
-- DML command status
UPDATE onek SET unique1 = unique1 WHERE false;
\set QUIET true
\o
-- Check the contents of the files generated.
COPY reload_output(line) FROM :'g_out_file';
SELECT line FROM reload_output ORDER BY lineno;
 line 
------
 0
 1
 2
 3
 4
 5
 6
 7
 8
 9
(10 rows)

TRUNCATE TABLE reload_output;
COPY reload_output(line) FROM :'o_out_file';
SELECT line FROM reload_output ORDER BY lineno;
   line   
----------
  max 
 -----
  999
 (1 row)
 
  a 
 ---
  1
 (1 row)
 
  b 
 ---
  2
 (1 row)
 
  c 
 ---
  3
 (1 row)
 
 COPY 10
 UPDATE 0
(22 rows)

TRUNCATE TABLE reload_output;
-- Multiple COPY TO STDOUT with output file
\o :o_out_file
-- The data goes to :o_out_file with no status generated.
COPY (SELECT 'foo1') TO STDOUT \; COPY (SELECT 'bar1') TO STDOUT;
-- Combination of \o and \g file with multiple COPY queries.
COPY (SELECT 'foo2') TO STDOUT \; COPY (SELECT 'bar2') TO STDOUT \g :g_out_file
\o
-- Check the contents of the files generated.
COPY reload_output(line) FROM :'g_out_file';
SELECT line FROM reload_output ORDER BY lineno;
 line 
------
 foo2
 bar2
(2 rows)

TRUNCATE TABLE reload_output;
COPY reload_output(line) FROM :'o_out_file';
SELECT line FROM reload_output ORDER BY lineno;
 line 
------
 foo1
 bar1
(2 rows)

DROP TABLE reload_output;
--
-- AUTOCOMMIT and combined queries
--
\set AUTOCOMMIT off
\echo '# AUTOCOMMIT:' :AUTOCOMMIT
# AUTOCOMMIT: off
-- BEGIN is now implicit
CREATE TABLE foo(s TEXT) \;
ROLLBACK;
CREATE TABLE foo(s TEXT) \;
INSERT INTO foo(s) VALUES ('hello'), ('world') \;
COMMIT;
DROP TABLE foo \;
ROLLBACK;
-- table foo is still there
SELECT * FROM foo ORDER BY 1 \;
DROP TABLE foo \;
COMMIT;
   s   
-------
 hello
 world
(2 rows)

\set AUTOCOMMIT on
\echo '# AUTOCOMMIT:' :AUTOCOMMIT
# AUTOCOMMIT: on
-- BEGIN now explicit for multi-statement transactions
BEGIN \;
CREATE TABLE foo(s TEXT) \;
INSERT INTO foo(s) VALUES ('hello'), ('world') \;
COMMIT;
BEGIN \;
DROP TABLE foo \;
ROLLBACK \;
-- implicit transactions
SELECT * FROM foo ORDER BY 1 \;
DROP TABLE foo;
   s   
-------
 hello
 world
(2 rows)

--
-- test ON_ERROR_ROLLBACK and combined queries
--
CREATE FUNCTION psql_error(msg TEXT) RETURNS BOOLEAN AS $$
  BEGIN
    RAISE EXCEPTION 'error %', msg;
  END;
$$ LANGUAGE plpgsql;
\set ON_ERROR_ROLLBACK on
\echo '# ON_ERROR_ROLLBACK:' :ON_ERROR_ROLLBACK
# ON_ERROR_ROLLBACK: on
\echo '# AUTOCOMMIT:' :AUTOCOMMIT
# AUTOCOMMIT: on
BEGIN;
CREATE TABLE bla(s NO_SUCH_TYPE);               -- fails
ERROR:  type "no_such_type" does not exist
LINE 1: CREATE TABLE bla(s NO_SUCH_TYPE);
                           ^
CREATE TABLE bla(s TEXT);                       -- succeeds
SELECT psql_error('oops!');                     -- fails
ERROR:  error oops!
CONTEXT:  PL/pgSQL function psql_error(text) line 3 at RAISE
INSERT INTO bla VALUES ('Calvin'), ('Hobbes');
COMMIT;
SELECT * FROM bla ORDER BY 1;
   s    
--------
 Calvin
 Hobbes
(2 rows)

BEGIN;
INSERT INTO bla VALUES ('Susie');         -- succeeds
-- now with combined queries
INSERT INTO bla VALUES ('Rosalyn') \;     -- will rollback
SELECT 'before error' AS show \;          -- will show nevertheless!
  SELECT psql_error('boum!') \;           -- failure
  SELECT 'after error' AS noshow;         -- hidden by preceding error
     show     
--------------
 before error
(1 row)

ERROR:  error boum!
CONTEXT:  PL/pgSQL function psql_error(text) line 3 at RAISE
INSERT INTO bla(s) VALUES ('Moe') \;      -- will rollback
  SELECT psql_error('bam!');
ERROR:  error bam!
CONTEXT:  PL/pgSQL function psql_error(text) line 3 at RAISE
INSERT INTO bla VALUES ('Miss Wormwood'); -- succeeds
COMMIT;
SELECT * FROM bla ORDER BY 1;
       s       
---------------
 Calvin
 Hobbes
 Miss Wormwood
 Susie
(4 rows)

-- some with autocommit off
\set AUTOCOMMIT off
\echo '# AUTOCOMMIT:' :AUTOCOMMIT
# AUTOCOMMIT: off
-- implicit BEGIN
INSERT INTO bla VALUES ('Dad');           -- succeeds
SELECT psql_error('bad!');                -- implicit partial rollback
ERROR:  error bad!
CONTEXT:  PL/pgSQL function psql_error(text) line 3 at RAISE
INSERT INTO bla VALUES ('Mum') \;         -- will rollback
SELECT COUNT(*) AS "#mum"
FROM bla WHERE s = 'Mum' \;               -- but be counted here
SELECT psql_error('bad!');                -- implicit partial rollback
 #mum 
------
    1
(1 row)

ERROR:  error bad!
CONTEXT:  PL/pgSQL function psql_error(text) line 3 at RAISE
COMMIT;
SELECT COUNT(*) AS "#mum"
FROM bla WHERE s = 'Mum' \;               -- no mum here
SELECT * FROM bla ORDER BY 1;
 #mum 
------
    0
(1 row)

       s       
---------------
 Calvin
 Dad
 Hobbes
 Miss Wormwood
 Susie
(5 rows)

COMMIT;
-- reset all
\set AUTOCOMMIT on
\set ON_ERROR_ROLLBACK off
\echo '# final ON_ERROR_ROLLBACK:' :ON_ERROR_ROLLBACK
# final ON_ERROR_ROLLBACK: off
DROP TABLE bla;
DROP FUNCTION psql_error;
-- check describing invalid multipart names
\dA regression.heap
improper qualified name (too many dotted names): regression.heap
\dA nonesuch.heap
improper qualified name (too many dotted names): nonesuch.heap
\dt host.regression.pg_catalog.pg_class
improper qualified name (too many dotted names): host.regression.pg_catalog.pg_class
\dt |.pg_catalog.pg_class
cross-database references are not implemented: |.pg_catalog.pg_class
\dt nonesuch.pg_catalog.pg_class
cross-database references are not implemented: nonesuch.pg_catalog.pg_class
\da host.regression.pg_catalog.sum
improper qualified name (too many dotted names): host.regression.pg_catalog.sum
\da +.pg_catalog.sum
cross-database references are not implemented: +.pg_catalog.sum
\da nonesuch.pg_catalog.sum
cross-database references are not implemented: nonesuch.pg_catalog.sum
\dAc nonesuch.brin
improper qualified name (too many dotted names): nonesuch.brin
\dAc regression.brin
improper qualified name (too many dotted names): regression.brin
\dAf nonesuch.brin
improper qualified name (too many dotted names): nonesuch.brin
\dAf regression.brin
improper qualified name (too many dotted names): regression.brin
\dAo nonesuch.brin
improper qualified name (too many dotted names): nonesuch.brin
\dAo regression.brin
improper qualified name (too many dotted names): regression.brin
\dAp nonesuch.brin
improper qualified name (too many dotted names): nonesuch.brin
\dAp regression.brin
improper qualified name (too many dotted names): regression.brin
\db nonesuch.pg_default
improper qualified name (too many dotted names): nonesuch.pg_default
\db regression.pg_default
improper qualified name (too many dotted names): regression.pg_default
\dc host.regression.public.conversion
improper qualified name (too many dotted names): host.regression.public.conversion
\dc (.public.conversion
cross-database references are not implemented: (.public.conversion
\dc nonesuch.public.conversion
cross-database references are not implemented: nonesuch.public.conversion
\dC host.regression.pg_catalog.int8
improper qualified name (too many dotted names): host.regression.pg_catalog.int8
\dC ).pg_catalog.int8
cross-database references are not implemented: ).pg_catalog.int8
\dC nonesuch.pg_catalog.int8
cross-database references are not implemented: nonesuch.pg_catalog.int8
\dd host.regression.pg_catalog.pg_class
improper qualified name (too many dotted names): host.regression.pg_catalog.pg_class
\dd [.pg_catalog.pg_class
cross-database references are not implemented: [.pg_catalog.pg_class
\dd nonesuch.pg_catalog.pg_class
cross-database references are not implemented: nonesuch.pg_catalog.pg_class
\dD host.regression.public.gtestdomain1
improper qualified name (too many dotted names): host.regression.public.gtestdomain1
\dD ].public.gtestdomain1
cross-database references are not implemented: ].public.gtestdomain1
\dD nonesuch.public.gtestdomain1
cross-database references are not implemented: nonesuch.public.gtestdomain1
\ddp host.regression.pg_catalog.pg_class
improper qualified name (too many dotted names): host.regression.pg_catalog.pg_class
\ddp {.pg_catalog.pg_class
cross-database references are not implemented: {.pg_catalog.pg_class
\ddp nonesuch.pg_catalog.pg_class
cross-database references are not implemented: nonesuch.pg_catalog.pg_class
\dE host.regression.public.ft
improper qualified name (too many dotted names): host.regression.public.ft
\dE }.public.ft
cross-database references are not implemented: }.public.ft
\dE nonesuch.public.ft
cross-database references are not implemented: nonesuch.public.ft
\di host.regression.public.tenk1_hundred
improper qualified name (too many dotted names): host.regression.public.tenk1_hundred
\di ..public.tenk1_hundred
improper qualified name (too many dotted names): ..public.tenk1_hundred
\di nonesuch.public.tenk1_hundred
cross-database references are not implemented: nonesuch.public.tenk1_hundred
\dm host.regression.public.mvtest_bb
improper qualified name (too many dotted names): host.regression.public.mvtest_bb
\dm ^.public.mvtest_bb
cross-database references are not implemented: ^.public.mvtest_bb
\dm nonesuch.public.mvtest_bb
cross-database references are not implemented: nonesuch.public.mvtest_bb
\ds host.regression.public.check_seq
improper qualified name (too many dotted names): host.regression.public.check_seq
\ds regression|mydb.public.check_seq
cross-database references are not implemented: regression|mydb.public.check_seq
\ds nonesuch.public.check_seq
cross-database references are not implemented: nonesuch.public.check_seq
\dt host.regression.public.b_star
improper qualified name (too many dotted names): host.regression.public.b_star
\dt regres+ion.public.b_star
cross-database references are not implemented: regres+ion.public.b_star
\dt nonesuch.public.b_star
cross-database references are not implemented: nonesuch.public.b_star
\dv host.regression.public.shoe
improper qualified name (too many dotted names): host.regression.public.shoe
\dv regress(ion).public.shoe
cross-database references are not implemented: regress(ion).public.shoe
\dv nonesuch.public.shoe
cross-database references are not implemented: nonesuch.public.shoe
\des nonesuch.server
improper qualified name (too many dotted names): nonesuch.server
\des regression.server
improper qualified name (too many dotted names): regression.server
\des nonesuch.server
improper qualified name (too many dotted names): nonesuch.server
\des regression.server
improper qualified name (too many dotted names): regression.server
\des nonesuch.username
improper qualified name (too many dotted names): nonesuch.username
\des regression.username
improper qualified name (too many dotted names): regression.username
\dew nonesuch.fdw
improper qualified name (too many dotted names): nonesuch.fdw
\dew regression.fdw
improper qualified name (too many dotted names): regression.fdw
\df host.regression.public.namelen
improper qualified name (too many dotted names): host.regression.public.namelen
\df regres[qrstuv]ion.public.namelen
cross-database references are not implemented: regres[qrstuv]ion.public.namelen
\df nonesuch.public.namelen
cross-database references are not implemented: nonesuch.public.namelen
\dF host.regression.pg_catalog.arabic
improper qualified name (too many dotted names): host.regression.pg_catalog.arabic
\dF regres{1,2}ion.pg_catalog.arabic
cross-database references are not implemented: regres{1,2}ion.pg_catalog.arabic
\dF nonesuch.pg_catalog.arabic
cross-database references are not implemented: nonesuch.pg_catalog.arabic
\dFd host.regression.pg_catalog.arabic_stem
improper qualified name (too many dotted names): host.regression.pg_catalog.arabic_stem
\dFd regres?ion.pg_catalog.arabic_stem
cross-database references are not implemented: regres?ion.pg_catalog.arabic_stem
\dFd nonesuch.pg_catalog.arabic_stem
cross-database references are not implemented: nonesuch.pg_catalog.arabic_stem
\dFp host.regression.pg_catalog.default
improper qualified name (too many dotted names): host.regression.pg_catalog.default
\dFp ^regression.pg_catalog.default
cross-database references are not implemented: ^regression.pg_catalog.default
\dFp nonesuch.pg_catalog.default
cross-database references are not implemented: nonesuch.pg_catalog.default
\dFt host.regression.pg_catalog.ispell
improper qualified name (too many dotted names): host.regression.pg_catalog.ispell
\dFt regression$.pg_catalog.ispell
cross-database references are not implemented: regression$.pg_catalog.ispell
\dFt nonesuch.pg_catalog.ispell
cross-database references are not implemented: nonesuch.pg_catalog.ispell
\dg nonesuch.pg_database_owner
improper qualified name (too many dotted names): nonesuch.pg_database_owner
\dg regression.pg_database_owner
improper qualified name (too many dotted names): regression.pg_database_owner
\dL host.regression.plpgsql
improper qualified name (too many dotted names): host.regression.plpgsql
\dL *.plpgsql
cross-database references are not implemented: *.plpgsql
\dL nonesuch.plpgsql
cross-database references are not implemented: nonesuch.plpgsql
\dn host.regression.public
improper qualified name (too many dotted names): host.regression.public
\dn """".public
cross-database references are not implemented: """".public
\dn nonesuch.public
cross-database references are not implemented: nonesuch.public
\do host.regression.public.!=-
improper qualified name (too many dotted names): host.regression.public.!=-
\do "regression|mydb".public.!=-
cross-database references are not implemented: "regression|mydb".public.!=-
\do nonesuch.public.!=-
cross-database references are not implemented: nonesuch.public.!=-
\dO host.regression.pg_catalog.POSIX
improper qualified name (too many dotted names): host.regression.pg_catalog.POSIX
\dO .pg_catalog.POSIX
cross-database references are not implemented: .pg_catalog.POSIX
\dO nonesuch.pg_catalog.POSIX
cross-database references are not implemented: nonesuch.pg_catalog.POSIX
\dp host.regression.public.a_star
improper qualified name (too many dotted names): host.regression.public.a_star
\dp "regres+ion".public.a_star
cross-database references are not implemented: "regres+ion".public.a_star
\dp nonesuch.public.a_star
cross-database references are not implemented: nonesuch.public.a_star
\dP host.regression.public.mlparted
improper qualified name (too many dotted names): host.regression.public.mlparted
\dP "regres(sion)".public.mlparted
cross-database references are not implemented: "regres(sion)".public.mlparted
\dP nonesuch.public.mlparted
cross-database references are not implemented: nonesuch.public.mlparted
\drds nonesuch.lc_messages
improper qualified name (too many dotted names): nonesuch.lc_messages
\drds regression.lc_messages
improper qualified name (too many dotted names): regression.lc_messages
\dRp public.mypub
improper qualified name (too many dotted names): public.mypub
\dRp regression.mypub
improper qualified name (too many dotted names): regression.mypub
\dRs public.mysub
improper qualified name (too many dotted names): public.mysub
\dRs regression.mysub
improper qualified name (too many dotted names): regression.mysub
\dT host.regression.public.widget
improper qualified name (too many dotted names): host.regression.public.widget
\dT "regression{1,2}".public.widget
cross-database references are not implemented: "regression{1,2}".public.widget
\dT nonesuch.public.widget
cross-database references are not implemented: nonesuch.public.widget
\dx regression.plpgsql
improper qualified name (too many dotted names): regression.plpgsql
\dx nonesuch.plpgsql
improper qualified name (too many dotted names): nonesuch.plpgsql
\dX host.regression.public.func_deps_stat
improper qualified name (too many dotted names): host.regression.public.func_deps_stat
\dX "^regression$".public.func_deps_stat
cross-database references are not implemented: "^regression$".public.func_deps_stat
\dX nonesuch.public.func_deps_stat
cross-database references are not implemented: nonesuch.public.func_deps_stat
\dy regression.myevt
improper qualified name (too many dotted names): regression.myevt
\dy nonesuch.myevt
improper qualified name (too many dotted names): nonesuch.myevt
-- check that dots within quoted name segments are not counted
\dA "no.such.access.method"
List of access methods
 Name | Type 
------+------
(0 rows)

\dt "no.such.table.relation"
        List of tables
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\da "no.such.aggregate.function"
                     List of aggregate functions
 Schema | Name | Result data type | Argument data types | Description 
--------+------+------------------+---------------------+-------------
(0 rows)

\dAc "no.such.operator.class"
                  List of operator classes
 AM | Input type | Storage type | Operator class | Default? 
----+------------+--------------+----------------+----------
(0 rows)

\dAf "no.such.operator.family"
        List of operator families
 AM | Operator family | Applicable types 
----+-----------------+------------------
(0 rows)

\dAo "no.such.operator.of.operator.family"
        List of operators of operator families
 AM | Operator family | Operator | Strategy | Purpose 
----+-----------------+----------+----------+---------
(0 rows)

\dAp "no.such.operator.support.function.of.operator.family"
                     List of support functions of operator families
 AM | Operator family | Registered left type | Registered right type | Number | Function 
----+-----------------+----------------------+-----------------------+--------+----------
(0 rows)

\db "no.such.tablespace"
   List of tablespaces
 Name | Owner | Location 
------+-------+----------
(0 rows)

\dc "no.such.conversion"
               List of conversions
 Schema | Name | Source | Destination | Default? 
--------+------+--------+-------------+----------
(0 rows)

\dC "no.such.cast"
                  List of casts
 Source type | Target type | Function | Implicit? 
-------------+-------------+----------+-----------
(0 rows)

\dd "no.such.object.description"
         Object descriptions
 Schema | Name | Object | Description 
--------+------+--------+-------------
(0 rows)

\dD "no.such.domain"
                        List of domains
 Schema | Name | Type | Collation | Nullable | Default | Check 
--------+------+------+-----------+----------+---------+-------
(0 rows)

\ddp "no.such.default.access.privilege"
         Default access privileges
 Owner | Schema | Type | Access privileges 
-------+--------+------+-------------------
(0 rows)

\di "no.such.index.relation"
           List of indexes
 Schema | Name | Type | Owner | Table 
--------+------+------+-------+-------
(0 rows)

\dm "no.such.materialized.view"
  List of materialized views
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\ds "no.such.relation"
      List of sequences
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\dt "no.such.relation"
        List of tables
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\dv "no.such.relation"
        List of views
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\des "no.such.foreign.server"
       List of foreign servers
 Name | Owner | Foreign-data wrapper 
------+-------+----------------------
(0 rows)

\dew "no.such.foreign.data.wrapper"
   List of foreign-data wrappers
 Name | Owner | Handler | Validator 
------+-------+---------+-----------
(0 rows)

\df "no.such.function"
                       List of functions
 Schema | Name | Result data type | Argument data types | Type 
--------+------+------------------+---------------------+------
(0 rows)

\dF "no.such.text.search.configuration"
List of text search configurations
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dFd "no.such.text.search.dictionary"
List of text search dictionaries
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dFp "no.such.text.search.parser"
 List of text search parsers
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dFt "no.such.text.search.template"
List of text search templates
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dg "no.such.role"
     List of roles
 Role name | Attributes 
-----------+------------

\dL "no.such.language"
          List of languages
 Name | Owner | Trusted | Description 
------+-------+---------+-------------
(0 rows)

\dn "no.such.schema"
List of schemas
 Name | Owner 
------+-------
(0 rows)

\do "no.such.operator"
                             List of operators
 Schema | Name | Left arg type | Right arg type | Result type | Description 
--------+------+---------------+----------------+-------------+-------------
(0 rows)

\dO "no.such.collation"
                                List of collations
 Schema | Name | Provider | Collate | Ctype | Locale | ICU Rules | Deterministic? 
--------+------+----------+---------+-------+--------+-----------+----------------
(0 rows)

\dp "no.such.access.privilege"
                            Access privileges
 Schema | Name | Type | Access privileges | Column privileges | Policies 
--------+------+------+-------------------+-------------------+----------
(0 rows)

\dP "no.such.partitioned.relation"
           List of partitioned relations
 Schema | Name | Owner | Type | Parent name | Table 
--------+------+-------+------+-------------+-------
(0 rows)

\drds "no.such.setting"
      List of settings
 Role | Database | Settings 
------+----------+----------
(0 rows)

\dRp "no.such.publication"
                                        List of publications
 Name | Owner | All tables | Inserts | Updates | Deletes | Truncates | Generated columns | Via root 
------+-------+------------+---------+---------+---------+-----------+-------------------+----------
(0 rows)

\dRs "no.such.subscription"
        List of subscriptions
 Name | Owner | Enabled | Publication 
------+-------+---------+-------------
(0 rows)

\dT "no.such.data.type"
     List of data types
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dx "no.such.installed.extension"
     List of installed extensions
 Name | Version | Schema | Description 
------+---------+--------+-------------
(0 rows)

\dX "no.such.extended.statistics"
                 List of extended statistics
 Schema | Name | Definition | Ndistinct | Dependencies | MCV 
--------+------+------------+-----------+--------------+-----
(0 rows)

\dy "no.such.event.trigger"
              List of event triggers
 Name | Event | Owner | Enabled | Function | Tags 
------+-------+-------+---------+----------+------
(0 rows)

-- again, but with dotted schema qualifications.
\dA "no.such.schema"."no.such.access.method"
improper qualified name (too many dotted names): "no.such.schema"."no.such.access.method"
\dt "no.such.schema"."no.such.table.relation"
        List of tables
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\da "no.such.schema"."no.such.aggregate.function"
                     List of aggregate functions
 Schema | Name | Result data type | Argument data types | Description 
--------+------+------------------+---------------------+-------------
(0 rows)

\dAc "no.such.schema"."no.such.operator.class"
improper qualified name (too many dotted names): "no.such.schema"."no.such.operator.class"
\dAf "no.such.schema"."no.such.operator.family"
improper qualified name (too many dotted names): "no.such.schema"."no.such.operator.family"
\dAo "no.such.schema"."no.such.operator.of.operator.family"
improper qualified name (too many dotted names): "no.such.schema"."no.such.operator.of.operator.family"
\dAp "no.such.schema"."no.such.operator.support.function.of.operator.family"
improper qualified name (too many dotted names): "no.such.schema"."no.such.operator.support.function.of.operator.family"
\db "no.such.schema"."no.such.tablespace"
improper qualified name (too many dotted names): "no.such.schema"."no.such.tablespace"
\dc "no.such.schema"."no.such.conversion"
               List of conversions
 Schema | Name | Source | Destination | Default? 
--------+------+--------+-------------+----------
(0 rows)

\dC "no.such.schema"."no.such.cast"
                  List of casts
 Source type | Target type | Function | Implicit? 
-------------+-------------+----------+-----------
(0 rows)

\dd "no.such.schema"."no.such.object.description"
         Object descriptions
 Schema | Name | Object | Description 
--------+------+--------+-------------
(0 rows)

\dD "no.such.schema"."no.such.domain"
                        List of domains
 Schema | Name | Type | Collation | Nullable | Default | Check 
--------+------+------+-----------+----------+---------+-------
(0 rows)

\ddp "no.such.schema"."no.such.default.access.privilege"
         Default access privileges
 Owner | Schema | Type | Access privileges 
-------+--------+------+-------------------
(0 rows)

\di "no.such.schema"."no.such.index.relation"
           List of indexes
 Schema | Name | Type | Owner | Table 
--------+------+------+-------+-------
(0 rows)

\dm "no.such.schema"."no.such.materialized.view"
  List of materialized views
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\ds "no.such.schema"."no.such.relation"
      List of sequences
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\dt "no.such.schema"."no.such.relation"
        List of tables
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\dv "no.such.schema"."no.such.relation"
        List of views
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\des "no.such.schema"."no.such.foreign.server"
improper qualified name (too many dotted names): "no.such.schema"."no.such.foreign.server"
\dew "no.such.schema"."no.such.foreign.data.wrapper"
improper qualified name (too many dotted names): "no.such.schema"."no.such.foreign.data.wrapper"
\df "no.such.schema"."no.such.function"
                       List of functions
 Schema | Name | Result data type | Argument data types | Type 
--------+------+------------------+---------------------+------
(0 rows)

\dF "no.such.schema"."no.such.text.search.configuration"
List of text search configurations
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dFd "no.such.schema"."no.such.text.search.dictionary"
List of text search dictionaries
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dFp "no.such.schema"."no.such.text.search.parser"
 List of text search parsers
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dFt "no.such.schema"."no.such.text.search.template"
List of text search templates
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dg "no.such.schema"."no.such.role"
improper qualified name (too many dotted names): "no.such.schema"."no.such.role"
\dL "no.such.schema"."no.such.language"
cross-database references are not implemented: "no.such.schema"."no.such.language"
\do "no.such.schema"."no.such.operator"
                             List of operators
 Schema | Name | Left arg type | Right arg type | Result type | Description 
--------+------+---------------+----------------+-------------+-------------
(0 rows)

\dO "no.such.schema"."no.such.collation"
                                List of collations
 Schema | Name | Provider | Collate | Ctype | Locale | ICU Rules | Deterministic? 
--------+------+----------+---------+-------+--------+-----------+----------------
(0 rows)

\dp "no.such.schema"."no.such.access.privilege"
                            Access privileges
 Schema | Name | Type | Access privileges | Column privileges | Policies 
--------+------+------+-------------------+-------------------+----------
(0 rows)

\dP "no.such.schema"."no.such.partitioned.relation"
           List of partitioned relations
 Schema | Name | Owner | Type | Parent name | Table 
--------+------+-------+------+-------------+-------
(0 rows)

\drds "no.such.schema"."no.such.setting"
improper qualified name (too many dotted names): "no.such.schema"."no.such.setting"
\dRp "no.such.schema"."no.such.publication"
improper qualified name (too many dotted names): "no.such.schema"."no.such.publication"
\dRs "no.such.schema"."no.such.subscription"
improper qualified name (too many dotted names): "no.such.schema"."no.such.subscription"
\dT "no.such.schema"."no.such.data.type"
     List of data types
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dx "no.such.schema"."no.such.installed.extension"
improper qualified name (too many dotted names): "no.such.schema"."no.such.installed.extension"
\dX "no.such.schema"."no.such.extended.statistics"
                 List of extended statistics
 Schema | Name | Definition | Ndistinct | Dependencies | MCV 
--------+------+------------+-----------+--------------+-----
(0 rows)

\dy "no.such.schema"."no.such.event.trigger"
improper qualified name (too many dotted names): "no.such.schema"."no.such.event.trigger"
-- again, but with current database and dotted schema qualifications.
\dt regression."no.such.schema"."no.such.table.relation"
        List of tables
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\da regression."no.such.schema"."no.such.aggregate.function"
                     List of aggregate functions
 Schema | Name | Result data type | Argument data types | Description 
--------+------+------------------+---------------------+-------------
(0 rows)

\dc regression."no.such.schema"."no.such.conversion"
               List of conversions
 Schema | Name | Source | Destination | Default? 
--------+------+--------+-------------+----------
(0 rows)

\dC regression."no.such.schema"."no.such.cast"
                  List of casts
 Source type | Target type | Function | Implicit? 
-------------+-------------+----------+-----------
(0 rows)

\dd regression."no.such.schema"."no.such.object.description"
         Object descriptions
 Schema | Name | Object | Description 
--------+------+--------+-------------
(0 rows)

\dD regression."no.such.schema"."no.such.domain"
                        List of domains
 Schema | Name | Type | Collation | Nullable | Default | Check 
--------+------+------+-----------+----------+---------+-------
(0 rows)

\di regression."no.such.schema"."no.such.index.relation"
           List of indexes
 Schema | Name | Type | Owner | Table 
--------+------+------+-------+-------
(0 rows)

\dm regression."no.such.schema"."no.such.materialized.view"
  List of materialized views
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\ds regression."no.such.schema"."no.such.relation"
      List of sequences
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\dt regression."no.such.schema"."no.such.relation"
        List of tables
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\dv regression."no.such.schema"."no.such.relation"
        List of views
 Schema | Name | Type | Owner 
--------+------+------+-------
(0 rows)

\df regression."no.such.schema"."no.such.function"
                       List of functions
 Schema | Name | Result data type | Argument data types | Type 
--------+------+------------------+---------------------+------
(0 rows)

\dF regression."no.such.schema"."no.such.text.search.configuration"
List of text search configurations
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dFd regression."no.such.schema"."no.such.text.search.dictionary"
List of text search dictionaries
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dFp regression."no.such.schema"."no.such.text.search.parser"
 List of text search parsers
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dFt regression."no.such.schema"."no.such.text.search.template"
List of text search templates
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\do regression."no.such.schema"."no.such.operator"
                             List of operators
 Schema | Name | Left arg type | Right arg type | Result type | Description 
--------+------+---------------+----------------+-------------+-------------
(0 rows)

\dO regression."no.such.schema"."no.such.collation"
                                List of collations
 Schema | Name | Provider | Collate | Ctype | Locale | ICU Rules | Deterministic? 
--------+------+----------+---------+-------+--------+-----------+----------------
(0 rows)

\dp regression."no.such.schema"."no.such.access.privilege"
                            Access privileges
 Schema | Name | Type | Access privileges | Column privileges | Policies 
--------+------+------+-------------------+-------------------+----------
(0 rows)

\dP regression."no.such.schema"."no.such.partitioned.relation"
           List of partitioned relations
 Schema | Name | Owner | Type | Parent name | Table 
--------+------+-------+------+-------------+-------
(0 rows)

\dT regression."no.such.schema"."no.such.data.type"
     List of data types
 Schema | Name | Description 
--------+------+-------------
(0 rows)

\dX regression."no.such.schema"."no.such.extended.statistics"
                 List of extended statistics
 Schema | Name | Definition | Ndistinct | Dependencies | MCV 
--------+------+------------+-----------+--------------+-----
(0 rows)

-- again, but with dotted database and dotted schema qualifications.
\dt "no.such.database"."no.such.schema"."no.such.table.relation"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.table.relation"
\da "no.such.database"."no.such.schema"."no.such.aggregate.function"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.aggregate.function"
\dc "no.such.database"."no.such.schema"."no.such.conversion"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.conversion"
\dC "no.such.database"."no.such.schema"."no.such.cast"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.cast"
\dd "no.such.database"."no.such.schema"."no.such.object.description"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.object.description"
\dD "no.such.database"."no.such.schema"."no.such.domain"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.domain"
\ddp "no.such.database"."no.such.schema"."no.such.default.access.privilege"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.default.access.privilege"
\di "no.such.database"."no.such.schema"."no.such.index.relation"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.index.relation"
\dm "no.such.database"."no.such.schema"."no.such.materialized.view"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.materialized.view"
\ds "no.such.database"."no.such.schema"."no.such.relation"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.relation"
\dt "no.such.database"."no.such.schema"."no.such.relation"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.relation"
\dv "no.such.database"."no.such.schema"."no.such.relation"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.relation"
\df "no.such.database"."no.such.schema"."no.such.function"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.function"
\dF "no.such.database"."no.such.schema"."no.such.text.search.configuration"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.text.search.configuration"
\dFd "no.such.database"."no.such.schema"."no.such.text.search.dictionary"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.text.search.dictionary"
\dFp "no.such.database"."no.such.schema"."no.such.text.search.parser"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.text.search.parser"
\dFt "no.such.database"."no.such.schema"."no.such.text.search.template"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.text.search.template"
\do "no.such.database"."no.such.schema"."no.such.operator"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.operator"
\dO "no.such.database"."no.such.schema"."no.such.collation"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.collation"
\dp "no.such.database"."no.such.schema"."no.such.access.privilege"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.access.privilege"
\dP "no.such.database"."no.such.schema"."no.such.partitioned.relation"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.partitioned.relation"
\dT "no.such.database"."no.such.schema"."no.such.data.type"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.data.type"
\dX "no.such.database"."no.such.schema"."no.such.extended.statistics"
cross-database references are not implemented: "no.such.database"."no.such.schema"."no.such.extended.statistics"
-- check \drg and \du
CREATE ROLE regress_du_role0;
CREATE ROLE regress_du_role1;
CREATE ROLE regress_du_role2;
CREATE ROLE regress_du_admin;
GRANT regress_du_role0 TO regress_du_admin WITH ADMIN TRUE;
GRANT regress_du_role1 TO regress_du_admin WITH ADMIN TRUE;
GRANT regress_du_role2 TO regress_du_admin WITH ADMIN TRUE;
GRANT regress_du_role0 TO regress_du_role1 WITH ADMIN TRUE,  INHERIT TRUE,  SET TRUE  GRANTED BY regress_du_admin;
GRANT regress_du_role0 TO regress_du_role2 WITH ADMIN TRUE,  INHERIT FALSE, SET FALSE GRANTED BY regress_du_admin;
GRANT regress_du_role1 TO regress_du_role2 WITH ADMIN TRUE , INHERIT FALSE, SET TRUE  GRANTED BY regress_du_admin;
GRANT regress_du_role0 TO regress_du_role1 WITH ADMIN FALSE, INHERIT TRUE,  SET FALSE GRANTED BY regress_du_role1;
GRANT regress_du_role0 TO regress_du_role2 WITH ADMIN FALSE, INHERIT TRUE , SET TRUE  GRANTED BY regress_du_role1;
GRANT regress_du_role0 TO regress_du_role1 WITH ADMIN FALSE, INHERIT FALSE, SET TRUE  GRANTED BY regress_du_role2;
GRANT regress_du_role0 TO regress_du_role2 WITH ADMIN FALSE, INHERIT FALSE, SET FALSE GRANTED BY regress_du_role2;
\drg regress_du_role*
                             List of role grants
    Role name     |    Member of     |       Options       |     Grantor      
------------------+------------------+---------------------+------------------
 regress_du_role1 | regress_du_role0 | ADMIN, INHERIT, SET | regress_du_admin
 regress_du_role1 | regress_du_role0 | INHERIT             | regress_du_role1
 regress_du_role1 | regress_du_role0 | SET                 | regress_du_role2
 regress_du_role2 | regress_du_role0 | ADMIN               | regress_du_admin
 regress_du_role2 | regress_du_role0 | INHERIT, SET        | regress_du_role1
 regress_du_role2 | regress_du_role0 |                     | regress_du_role2
 regress_du_role2 | regress_du_role1 | ADMIN, SET          | regress_du_admin
(7 rows)

\du regress_du_role*
          List of roles
    Role name     |  Attributes  
------------------+--------------
 regress_du_role0 | Cannot login
 regress_du_role1 | Cannot login
 regress_du_role2 | Cannot login

DROP ROLE regress_du_role0;
DROP ROLE regress_du_role1;
DROP ROLE regress_du_role2;
DROP ROLE regress_du_admin;
-- Test display of empty privileges.
BEGIN;
-- Create an owner for tested objects because output contains owner name.
CREATE ROLE regress_zeropriv_owner;
SET LOCAL ROLE regress_zeropriv_owner;
CREATE DOMAIN regress_zeropriv_domain AS int;
REVOKE ALL ON DOMAIN regress_zeropriv_domain FROM CURRENT_USER, PUBLIC;
\dD+ regress_zeropriv_domain
                                                    List of domains
 Schema |          Name           |  Type   | Collation | Nullable | Default | Check | Access privileges | Description 
--------+-------------------------+---------+-----------+----------+---------+-------+-------------------+-------------
 public | regress_zeropriv_domain | integer |           |          |         |       | (none)            | 
(1 row)

CREATE PROCEDURE regress_zeropriv_proc() LANGUAGE sql AS '';
REVOKE ALL ON PROCEDURE regress_zeropriv_proc() FROM CURRENT_USER, PUBLIC;
\df+ regress_zeropriv_proc
                                                                                                  List of functions
 Schema |         Name          | Result data type | Argument data types | Type | Volatility | Parallel |         Owner          | Security | Leakproof? | Access privileges | Language | Internal name | Description 
--------+-----------------------+------------------+---------------------+------+------------+----------+------------------------+----------+------------+-------------------+----------+---------------+-------------
 public | regress_zeropriv_proc |                  |                     | proc | volatile   | unsafe   | regress_zeropriv_owner | invoker  | no         | (none)            | sql      |               | 
(1 row)

CREATE TABLE regress_zeropriv_tbl (a int);
REVOKE ALL ON TABLE regress_zeropriv_tbl FROM CURRENT_USER;
\dp regress_zeropriv_tbl
                                    Access privileges
 Schema |         Name         | Type  | Access privileges | Column privileges | Policies 
--------+----------------------+-------+-------------------+-------------------+----------
 public | regress_zeropriv_tbl | table | (none)            |                   | 
(1 row)

CREATE TYPE regress_zeropriv_type AS (a int);
REVOKE ALL ON TYPE regress_zeropriv_type FROM CURRENT_USER, PUBLIC;
\dT+ regress_zeropriv_type
                                                          List of data types
 Schema |         Name          |     Internal name     | Size  | Elements |         Owner          | Access privileges | Description 
--------+-----------------------+-----------------------+-------+----------+------------------------+-------------------+-------------
 public | regress_zeropriv_type | regress_zeropriv_type | tuple |          | regress_zeropriv_owner | (none)            | 
(1 row)

ROLLBACK;
-- Test display of default privileges with \pset null.
CREATE TABLE defprivs (a int);
\pset null '(default)'
\z defprivs
                              Access privileges
 Schema |   Name   | Type  | Access privileges | Column privileges | Policies 
--------+----------+-------+-------------------+-------------------+----------
 public | defprivs | table | (default)         |                   | 
(1 row)

\zx defprivs
Access privileges
-[ RECORD 1 ]-----+----------
Schema            | public
Name              | defprivs
Type              | table
Access privileges | (default)
Column privileges | 
Policies          | 

\pset null ''
DROP TABLE defprivs;
