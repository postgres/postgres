<refentry id="SQL-CREATEFUNCTION">
 <refmeta>
  <refentrytitle>
   CREATE FUNCTION
  </refentrytitle>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
 <refnamediv>
  <refname>
   CREATE FUNCTION
  </refname>
  <refpurpose>
   Defines a new function
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <refsynopsisdivinfo>
   <date>1998-09-09</date>
  </refsynopsisdivinfo>
  <synopsis>
CREATE FUNCTION <replaceable class="parameter">name</replaceable> ( [ <replaceable class="parameter">ftype</replaceable> [, ...] ] )
    RETURNS <replaceable class="parameter">rtype</replaceable>
    AS <replaceable class="parameter">definition</replaceable>
    LANGUAGE '<replaceable class="parameter">langname</replaceable>'
  </synopsis>
  
  <refsect2 id="R2-SQL-CREATEFUNCTION-1">
   <refsect2info>
    <date>1998-09-09</date>
   </refsect2info>
   <title>
    Inputs
   </title>
   <para>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">name</replaceable></term>
      <listitem>
       <para>
	The name of a function to create.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><replaceable class="parameter">ftype</replaceable></term>
      <listitem>
       <para>
	The data type of function arguments.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><replaceable class="parameter">rtype</replaceable></term>
      <listitem>
       <para>
	The return data type.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><replaceable class="parameter">definition</replaceable></term>
      <listitem>
       <para>
	A string defining the function; the meaning depends on the language.
	It may be an internal function name, the path to an object file,
	an SQL query, or text in a procedural language.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><replaceable class="parameter">langname</replaceable></term>
      <listitem>
       <para>
	may be '<literal>C</literal>', '<literal>sql</literal>',
	'<literal>internal</literal>'
	or '<replaceable class="parameter">plname</replaceable>',
	where '<replaceable class="parameter">plname</replaceable>'
	is the name of a created procedural
	language. See <command>CREATE LANGUAGE</command> for details.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>

  <refsect2 id="R2-SQL-CREATEFUNCTION-2">
   <refsect2info>
    <date>1998-09-09</date>
   </refsect2info>
   <title>
    Outputs
   </title>
   <para>

    <variablelist>
     <varlistentry>
      <term><computeroutput>
CREATE
       </computeroutput></term>
      <listitem>
       <para>
	This is returned if the command completes successfully.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>
 </refsynopsisdiv>

 <refsect1 id="R1-SQL-CREATEFUNCTION-1">
  <refsect1info>
   <date>1998-09-09</date>
  </refsect1info>
  <title>
   Description
  </title>
  <para>
   <command>CREATE FUNCTION</command> allows a
   <productname>Postgres</productname> user
   to register a function
   with a database. Subsequently, this user is treated as the
   owner of the function.
  </para>
  
  <refsect2 id="R2-SQL-CREATEFUNCTION-3">
   <refsect2info>
    <date>1998-09-09</date>
   </refsect2info>
   <title>
    Notes
   </title>
   <para>
    Refer to the chapter on functions 
in the <citetitle>PostgreSQL Programmer's Guide</citetitle>
    for further information.
   </para>
   <para>
    Use <command>DROP FUNCTION</command>
    to drop user-defined functions.
   </para>

  <para>
   <productname>Postgres</productname> allows function "overloading";
   that is, the same name can be used for several different functions
   so long as they have distinct argument types.  This facility must be
   used with caution for INTERNAL and C-language functions, however.
  </para>

  <para>
   Two INTERNAL functions cannot have the same C name without causing
   errors at link time.  To get around that, give them different C names
   (for example, use the argument types as part of the C names), then
   specify those names in the AS clause of <command>CREATE FUNCTION</command>.
   If the AS clause is left empty then <command>CREATE FUNCTION</command>
   assumes the C name of the function is the same as the SQL name.
  </para>

  <para>
   For dynamically-loaded C functions, the SQL name of the function must
   be the same as the C function name, because the AS clause is used to
   give the path name of the object file containing the C code.  In this
   situation it is best not to try to overload SQL function names.  It
   might work to load a C function that has the same C name as an internal
   function or another dynamically-loaded function --- or it might not.
   On some platforms the dynamic loader may botch the load in interesting
   ways if there is a conflict of C function names.  So, even if it works
   for you today, you might regret overloading names later when you try
   to run the code somewhere else.
  </para>
  </refsect2>
 </refsect1>
  
 <refsect1 id="R1-SQL-CREATEFUNCTION-2">
  <title>
   Usage
  </title>
  <para>
   To create a simple SQL function:

  <programlisting>
CREATE FUNCTION one() RETURNS int4
    AS 'SELECT 1 AS RESULT'
    LANGUAGE 'sql';
SELECT one() AS answer;

   <computeroutput>
    answer 
    ------
    1
   </computeroutput>
  </programlisting>
  </para>

  <para>
   To create a C function, calling a routine from a user-created
   shared library.  This particular routine calculates a check
   digit and returns TRUE if the check digit in the function parameters
   is correct. It is intended for use in a CHECK contraint.
  </para>
  <programlisting>
   <userinput>
CREATE FUNCTION ean_checkdigit(bpchar, bpchar) RETURNS bool
    AS '/usr1/proj/bray/sql/funcs.so' LANGUAGE 'c';
    
CREATE TABLE product (
    id        char(8) PRIMARY KEY,
    eanprefix char(8) CHECK (eanprefix ~ '[0-9]{2}-[0-9]{5}')
                      REFERENCES brandname(ean_prefix),
    eancode   char(6) CHECK (eancode ~ '[0-9]{6}'),
    CONSTRAINT ean    CHECK (ean_checkdigit(eanprefix, eancode))
);
   </userinput>
  </programlisting>
 </refsect1>
 
 <refsect1 id="R1-SQL-CREATEFUNCTION-3">
  <title>
   Bugs
  </title>
  <para>
   A C function cannot return a set of values.
  </para>
 </refsect1>

 <refsect1 id="R1-SQL-CREATEFUNCTION-4">
  <title>
   Compatibility
  </title>
  <para>
   <command>CREATE FUNCTION</command> is
   a <productname>Postgres</productname> language extension.
   </para>

  <refsect2 id="R2-SQL-CREATEFUNCTION-4">
   <refsect2info>
    <date>1998-09-09</date>
   </refsect2info>
   <title>
    SQL/PSM
   </title>
   <para>

    <note>
     <para>
      PSM stands for Persistent Stored Modules. It is a procedural
      language and it was originally hoped that PSM would be ratified
      as an official standard by late 1996. As of mid-1998, this
      has not yet happened, but it is hoped that PSM will
      eventually become a standard.
     </para>
    </note>

    SQL/PSM <command>CREATE FUNCTION</command> has the following syntax:
    <synopsis>
CREATE FUNCTION <replaceable class="parameter">name</replaceable>
    ( [ [ IN | OUT | INOUT ] <replaceable class="parameter">eter</replaceable>eable>eable> <replaceable
      class="parameter">type</replaceable> [, ...] ] )
     RETURNS <replaceable class="parameter">rtype</replaceable>
     LANGUAGE '<replaceable class="parameter">langname</replaceable>'
     ESPECIFIC <replaceable class="parameter">routine</replaceable>
     <replaceable class="parameter">SQL-statement</replaceable>
    </synopsis>
   </para>
  </refsect2>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
