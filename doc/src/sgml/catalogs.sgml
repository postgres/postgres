<!--
 Documentation of the system catalogs, directed toward PostgreSQL developers
 $Header: /cvsroot/pgsql/doc/src/sgml/catalogs.sgml,v 2.65 2003/01/19 00:13:28 momjian Exp $
 -->

<chapter id="catalogs">
 <title>System Catalogs</title>

 <sect1 id="catalogs-overview">
  <title>Overview</title>

  <para>
   The system catalogs are the place where a relational database
   management system stores schema metadata, such as information about
   tables and columns, and internal bookkeeping information.
   <productname>PostgreSQL</productname>'s system catalogs are regular
   tables.  You can drop and recreate the tables, add columns, insert
   and update values, and severely mess up your system that way.
   Normally one should not change the system catalogs by hand, there
   are always SQL commands to do that.  (For example, <command>CREATE
   DATABASE</command> inserts a row into the
   <structname>pg_database</structname> catalog -- and actually
   creates the database on disk.)  There are some exceptions for
   especially esoteric operations, such as adding index access methods.
  </para>
  <para>
   Most system catalogs are copied from the template database during
   database creation, and are thereafter database-specific. A few
   catalogs are physically shared across all databases in an installation;
   these are marked in the descriptions of the individual catalogs.
  </para>

  <table>
   <title>System Catalogs</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Catalog Name</entry>
      <entry>Purpose</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="catalog-pg-aggregate">
       <database class="table">pg_aggregate</database></link></entry>
      <entry>aggregate functions</entry>
     </row>

     <row>
      <entry>pg_am</entry>
      <entry>index access methods</entry>
     </row>

     <row>
      <entry>pg_amop</entry>
      <entry>access method operators</entry>
     </row>

     <row>
      <entry>pg_amproc</entry>
      <entry>access method support procedures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attrdef">
       <database class="table">pg_attrdef</database></link></entry>
      <entry>column default values</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attribute">
       <database class="table">pg_attribute</database></link></entry>
      <entry>table columns (<quote>attributes</quote>, <quote>fields</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-cast">
       <database class="table">pg_cast</database></link></entry>
      <entry>casts (data type conversions)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-class">
       <database class="table">pg_class</database></link></entry>
      <entry>tables, indexes, sequences (<quote>relations</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-constraint">
       <database class="table">pg_constraint</database></link></entry>
      <entry>check constraints, unique / primary key constraints, foreign key constraints</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-conversion">
       <database class="table">pg_conversion</database></link></entry>
      <entry>encoding conversion information</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-database">
       <database class="table">pg_database</database></link></entry>
      <entry>databases within this database cluster</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-depend">
       <database class="table">pg_depend</database></link></entry>
      <entry>dependencies between database objects</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-description">
       <database class="table">pg_description</database></link></entry>
      <entry>descriptions or comments on database objects</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-group">
       <database class="table">pg_group</database></link></entry>
      <entry>groups of database users</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-index">
       <database class="table">pg_index</database></link></entry>
      <entry>additional index information</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-inherits">
       <database class="table">pg_inherits</database></link></entry>
      <entry>table inheritance hierarchy</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-language">
       <database class="table">pg_language</database></link></entry>
      <entry>languages for writing functions</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject">
       <database class="table">pg_largeobject</database></link></entry>
      <entry>large objects</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-listener">
       <database class="table">pg_listener</database></link></entry>
      <entry>asynchronous notification</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-namespace">
       <database class="table">pg_namespace</database></link></entry>
      <entry>namespaces (schemas)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opclass">
       <database class="table">pg_opclass</database></link></entry>
      <entry>index access method operator classes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-operator">
       <database class="table">pg_operator</database></link></entry>
      <entry>operators</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-proc">
       <database class="table">pg_proc</database></link></entry>
      <entry>functions and procedures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-rewrite">
       <database class="table">pg_rewrite</database></link></entry>
      <entry>query rewriter rules</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shadow">
       <database class="table">pg_shadow</database></link></entry>
      <entry>database users</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic">
       <database class="table">pg_statistic</database></link></entry>
      <entry>optimizer statistics</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-trigger">
       <database class="table">pg_trigger</database></link></entry>
      <entry>triggers</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-type">
       <database class="table">pg_type</database></link></entry>
      <entry>data types</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   More detailed documentation of each catalog follows below.
  </para>

 </sect1>


 <sect1 id="catalog-pg-aggregate">
  <title>pg_aggregate</title>

  <para>
   <structname>pg_aggregate</structname> stores information about
   aggregate functions.  An aggregate function is a function that
   operates on a set of values (typically one column from each row
   that matches a query condition) and returns a single value computed
   from all these values.  Typical aggregate functions are
   <function>sum</function>, <function>count</function>, and
   <function>max</function>.  Each entry in
   <structname>pg_aggregate</structname> is an extension of an entry
   in <structname>pg_proc</structname>.  The <structname>pg_proc</structname>
   entry carries the aggregate's name, input and output datatypes, and
   other information that is similar to ordinary functions.
  </para>

  <table>
   <title>pg_aggregate Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>aggfnoid</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>pg_proc OID of the aggregate function</entry>
     </row>
     <row>
      <entry>aggtransfn</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>Transition function</entry>
     </row>
     <row>
      <entry>aggfinalfn</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>Final function (zero if none)</entry>
     </row>
     <row>
      <entry>aggtranstype</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>The type of the aggregate function's internal transition (state) data</entry>
     </row>
     <row>
      <entry>agginitval</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       The initial value of the transition state.  This is a text
       field containing the initial value in its external string
       representation.  If the field is NULL, the transition state
       value starts out NULL.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   New aggregate functions are registered with the <command>CREATE
   AGGREGATE</command> command.  See the &cite-programmer; for more
   information about writing aggregate functions and the meaning of
   the transition functions, etc.
  </para>

 </sect1>


 <sect1 id="catalog-pg-am">
  <title>pg_am</title>

  <para>
   <structname>pg_am</structname> stores information about index access
   methods.  There is one row for each index access method supported by
   the system.
  </para>

  <table>
   <title>pg_am Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry>amname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>name of the access method</entry>
     </row>

     <row>
      <entry>amowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>user ID of the owner (currently not used)</entry>
     </row>

     <row>
      <entry>amstrategies</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>number of operator strategies for this access method</entry>
     </row>

     <row>
      <entry>amsupport</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>number of support routines for this access method</entry>
     </row>

     <row>
      <entry>amorderstrategy</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>zero if the index offers no sort order, otherwise the strategy
      number of the strategy operator that describes the sort order</entry>
     </row>

     <row>
      <entry>amcanunique</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>does AM support unique indexes?</entry>
     </row>

     <row>
      <entry>amcanmulticol</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>does AM support multicolumn indexes?</entry>
     </row>

     <row>
      <entry>amindexnulls</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>does AM support NULL index entries?</entry>
     </row>

     <row>
      <entry>amconcurrent</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>does AM support concurrent updates?</entry>
     </row>

     <row>
      <entry>amgettuple</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry><quote>next valid tuple</quote> function</entry>
     </row>

     <row>
      <entry>aminsert</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry><quote>insert this tuple</quote> function</entry>
     </row>

     <row>
      <entry>ambeginscan</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry><quote>start new scan</quote> function</entry>
     </row>

     <row>
      <entry>amrescan</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry><quote>restart this scan</quote> function</entry>
     </row>

     <row>
      <entry>amendscan</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry><quote>end this scan</quote> function</entry>
     </row>

     <row>
      <entry>ammarkpos</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry><quote>mark current scan position</quote> function</entry>
     </row>

     <row>
      <entry>amrestrpos</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry><quote>restore marked scan position</quote> function</entry>
     </row>

     <row>
      <entry>ambuild</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry><quote>build new index</quote> function</entry>
     </row>

     <row>
      <entry>ambulkdelete</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>bulk-delete function</entry>
     </row>

     <row>
      <entry>amcostestimate</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>estimate cost of an indexscan</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

   <para>
    An index AM that supports multiple columns (has
    <structfield>amcanmulticol</structfield> true) <emphasis>must</>
    support indexing nulls in columns after the first, because the planner
    will assume the index can be used for queries on just the first
    column(s).  For example, consider an index on (a,b) and a query
    WHERE a = 4.  The system will assume the index can be used to scan for
    rows with a = 4, which is wrong if the index omits rows where b is null.
    However it is okay to omit rows where the first indexed column is null.
    (GiST currently does so.)
    <structfield>amindexnulls</structfield> should be set true only if the
    index AM indexes all rows, including arbitrary combinations of nulls.
   </para>

 </sect1>


 <sect1 id="catalog-pg-amop">
  <title>pg_amop</title>

  <para>
   <structname>pg_amop</structname> stores information about operators
   associated with index access method operator classes.  There is one
   row for each operator that is a member of an operator class.
  </para>

  <table>
   <title>pg_amop Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry>amopclaid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_opclass.oid</entry>
      <entry>the index opclass this entry is for</entry>
     </row>

     <row>
      <entry>amopstrategy</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>operator strategy number</entry>
     </row>

     <row>
      <entry>amopreqcheck</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>index hit must be rechecked</entry>
     </row>

     <row>
      <entry>amopopr</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>the operator's pg_operator OID</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-amproc">
  <title>pg_amproc</title>

  <para>
   <structname>pg_amproc</structname> stores information about support
   procedures
   associated with index access method operator classes.  There is one
   row for each support procedure belonging to an operator class.
  </para>

  <table>
   <title>pg_amproc Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry>amopclaid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_opclass.oid</entry>
      <entry>the index opclass this entry is for</entry>
     </row>

     <row>
      <entry>amprocnum</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>support procedure index</entry>
     </row>

     <row>
      <entry>amproc</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>OID of the proc</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
  <title>pg_attrdef</title>

  <para>
   This catalog stores column default values.  The main information
   about columns is stored in <structname>pg_attribute</structname>
   (see below).  Only columns that explicitly specify a default value
   (when the table is created or the column is added) will have an
   entry here.
  </para>

  <table>
   <title>pg_attrdef Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>adrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table this column belongs to</entry>
     </row>

     <row>
      <entry>adnum</entry>
      <entry><type>int2</type></entry>
      <entry>pg_attribute.attnum</entry>
      <entry>The number of the column</entry>
     </row>

     <row>
      <entry>adbin</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>An internal representation of the column default value</entry>
     </row>

     <row>
      <entry>adsrc</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>A human-readable representation of the default value</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-attribute">
  <title>pg_attribute</title>

  <para>
   <structname>pg_attribute</structname> stores information about
   table columns.  There will be exactly one
   <structname>pg_attribute</structname> row for every column in every
   table in the database.  (There will also be attribute entries for
   indexes and other objects.  See <structname>pg_class</structname>.)
  </para>

  <para>
   The term attribute is equivalent to column and is used for
   historical reasons.
  </para>

  <table>
   <title>pg_attribute Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>attrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table this column belongs to</entry>
     </row>

     <row>
      <entry>attname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Column name</entry>
     </row>

     <row>
      <entry>atttypid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>The data type of this column</entry>
     </row>

     <row>
      <entry>attstattarget</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>attstattarget</structfield> controls the level of detail
       of statistics accumulated for this column by
       <command>ANALYZE</command>.
       A zero value indicates that no statistics should be collected.
       A negative value says to use the system default statistics target.
       The exact meaning of positive values is datatype-dependent.
       For scalar datatypes, <structfield>attstattarget</structfield>
       is both the target number of <quote>most common values</quote>
       to collect, and the target number of histogram bins to create.
      </entry>
     </row>

     <row>
      <entry>attlen</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       This is a copy of
       <structname>pg_type</structname>.<structfield>typlen</structfield>
       of this column's type.
      </entry>
     </row>

     <row>
      <entry>attnum</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       The number of the column.  Ordinary columns are numbered from 1
       up.  System columns, such as <structfield>oid</structfield>,
       have (arbitrary) negative numbers.
      </entry>
     </row>

     <row>
      <entry>attndims</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Number of dimensions, if the column is an array type; otherwise 0.
       (Presently, the number of dimensions of an array is not enforced,
       so any nonzero value effectively means <quote>it's an array</>.)
      </entry>
     </row>

     <row>
      <entry>attcacheoff</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Always -1 in storage, but when loaded into a tuple descriptor
       in memory this may be updated to cache the offset of the attribute
       within the tuple.
      </entry>
     </row>

     <row>
      <entry>atttypmod</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>atttypmod</structfield> records type-specific data
       supplied at table creation time (for example, the maximum
       length of a <type>varchar</type> column).  It is passed to
       type-specific input functions and length coercion functions.
       The value will generally be -1 for types that do not need typmod.
      </entry>
     </row>

     <row>
      <entry>attbyval</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       A copy of
       <structname>pg_type</structname>.<structfield>typbyval</structfield>
       of this column's type
      </entry>
     </row>

     <row>
      <entry>attstorage</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Normally a copy of
       <structname>pg_type</structname>.<structfield>typstorage</structfield>
       of this column's type.  For TOASTable datatypes, this can be altered
       after column creation to control storage policy.
      </entry>
     </row>

     <row>
      <entry>attisset</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true, this attribute is a set.  In that case, what is really
       stored in the attribute is the OID of a tuple in the
       <structname>pg_proc</structname> catalog.  The
       <structname>pg_proc</structname> tuple contains the query
       string that defines this set - i.e., the query to run to get
       the set.  So the <structfield>atttypid</structfield> (see
       above) refers to the type returned by this query, but the
       actual length of this attribute is the length (size) of an
       <type>oid</type>.  --- At least this is the theory.  All this
       is probably quite broken these days.
      </entry>
     </row>

     <row>
      <entry>attalign</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A copy of
       <structname>pg_type</structname>.<structfield>typalign</structfield>
       of this column's type
      </entry>
     </row>

     <row>
      <entry>attnotnull</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This represents a NOT NULL constraint.  It is possible to
       change this field to enable or disable the constraint.
      </entry>
     </row>

     <row>
      <entry>atthasdef</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column has a default value, in which case there will be a
       corresponding entry in the <structname>pg_attrdef</structname>
       catalog that actually defines the value.
      </entry>
     </row>

     <row>
      <entry>attisdropped</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column has been dropped and is no longer valid.  A dropped
       column is still physically present in the table, but is
       ignored by the parser and so cannot be accessed via SQL.
      </entry>
     </row>

     <row>
      <entry>attislocal</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column is defined locally in the relation.  Note that a column may
       be locally defined and inherited simultaneously.
      </entry>
     </row>

     <row>
      <entry>attinhcount</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       The number of direct ancestors this column has.  A column with a 
       nonzero number of ancestors cannot be dropped nor renamed.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-cast">
  <title>pg_cast</title>

  <para>
   <structname>pg_cast</structname> stores data type conversion paths,
   both built-in paths and those defined with <command>CREATE CAST</command>.
  </para>

  <table>
   <title>pg_cast Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>castsource</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>OID of the source data type</entry>
     </row>

     <row>
      <entry>casttarget</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>OID of the target data type</entry>
     </row>

     <row>
      <entry>castfunc</entry>
      <entry><type>oid</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>
       The OID of the function to use to perform this cast.  Zero is
       stored if the data types are binary coercible (that is, no
       run-time operation is needed to perform the cast).
      </entry>
     </row>

     <row>
      <entry>castcontext</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Indicates what contexts the cast may be invoked in.
       <literal>e</> means only as an explicit cast (using
       <literal>CAST</>, <literal>::</>, or function-call syntax).
       <literal>a</> means implicitly in assignment
       to a target column, as well as explicitly.
       <literal>i</> means implicitly in expressions, as well as the
       other cases.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-class">
  <title>pg_class</title>

  <para>
   <structname>pg_class</structname> catalogs tables and most
   everything else that has columns or is otherwise similar to a
   table.  This includes indexes (but see also
   <structname>pg_index</structname>), sequences, views, and some
   kinds of special relation; see <structfield>relkind</>.
   Below, when we mean all of these
   kinds of objects we speak of <quote>relations</quote>.  Not all
   fields are meaningful for all relation types.
  </para>

  <table>
   <title>pg_class Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>relname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the table, index, view, etc.</entry>
     </row>

     <row>
      <entry>relnamespace</entry>
      <entry><type>oid</type></entry>
      <entry>pg_namespace.oid</entry>
      <entry>
       The OID of the namespace that contains this relation
      </entry>
     </row>

     <row>
      <entry>reltype</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>
       The OID of the data type that corresponds to this table, if any
       (zero for indexes, which have no pg_type entry)
      </entry>
     </row>

     <row>
      <entry>relowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner of the relation</entry>
     </row>

     <row>
      <entry>relam</entry>
      <entry><type>oid</type></entry>
      <entry>pg_am.oid</entry>
      <entry>If this is an index, the access method used (B-tree, hash, etc.)</entry>
     </row>

     <row>
      <entry>relfilenode</entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Name of the on-disk file of this relation; 0 if none</entry>
     </row>

     <row>
      <entry>relpages</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Size of the on-disk representation of this table in pages (size
       <symbol>BLCKSZ</symbol>).
       This is only an estimate used by the planner.
       It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and <command>CREATE INDEX</command>.
      </entry>
     </row>

     <row>
      <entry>reltuples</entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
       Number of tuples in the table.
       This is only an estimate used by the planner.
       It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and <command>CREATE INDEX</command>.
      </entry>
     </row>

     <row>
      <entry>reltoastrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>
       OID of the TOAST table associated with this table, 0 if none.
       The TOAST table stores large attributes <quote>out of
       line</quote> in a secondary table.
      </entry>
     </row>

     <row>
      <entry>reltoastidxid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>
       For a TOAST table, the OID of its index.  0 if not a TOAST table.
      </entry>
     </row>

     <row>
      <entry>relhasindex</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if this is a table and it has (or recently had) any
       indexes. This is set by <command>CREATE INDEX</command>, but
       not cleared immediately by <command>DROP INDEX</command>.
       <command>VACUUM</command> clears relhasindex if it finds the
       table has no indexes.
      </entry>
     </row>

     <row>
      <entry>relisshared</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if this table is shared across all databases in the
      cluster.  Only certain system catalogs (such as
      <structname>pg_database</structname>) are shared.</entry>
     </row>

     <row>
      <entry>relkind</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       'r' = ordinary table, 'i' = index, 'S' = sequence, 'v' = view,
       'c' = composite type, 's' = special, 't' = TOAST table
      </entry>
     </row>

     <row>
      <entry>relnatts</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of user columns in the relation (system columns not counted).
       There must be this many corresponding entries in
       <structname>pg_attribute</structname>.  See also
       <structname>pg_attribute</structname>.<structfield>attnum</structfield>.
      </entry>
     </row>

     <row>
      <entry>relchecks</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of check constraints on the table; see
       <structname>pg_constraint</structname> catalog
      </entry>
     </row>

     <row>
      <entry>reltriggers</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of triggers on the table; see
       <structname>pg_trigger</structname> catalog
      </entry>
     </row>

     <row>
      <entry>relukeys</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>unused  (<emphasis>Not</emphasis> the number of unique keys)</entry>
     </row>

     <row>
      <entry>relfkeys</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>unused  (<emphasis>Not</emphasis> the number of foreign keys on the table)</entry>
     </row>

     <row>
      <entry>relrefs</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>unused</entry>
     </row>

     <row>
      <entry>relhasoids</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if we generate an OID for each row of the relation.
      </entry>
     </row>

     <row>
      <entry>relhaspkey</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if the table has (or once had) a primary key.
      </entry>
     </row>

     <row>
      <entry>relhasrules</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Table has rules; see
       <structname>pg_rewrite</structname> catalog
      </entry>
     </row>

     <row>
      <entry>relhassubclass</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>At least one table inherits from this one</entry>
     </row>

     <row>
      <entry>relacl</entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access permissions.  See the descriptions of
       <command>GRANT</command> and <command>REVOKE</command> for
       details.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-constraint">
  <title>pg_constraint</title>

  <para>
   This system catalog stores CHECK, PRIMARY KEY, UNIQUE, and FOREIGN KEY
   constraints on tables.  (Column
   constraints are not treated specially.  Every column constraint is
   equivalent to some table constraint.)  See under <command>CREATE
   TABLE</command> for more information.
  </para>

  <note>
   <para>
    NOT NULL constraints are represented in the <structname>pg_attribute</>
    catalog.
   </para>
  </note>

  <para>
   CHECK constraints on domains are stored here, too.  Global ASSERTIONS
   (a currently-unsupported SQL feature) may someday appear here as well.
  </para>

  <table>
   <title>pg_constraint Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>conname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Constraint name (not necessarily unique!)</entry>
     </row>

     <row>
      <entry>connamespace</entry>
      <entry><type>oid</type></entry>
      <entry>pg_namespace.oid</entry>
      <entry>
       The OID of the namespace that contains this constraint
      </entry>
     </row>

     <row>
      <entry>contype</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
        'c' = check constraint,
        'f' = foreign key constraint,
        'p' = primary key constraint,
        'u' = unique constraint
      </entry>
     </row>

     <row>
      <entry>condeferrable</entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>Is the constraint deferrable?</entry>
     </row>

     <row>
      <entry>condeferred</entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>Is the constraint deferred by default?</entry>
     </row>

     <row>
      <entry>conrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table this constraint is on; 0 if not a table constraint</entry>
     </row>

     <row>
      <entry>contypid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>The domain this constraint is on; 0 if not a domain constraint</entry>
     </row>

     <row>
      <entry>confrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>If a foreign key, the referenced table; else 0</entry>
     </row>

     <row>
      <entry>confupdtype</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Foreign key update action code</entry>
     </row>

     <row>
      <entry>confdeltype</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Foreign key deletion action code</entry>
     </row>

     <row>
      <entry>confmatchtype</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Foreign key match type</entry>
     </row>

     <row>
      <entry>conkey</entry>
      <entry><type>int2[]</type></entry>
      <entry>pg_attribute.attnum</entry>
      <entry>If a table constraint, list of columns which the constraint constrains</entry>
     </row>

     <row>
      <entry>confkey</entry>
      <entry><type>int2[]</type></entry>
      <entry>pg_attribute.attnum</entry>
      <entry>If a foreign key, list of the referenced columns</entry>
     </row>

     <row>
      <entry>conbin</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>If a check constraint, an internal representation of the expression</entry>
     </row>

     <row>
      <entry>consrc</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>If a check constraint, a human-readable representation of the expression</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <structname>pg_class</structname>.<structfield>relchecks</structfield>
    needs to agree with the number of check-constraint entries found in this
    table for the given relation.
   </para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-conversion">
  <title>pg_conversion</title>

  <para>
   This system catalog stores encoding conversion information. See
   <command>CREATE CONVERSION</command> for more information.
  </para>

  <table>
   <title>pg_conversion Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>conname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Conversion name (unique within a namespace)</entry>
     </row>

     <row>
      <entry>connamespace</entry>
      <entry><type>oid</type></entry>
      <entry>pg_namespace.oid</entry>
      <entry>
       The OID of the namespace that contains this conversion
      </entry>
     </row>

     <row>
      <entry>conowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner (creator) of the namespace</entry>
     </row>

     <row>
      <entry>conforencoding</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Source(for) encoding ID</entry>
     </row>

     <row>
      <entry>contoencoding</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Destination(to) encoding ID</entry>
     </row>

     <row>
      <entry>conproc</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>Conversion procedure</entry>
     </row>

     <row>
      <entry>condefault</entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>true if this is the default conversion</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-database">
  <title>pg_database</title>

  <para>
   The <structname>pg_database</structname> catalog stores information
   about the available databases.  Databases are created with the
   <command>CREATE DATABASE</command> command.  Consult the
   &cite-admin; for details about the meaning of some of the
   parameters.
  </para>

  <para>
   Unlike most system catalogs, <structname>pg_database</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_database</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title>pg_database Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>datname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Database name</entry>
     </row>

     <row>
      <entry>datdba</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner of the database, usually the user who created it</entry>
     </row>

     <row>
      <entry>encoding</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Character/multibyte encoding for this database</entry>
     </row>

     <row>
      <entry>datistemplate</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true then this database can be used in the
       <quote>TEMPLATE</quote> clause of <command>CREATE
       DATABASE</command> to create a new database as a clone of
       this one.
      </entry>
     </row>

     <row>
      <entry>datallowconn</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If false then no one can connect to this database.  This is
       used to protect the template0 database from being altered.
      </entry>
     </row>

     <row>
      <entry>datlastsysoid</entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>
       Last system OID in the database; useful
       particularly to <application>pg_dump</application>
      </entry>
     </row>

     <row>
      <entry>datvacuumxid</entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       All tuples inserted or deleted by transaction IDs before this one
       have been marked as known committed or known aborted in this database.
       This is used to determine when commit-log space can be recycled.
      </entry>
     </row>

     <row>
      <entry>datfrozenxid</entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       All tuples inserted by transaction IDs before this one have been
       relabeled with a permanent (<quote>frozen</>) transaction ID in this
       database.  This is useful to check whether a database must be vacuumed
       soon to avoid transaction ID wraparound problems.
      </entry>
     </row>

     <row>
      <entry>datpath</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       If the database is stored at an alternative location then this
       records the location.  It's either an environment variable name
       or an absolute path, depending how it was entered.
      </entry>
     </row>

     <row>
      <entry>datconfig</entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Session defaults for run-time configuration variables</entry>
     </row>

     <row>
      <entry>datacl</entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Access permissions</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-depend">
  <title>pg_depend</title>

  <para>
   The <structname>pg_depend</structname> table records the dependency
   relationships between database objects.  This information allows
   <command>DROP</> commands to find which other objects must be dropped
   by <command>DROP CASCADE</>, or prevent dropping in the <command>DROP
   RESTRICT</> case.
  </para>

  <table>
   <title>pg_depend Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>classid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The oid of the system catalog the dependent object is in</entry>
     </row>

     <row>
      <entry>objid</entry>
      <entry><type>oid</type></entry>
      <entry>any oid attribute</entry>
      <entry>The oid of the specific dependent object</entry>
     </row>

     <row>
      <entry>objsubid</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>For a table attribute, this is the attribute's
       column number (the objid and classid refer to the table itself).
       For all other object types, this field is presently zero.
      </entry>
     </row>

     <row>
      <entry>refclassid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The oid of the system catalog the referenced object is in</entry>
     </row>

     <row>
      <entry>refobjid</entry>
      <entry><type>oid</type></entry>
      <entry>any oid attribute</entry>
      <entry>The oid of the specific referenced object</entry>
     </row>

     <row>
      <entry>refobjsubid</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>For a table attribute, this is the attribute's
       column number (the refobjid and refclassid refer to the table itself).
       For all other object types, this field is presently zero.
      </entry>
     </row>

     <row>
      <entry>deptype</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A code defining the specific semantics of this dependency relationship.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   In all cases, a <structname>pg_depend</structname> entry indicates that the
   referenced object may not be dropped without also dropping the dependent
   object.  However, there are several subflavors identified by
   <structfield>deptype</>:

   <itemizedlist>
    <listitem>
     <para>
      DEPENDENCY_NORMAL ('n'): normal relationship between separately-created
      objects.  The dependent object may be dropped without affecting the
      referenced object.  The referenced object may only be dropped by
      specifying CASCADE, in which case the dependent object is dropped too.
      Example: a table column has a normal dependency on its datatype.
     </para>
    </listitem>

    <listitem>
     <para>
      DEPENDENCY_AUTO ('a'): the dependent object can be dropped separately
      from the referenced object, and should be automatically dropped
      (regardless of RESTRICT or CASCADE mode) if the referenced object
      is dropped.
      Example: a named constraint on a table is made auto-dependent on
      the table, so that it will go away if the table is dropped.
     </para>
    </listitem>

    <listitem>
     <para>
      DEPENDENCY_INTERNAL ('i'): the dependent object was created as part
      of creation of the referenced object, and is really just a part of
      its internal implementation.  A DROP of the dependent object will be
      disallowed outright (we'll tell the user to issue a DROP against the
      referenced object, instead).  A DROP of the referenced object will be
      propagated through to drop the dependent object whether CASCADE is
      specified or not.
      Example: a trigger that's created to enforce a foreign-key constraint
      is made internally dependent on the constraint's pg_constraint entry.
     </para>
    </listitem>

    <listitem>
     <para>
      DEPENDENCY_PIN ('p'): there is no dependent object; this type of entry
      is a signal that the system itself depends on the referenced object,
      and so that object must never be deleted.  Entries of this type are
      created only during initdb.  The fields for the dependent object
      contain zeroes.
     </para>
    </listitem>
   </itemizedlist>

   Other dependency flavors may be needed in future.
  </para>

 </sect1>


 <sect1 id="catalog-pg-description">
  <title>pg_description</title>

  <para>
   The pg_description table can store an optional description or
   comment for each database object.  Descriptions can be manipulated
   with the <command>COMMENT</command> command and viewed with
   <application>psql</application>'s <literal>\d</literal> commands.
   Descriptions of many built-in system objects are provided in the initial
   contents of pg_description.
  </para>

  <table>
   <title>pg_description Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>objoid</entry>
      <entry><type>oid</type></entry>
      <entry>any oid attribute</entry>
      <entry>The oid of the object this description pertains to</entry>
     </row>

     <row>
      <entry>classoid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The oid of the system catalog this object appears in</entry>
     </row>

     <row>
      <entry>objsubid</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>For a comment on a table attribute, this is the attribute's
       column number (the objoid and classoid refer to the table itself).
       For all other object types, this field is presently zero.
      </entry>
     </row>

     <row>
      <entry>description</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Arbitrary text that serves as the description of this object.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-group">
  <title>pg_group</title>

  <para>
   This catalog defines groups and stores what users belong to what
   groups.  Groups are created with the <command>CREATE
   GROUP</command> command.  Consult the &cite-admin; for information
   about user permission management.
  </para>

  <para>
   Because user and group identities are cluster-wide,
   <structname>pg_group</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_group</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title>pg_group Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>groname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the group</entry>
     </row>

     <row>
      <entry>grosysid</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>An arbitrary number to identify this group</entry>
     </row>

     <row>
      <entry>grolist</entry>
      <entry><type>int4[]</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>An array containing the ids of the users in this group</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-index">
  <title>pg_index</title>

  <para>
   <structname>pg_index</structname> contains part of the information
   about indexes.  The rest is mostly in
   <structname>pg_class</structname>.
  </para>

  <table>
   <title>pg_index Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>indexrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The OID of the pg_class entry for this index</entry>
     </row>

     <row>
      <entry>indrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The OID of the pg_class entry for the table this index is for</entry>
     </row>

     <row>
      <entry>indproc</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>The function's OID if this is a functional index,
      else zero</entry>
     </row>

     <row>
      <entry>indkey</entry>
      <entry><type>int2vector</type></entry>
      <entry>pg_attribute.attnum</entry>
      <entry>
       This is a vector (array) of up to
       <symbol>INDEX_MAX_KEYS</symbol> values that indicate which
       table columns this index pertains to.  For example a value of
       <literal>1 3</literal> would mean that the first and the third
       column make up the index key.  For a functional index, these
       columns are the inputs to the function, and the function's return
       value is the index key.
      </entry>
     </row>

     <row>
      <entry>indclass</entry>
      <entry><type>oidvector</type></entry>
      <entry>pg_opclass.oid</entry>
      <entry>
       For each column in the index key this contains a reference to
       the <quote>operator class</quote> to use.  See
       <structname>pg_opclass</structname> for details.
      </entry>
     </row>

     <row>
      <entry>indisclustered</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, the table was last clustered on this index.</entry>
     </row>

     <row>
      <entry>indisunique</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this is a unique index.</entry>
     </row>

     <row>
      <entry>indisprimary</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this index represents the primary key of the table.
      (indisunique should always be true when this is true.)</entry>
     </row>

     <row>
      <entry>indreference</entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>unused</entry>
     </row>

     <row>
      <entry>indpred</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Expression tree (in the form of a nodeToString representation)
      for partial index predicate.  Empty string if not a partial
      index.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
  <title>pg_inherits</title>

  <para>
   This catalog records information about table inheritance hierarchies.
  </para>

  <table>
   <title>pg_inherits Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>inhrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>
       The OID of the child table.
      </entry>
     </row>

     <row>
      <entry>inhparent</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>
       The OID of the parent table.
      </entry>
     </row>

     <row>
      <entry>inhseqno</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       If there is more than one parent for a child table (multiple
       inheritance), this number tells the order in which the
       inherited columns are to be arranged.  The count starts at 1.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-language">
  <title>pg_language</title>

  <para>
   <structname>pg_language</structname> registers call interfaces or
   languages in which you can write functions or stored procedures.
   See under <command>CREATE LANGUAGE</command> and in the
   &cite-programmer; for more information about language handlers.
  </para>

  <table>
   <title>pg_language Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>lanname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the language (to be specified when creating a function)</entry>
     </row>

     <row>
      <entry>lanispl</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This is false for internal languages (such as
       <acronym>SQL</acronym>) and true for user-defined languages.
       Currently, <application>pg_dump</application> still uses this
       to determine which languages need to be dumped, but this may be
       replaced by a different mechanism sometime.
      </entry>
     </row>

     <row>
      <entry>lanpltrusted</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This is a trusted language.  See under <command>CREATE
       LANGUAGE</command> what this means.  If this is an internal
       language (<structfield>lanispl</structfield> is false) then
       this field is meaningless.
      </entry>
     </row>

     <row>
      <entry>lanplcallfoid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>
       For non-internal languages this references the language
       handler, which is a special function that is responsible for
       executing all functions that are written in the particular
       language.
      </entry>
     </row>

     <row>
      <entry>lanvalidator</entry>
      <entry><type>oid</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>
       This references a language validator function that is responsible
       for checking the syntax and validity of new functions when they
       are created. See under <command>CREATE LANGUAGE</command> for
       further information about validators.
      </entry>
     </row>

     <row>
      <entry>lanacl</entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Access permissions</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
  <title>pg_largeobject</title>

  <para>
   <structname>pg_largeobject</structname> holds the data making up
   <quote>large objects</quote>.  A large object is identified by an
   OID assigned when it is created.  Each large object is broken into
   segments or <quote>pages</> small enough to be conveniently stored as rows
   in <structname>pg_largeobject</structname>.
   The amount of data per page is defined to be LOBLKSIZE (which is currently
   BLCKSZ/4, or typically 2Kbytes).
  </para>

  <table>
   <title>pg_largeobject Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>loid</entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Identifier of the large object that includes this page</entry>
     </row>

     <row>
      <entry>pageno</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Page number of this page within its large object
      (counting from zero)</entry>
     </row>

     <row>
      <entry>data</entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       Actual data stored in the large object.
       This will never be more than LOBLKSIZE bytes, and may be less.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Each row of <structname>pg_largeobject</structname> holds data
   for one page of a large object, beginning at
   byte offset (pageno * LOBLKSIZE) within the object.  The implementation
   allows sparse storage: pages may be missing, and may be shorter than
   LOBLKSIZE bytes even if they are not the last page of the object.
   Missing regions within a large object read as zeroes.
  </para>

 </sect1>


 <sect1 id="catalog-pg-listener">
  <title>pg_listener</title>

  <para>
   <structname>pg_listener</structname> supports the <command>LISTEN</>
   and <command>NOTIFY</> commands.  A listener creates an entry in
   <structname>pg_listener</structname> for each notification name
   it is listening for.  A notifier scans <structname>pg_listener</structname>
   and updates each matching entry to show that a notification has occurred.
   The notifier also sends a signal (using the PID recorded in the table)
   to awaken the listener from sleep.
  </para>

  <table>
   <title>pg_listener Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>relname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Notify condition name.  (The name need not match any actual
      relation in the database; the term <quote>relname</> is historical.)
      </entry>
     </row>

     <row>
      <entry>listenerpid</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>PID of the backend process that created this entry.</entry>
     </row>

     <row>
      <entry>notification</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Zero if no event is pending for this listener.  If an event is
       pending, the PID of the backend that sent the notification.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-namespace">
  <title>pg_namespace</title>

  <para>
   A namespace is the structure underlying SQL92 schemas: each namespace
   can have a separate collection of relations, types, etc without name
   conflicts.
  </para>

  <table>
   <title>pg_namespace Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>nspname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the namespace</entry>
     </row>

     <row>
      <entry>nspowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner (creator) of the namespace</entry>
     </row>

     <row>
      <entry>nspacl</entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Access permissions</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-opclass">
  <title>pg_opclass</title>

  <para>
   <structname>pg_opclass</structname> defines
   index access method operator classes.  Each operator class defines
   semantics for index columns of a particular datatype and a particular
   index access method.  Note that there can be multiple operator classes
   for a given datatype/access method combination, thus supporting multiple
   behaviors.
  </para>

  <para>
   Operator classes are described at length in the &cite-programmer;.
  </para>

  <table>
   <title>pg_opclass Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry>opcamid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_am.oid</entry>
      <entry>index access method opclass is for</entry>
     </row>

     <row>
      <entry>opcname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>name of this opclass</entry>
     </row>

     <row>
      <entry>opcnamespace</entry>
      <entry><type>oid</type></entry>
      <entry>pg_namespace.oid</entry>
      <entry>namespace of this opclass</entry>
     </row>

     <row>
      <entry>opcowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>opclass owner</entry>
     </row>

     <row>
      <entry>opcintype</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>type of input data for opclass</entry>
     </row>

     <row>
      <entry>opcdefault</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>true if opclass is default for opcintype</entry>
     </row>

     <row>
      <entry>opckeytype</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>type of index data, or zero if same as opcintype</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   The majority of the information defining an operator class is actually
   not in its <structname>pg_opclass</structname> row, but in the associated
   rows in <structname>pg_amop</structname> and
   <structname>pg_amproc</structname>.  Those rows are considered to be
   part of the operator class definition --- this is not unlike the way
   that a relation is defined by a single <structname>pg_class</structname>
   row, plus associated rows in <structname>pg_attribute</structname> and
   other tables.
  </para>

 </sect1>


 <sect1 id="catalog-pg-operator">
  <title>pg_operator</title>

  <para>
   See <command>CREATE OPERATOR</command> and the &cite-programmer;
   for details on these operator parameters.
  </para>

  <table>
   <title>pg_operator Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>oprname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the operator</entry>
     </row>

     <row>
      <entry>oprnamespace</entry>
      <entry><type>oid</type></entry>
      <entry>pg_namespace.oid</entry>
      <entry>
       The OID of the namespace that contains this operator
      </entry>
     </row>

     <row>
      <entry>oprowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner (creator) of the operator</entry>
     </row>

     <row>
      <entry>oprkind</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       'b' = infix (<quote>both</quote>), 'l' = prefix
       (<quote>left</quote>), 'r' = postfix (<quote>right</quote>)
      </entry>
     </row>

     <row>
      <entry>oprcanhash</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>This operator supports hash joins.</entry>
     </row>

     <row>
      <entry>oprleft</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>Type of the left operand</entry>
     </row>

     <row>
      <entry>oprright</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>Type of the right operand</entry>
     </row>

     <row>
      <entry>oprresult</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>Type of the result</entry>
     </row>

     <row>
      <entry>oprcom</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>Commutator of this operator, if any</entry>
     </row>

     <row>
      <entry>oprnegate</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>Negator of this operator, if any</entry>
     </row>

     <row>
      <entry>oprlsortop</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>
       If this operator supports merge joins, the operator that sorts
       the type of the left-hand operand (<literal>L&lt;L</>)
      </entry>
     </row>

     <row>
      <entry>oprrsortop</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>
       If this operator supports merge joins, the operator that sorts
       the type of the right-hand operand (<literal>R&lt;R</>)
      </entry>
     </row>

     <row>
      <entry>oprltcmpop</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>
       If this operator supports merge joins, the less-than operator that
       compares the left and right operand types (<literal>L&lt;R</>)
      </entry>
     </row>

     <row>
      <entry>oprgtcmpop</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>
       If this operator supports merge joins, the greater-than operator that
       compares the left and right operand types (<literal>L&gt;R</>)
      </entry>
     </row>

     <row>
      <entry>oprcode</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>Function that implements this operator</entry>
     </row>

     <row>
      <entry>oprrest</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>Restriction selectivity estimation function for this operator</entry>
     </row>

     <row>
      <entry>oprjoin</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>Join selectivity estimation function for this operator</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Unused fields contain zeroes, for example oprleft is zero for a
   prefix operator.
  </para>

 </sect1>


 <sect1 id="catalog-pg-proc">
  <title>pg_proc</title>

  <para>
   This catalog stores information about functions (or procedures).
   The description of <command>CREATE FUNCTION</command> and the
   &cite-programmer; contain more information about the meaning of
   some fields.
  </para>

  <para>
   The table contains data for aggregate functions as well as plain functions.
   If <structfield>proisagg</structfield> is true, there should be a matching
   row in <structname>pg_aggregate</structname>.
  </para>

  <table>
   <title>pg_proc Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>proname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the function</entry>
     </row>

     <row>
      <entry>pronamespace</entry>
      <entry><type>oid</type></entry>
      <entry>pg_namespace.oid</entry>
      <entry>
       The OID of the namespace that contains this function
      </entry>
     </row>

     <row>
      <entry>proowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner (creator) of the function</entry>
     </row>

     <row>
      <entry>prolang</entry>
      <entry><type>oid</type></entry>
      <entry>pg_language.oid</entry>
      <entry>Implementation language or call interface of this function</entry>
     </row>

     <row>
      <entry>proisagg</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function is an aggregate function</entry>
     </row>

     <row>
      <entry>prosecdef</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function is a security definer (i.e., a <quote>setuid</>
      function)</entry>
     </row>

     <row>
      <entry>proisstrict</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Function returns null if any call argument is null.  In that
       case the function won't actually be called at all.  Functions
       that are not <quote>strict</quote> must be prepared to handle
       null inputs.
      </entry>
     </row>

     <row>
      <entry>proretset</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function returns a set (ie, multiple values of the specified
      data type)</entry>
     </row>

     <row>
      <entry>provolatile</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>provolatile</structfield> tells whether the function's
       result depends only on its input arguments, or is affected by outside
       factors.
       It is <literal>i</literal> for <quote>immutable</> functions,
       which always deliver the same result for the same inputs.
       It is <literal>s</literal> for <quote>stable</> functions,
       whose results (for fixed inputs) do not change within a scan.
       It is <literal>v</literal> for <quote>volatile</> functions,
       whose results may change at any time.  (Use <literal>v</literal> also
       for functions with side-effects, so that calls to them cannot get
       optimized away.)
      </entry>
     </row>

     <row>
      <entry>pronargs</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of arguments</entry>
     </row>

     <row>
      <entry>prorettype</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>Data type of the return value</entry>
     </row>

     <row>
      <entry>proargtypes</entry>
      <entry><type>oidvector</type></entry>
      <entry>pg_type.oid</entry>
      <entry>A vector with the data types of the function arguments</entry>
     </row>

     <row>
      <entry>prosrc</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       This tells the function handler how to invoke the function.  It
       might be the actual source code of the function for interpreted
       languages, a link symbol, a file name, or just about anything
       else, depending on the implementation language/call convention.
      </entry>
     </row>

     <row>
      <entry>probin</entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>Additional information about how to invoke the function.
      Again, the interpretation is language-specific.
      </entry>
     </row>

     <row>
      <entry>proacl</entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Access permissions</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
  Currently, prosrc contains the function's C-language name (link symbol)
  for compiled functions, both built-in and dynamically loaded.  For all
  other language types, prosrc contains the function's source text.
  </para>

  <para>
  Currently, probin is unused except for dynamically-loaded C functions,
  for which it gives the name of the shared library file containing the
  function.
  </para>

 </sect1>

 <sect1 id="catalog-pg-rewrite">
  <title>pg_rewrite</title>

  <para>
   This system catalog stores rewrite rules for tables and views.
  </para>

  <table>
   <title>pg_rewrite Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>rulename</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Rule name</entry>
     </row>

     <row>
      <entry>ev_class</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table this rule is for</entry>
     </row>

     <row>
      <entry>ev_attr</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>The column this rule is for (currently, always zero to
      indicate the whole table)</entry>
     </row>

     <row>
      <entry>ev_type</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Event type that the rule is for: '1' = SELECT,
      '2' = UPDATE, '3' = INSERT, '4' = DELETE</entry>
     </row>

     <row>
      <entry>is_instead</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if the rule is an INSTEAD rule</entry>
     </row>

     <row>
      <entry>ev_qual</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Expression tree (in the form of a nodeToString representation)
      for the rule's qualifying condition</entry>
     </row>

     <row>
      <entry>ev_action</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Query tree (in the form of a nodeToString representation)
      for the rule's action</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <structname>pg_class</structname>.<structfield>relhasrules</structfield>
    must be true if a table has any rules in this catalog.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-shadow">
  <title>pg_shadow</title>

  <para>
   <structname>pg_shadow</structname> contains information about
   database users.  The name stems from the fact that this table
   should not be readable by the public since it contains passwords.
   <structname>pg_user</structname> is a publicly readable view on
   <structname>pg_shadow</structname> that blanks out the password field.
  </para>

  <para>
   The &cite-admin; contains detailed information about user and
   permission management.
  </para>

  <para>
   Because user identities are cluster-wide,
   <structname>pg_shadow</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_shadow</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title>pg_shadow Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>usename</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>User name</entry>
     </row>

     <row>
      <entry>usesysid</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>User id (arbitrary number used to reference this user)</entry>
     </row>

     <row>
      <entry>usecreatedb</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>User may create databases</entry>
     </row>

     <row>
      <entry>usesuper</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>User is a superuser</entry>
     </row>

     <row>
      <entry>usecatupd</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       User may update system catalogs.  (Even a superuser may not do
       this unless this attribute is true.)
      </entry>
     </row>

     <row>
      <entry>passwd</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Password</entry>
     </row>

     <row>
      <entry>valuntil</entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <entry>Account expiry time (only used for password authentication)</entry>
     </row>

     <row>
      <entry>useconfig</entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Session defaults for run-time configuration variables</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-statistic">
  <title>pg_statistic</title>

  <para>
   <structname>pg_statistic</structname> stores statistical data about
   the contents of the database.  Entries are created by
   <command>ANALYZE</command> and subsequently used by the query planner.
   There is one entry for each table column that has been analyzed.
   Note that all the statistical data is inherently approximate,
   even assuming that it is up-to-date.
  </para>

  <para>
   Since different kinds of statistics may be appropriate for different
   kinds of data, <structname>pg_statistic</structname> is designed not
   to assume very much about what sort of statistics it stores.  Only
   extremely general statistics (such as NULL-ness) are given dedicated
   columns in <structname>pg_statistic</structname>.  Everything else
   is stored in <quote>slots</quote>, which are groups of associated columns whose
   content is identified by a code number in one of the slot's columns.
   For more information see
   <filename>src/include/catalog/pg_statistic.h</filename>.
  </para>

  <para>
   <structname>pg_statistic</structname> should not be readable by the
   public, since even statistical information about a table's contents
   may be considered sensitive.  (Example: minimum and maximum values
   of a salary column might be quite interesting.)
   <structname>pg_stats</structname> is a publicly readable view on
   <structname>pg_statistic</structname> that only exposes information
   about those tables that are readable by the current user.
   <structname>pg_stats</structname> is also designed to present the
   information in a more readable format than the underlying
   <structname>pg_statistic</structname> table --- at the cost that
   its schema must be extended whenever new slot types are added.
  </para>

  <table>
   <title>pg_statistic Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>starelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table that the described column belongs to</entry>
     </row>

     <row>
      <entry>staattnum</entry>
      <entry><type>int2</type></entry>
      <entry>pg_attribute.attnum</entry>
      <entry>The number of the described column</entry>
     </row>

     <row>
      <entry>stanullfrac</entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>The fraction of the column's entries that are NULL</entry>
     </row>

     <row>
      <entry>stawidth</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>The average stored width, in bytes, of non-NULL entries</entry>
     </row>

     <row>
      <entry>stadistinct</entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>The number of distinct non-NULL data values in the column.
      A value greater than zero is the actual number of distinct values.
      A value less than zero is the negative of a fraction of the number
      of rows in the table (for example, a column in which values appear about
      twice on the average could be represented by stadistinct = -0.5).
      A zero value means the number of distinct values is unknown.
      </entry>
     </row>

     <row>
      <entry>stakindN</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>A code number indicating the kind of statistics stored in the Nth
      <quote>slot</quote> of the <structname>pg_statistic</structname> row.
      </entry>
     </row>

     <row>
      <entry>staopN</entry>
      <entry><type>oid</type></entry>
      <entry>pg_operator.oid</entry>
      <entry>An operator used to derive the statistics stored in the
      Nth <quote>slot</quote>.  For example, a histogram slot would show the <literal>&lt;</literal>
      operator that defines the sort order of the data.
      </entry>
     </row>

     <row>
      <entry>stanumbersN</entry>
      <entry><type>float4[]</type></entry>
      <entry></entry>
      <entry>Numerical statistics of the appropriate kind for the Nth
      <quote>slot</quote>, or NULL if the slot kind does not involve numerical values.
      </entry>
     </row>

     <row>
      <entry>stavaluesN</entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Column data values of the appropriate kind for the Nth
      <quote>slot</quote>, or NULL if the slot kind does not store any data values.
      For data-type independence, all column data values are converted
      to external textual form and stored as TEXT datums.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-trigger">
  <title>pg_trigger</title>

  <para>
   This system catalog stores triggers on tables.  See under
   <command>CREATE TRIGGER</command> for more information.
  </para>

  <table>
   <title>pg_trigger Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>tgrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table this trigger is on</entry>
     </row>

     <row>
      <entry>tgname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Trigger name (must be unique among triggers of same table)</entry>
     </row>

     <row>
      <entry>tgfoid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>The function to be called</entry>
     </row>

     <row>
      <entry>tgtype</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Bitmask identifying trigger conditions</entry>
     </row>

     <row>
      <entry>tgenabled</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if trigger is enabled (not presently checked everywhere
      it should be, so disabling a trigger by setting this false does not
      work reliably)</entry>
     </row>

     <row>
      <entry>tgisconstraint</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if trigger implements an RI constraint</entry>
     </row>

     <row>
      <entry>tgconstrname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>RI constraint name</entry>
     </row>

     <row>
      <entry>tgconstrrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>The table referenced by an RI constraint</entry>
     </row>

     <row>
      <entry>tgdeferrable</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if deferrable</entry>
     </row>

     <row>
      <entry>tginitdeferred</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if initially deferred</entry>
     </row>

     <row>
      <entry>tgnargs</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of argument strings passed to trigger function</entry>
     </row>

     <row>
      <entry>tgattr</entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>Currently unused</entry>
     </row>

     <row>
      <entry>tgargs</entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>Argument strings to pass to trigger, each null-terminated</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <structname>pg_class</structname>.<structfield>reltriggers</structfield>
    needs to match up with the entries in this table.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-type">
  <title>pg_type</title>

  <para>
   This catalog stores information about data types.  Scalar types
   (<quote>base types</>) are created with <command>CREATE TYPE</command>.
   A complex type is automatically created for each table in the database, to
   represent the row structure of the table.  It is also possible to create
   complex types with <command>CREATE TYPE AS</command>, and
   derived types with <command>CREATE DOMAIN</command>.
  </para>

  <table>
   <title>pg_type Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>typname</entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Data type name</entry>
     </row>

     <row>
      <entry>typnamespace</entry>
      <entry><type>oid</type></entry>
      <entry>pg_namespace.oid</entry>
      <entry>
       The OID of the namespace that contains this type
      </entry>
     </row>

     <row>
      <entry>typowner</entry>
      <entry><type>int4</type></entry>
      <entry>pg_shadow.usesysid</entry>
      <entry>Owner (creator) of the type</entry>
     </row>

     <row>
      <entry>typlen</entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       For a fixed-size type, <structfield>typlen</structfield> is the number
       of bytes in the internal representation of the type.  But for a
       variable-length type, <structfield>typlen</structfield> is negative.
       -1 indicates a <quote>varlena</> type (one that has a length word),
       -2 indicates a null-terminated C string.
      </entry>
     </row>

     <row>
      <entry>typbyval</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <structfield>typbyval</structfield> determines whether internal
       routines pass a value of this type by value or by reference.
       Only <type>char</type>, <type>short</type>, and
       <type>int</type> equivalent items can be passed by value, so if
       the type is not 1, 2, or 4 bytes long,
       <productname>PostgreSQL</> does not have
       the option of passing by value and so
       <structfield>typbyval</structfield> had better be false.
       Variable-length types are always passed by reference. Note that
       <structfield>typbyval</structfield> can be false even if the
       length would allow pass-by-value; this is currently true for
       type <type>float4</type>, for example.
      </entry>
     </row>

     <row>
      <entry>typtype</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typtype</structfield> is <literal>b</literal> for
       a base type, <literal>c</literal> for a complex type (i.e.,
       a table's row type), <literal>d</literal> for a derived type (i.e.,
       a domain), or <literal>p</literal> for a pseudo-type.  See also
       <structfield>typrelid</structfield>
       and <structfield>typbasetype</structfield>.
      </entry>
     </row>

     <row>
      <entry>typisdefined</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if the type is defined, false if this is a placeholder
      entry for a not-yet-defined type.  When typisdefined is false,
      nothing except the type name, namespace, and OID can be relied on.
      </entry>
     </row>

     <row>
      <entry>typdelim</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Character that separates two values of this type when parsing
      array input.  Note that the delimiter is associated with the array
      element data type, not the array data type.</entry>
     </row>

     <row>
      <entry>typrelid</entry>
      <entry><type>oid</type></entry>
      <entry>pg_class.oid</entry>
      <entry>
       If this is a complex type (see
       <structfield>typtype</structfield>), then this field points to
       the <structname>pg_class</structname> entry that defines the
       corresponding table.  (For a free-standing composite type, the
       <structname>pg_class</structname> entry doesn't really represent
       a table, but it is needed anyway for the type's
       <structname>pg_attribute</structname> entries to link to.)
       Zero for non-complex types.
      </entry>
     </row>

     <row>
      <entry>typelem</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry>
       If <structfield>typelem</structfield> is not 0 then it
       identifies another row in <structname>pg_type</structname>.
       The current type can then be subscripted like an array yielding
       values of type <structfield>typelem</structfield>.  A
       <quote>true</quote> array type is variable length
       (<structfield>typlen</structfield> = -1),
       but some fixed-length (<structfield>typlen</structfield> &gt; 0) types
       also have nonzero <structfield>typelem</structfield>, for example
       <type>name</type> and <type>oidvector</type>.
       If a fixed-length type has a <structfield>typelem</structfield> then
       its internal representation must be N values of the
       <structfield>typelem</structfield> data type with no other data.
       Variable-length array types have a header defined by the array
       subroutines.
      </entry>
     </row>

     <row>
      <entry>typinput</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>Input conversion function</entry>
     </row>

     <row>
      <entry>typoutput</entry>
      <entry><type>regproc</type></entry>
      <entry>pg_proc.oid</entry>
      <entry>Output conversion function</entry>
     </row>

     <row>
      <entry>typalign</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>

       <structfield>typalign</structfield> is the alignment required
       when storing a value of this type.  It applies to storage on
       disk as well as most representations of the value inside
       <productname>PostgreSQL</>.
       When multiple values are stored consecutively, such
       as in the representation of a complete row on disk, padding is
       inserted before a datum of this type so that it begins on the
       specified boundary.  The alignment reference is the beginning
       of the first datum in the sequence.
      </para><para>
       Possible values are:
       <itemizedlist>
        <listitem>
         <para>'c' = CHAR alignment, i.e., no alignment needed.</para>
        </listitem>
        <listitem>
         <para>'s' = SHORT alignment (2 bytes on most machines).</para>
        </listitem>
        <listitem>
         <para>'i' = INT alignment (4 bytes on most machines).</para>
        </listitem>
        <listitem>
         <para>'d' = DOUBLE alignment (8 bytes on many machines, but by no means all).</para>
        </listitem>
       </itemizedlist>
      </para><note>
       <para>
        For types used in system tables, it is critical that the size
        and alignment defined in <structname>pg_type</structname>
        agree with the way that the compiler will lay out the field in
        a struct representing a table row.
       </para>
      </note></entry>
     </row>

     <row>
      <entry>typstorage</entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typstorage</structfield> tells for varlena
       types (those with <structfield>typlen</structfield> = -1) if
       the type is prepared for toasting and what the default strategy
       for attributes of this type should be.
       Possible values are
       <itemizedlist>
        <listitem>
         <para>'p': Value must always be stored plain.</para>
        </listitem>
        <listitem>
         <para>
          'e': Value can be stored in a <quote>secondary</quote>
          relation (if relation has one, see
          <structname>pg_class</structname>.<structfield>reltoastrelid</structfield>).
         </para>
        </listitem>
        <listitem>
         <para>'m': Value can be stored compressed inline.</para>
        </listitem>
        <listitem>
         <para>'x': Value can be stored compressed inline or in <quote>secondary</quote>.</para>
        </listitem>
       </itemizedlist>
       Note that 'm' fields can also be moved out to secondary
       storage, but only as a last resort ('e' and 'x' fields are
       moved first).
      </para></entry>
     </row>

     <row>
      <entry>typnotnull</entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typnotnull</structfield> represents a NOT NULL
       constraint on a type.  Presently used for domains only.
      </para></entry>
     </row>

     <row>
      <entry>typbasetype</entry>
      <entry><type>oid</type></entry>
      <entry>pg_type.oid</entry>
      <entry><para>
       If this is a derived type (see <structfield>typtype</structfield>),
       then <structfield>typbasetype</structfield> identifies
       the type that this one is based on.  Zero if not a derived type.
      </para></entry>
     </row>

     <row>
      <entry>typtypmod</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       Domains use <structfield>typtypmod</structfield> to record the typmod
       to be applied to their base type (-1 if base type does not use a
       typmod).  -1 if this type is not a domain.
      </para></entry>
     </row>

     <row>
      <entry>typndims</entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typndims</structfield> is the number of array dimensions
       for a domain that is an array (that is, typbasetype is an array type;
       the domain's typelem will match the base type's typelem).
       Zero for non-domains and non-array domains.
       </para></entry>
     </row>

     <row>
      <entry>typdefaultbin</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       If <structfield>typdefaultbin</> is not NULL, it is the nodeToString
       representation of a default expression for the type.  Currently this is
       only used for domains.
      </para></entry>
     </row>

     <row>
      <entry>typdefault</entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typdefault</> is NULL if the type has no associated
       default value. If <structfield>typdefaultbin</> is not NULL,
       <structfield>typdefault</> must contain a human-readable version of the
       default expression represented by <structfield>typdefaultbin</>.  If
       <structfield>typdefaultbin</> is NULL and <structfield>typdefault</> is
       not, then <structfield>typdefault</> is the external representation of
       the type's default value, which may be fed to the type's input
       converter to produce a constant.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-tabs-mode:nil
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/share/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
