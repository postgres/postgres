#!/usr/bin/perl
#----------------------------------------------------------------------
#
# Generate guc_tables.c from guc_parameters.dat.
#
# Portions Copyright (c) 1996-2025, PostgreSQL Global Development Group
# Portions Copyright (c) 1994, Regents of the University of California
#
# src/backend/utils/misc/gen_guc_tables.pl
#
#----------------------------------------------------------------------

use strict;
use warnings FATAL => 'all';

use FindBin;
use lib "$FindBin::RealBin/../../catalog";
use Catalog;

die "Usage: $0 INPUT_FILE OUTPUT_FILE\n" unless @ARGV == 2;
my ($input_fname, $output_fname) = @ARGV;

my $parse = Catalog::ParseData($input_fname);

open my $ofh, '>', $output_fname or die;

print_boilerplate($ofh, $output_fname, 'GUC tables');
foreach my $type (qw(bool int real string enum))
{
	print_one_table($ofh, $type);
}

close $ofh;


# Adds double quotes and escapes as necessary for C strings.
sub dquote
{
	my ($s) = @_;

	return q{"} . $s =~ s/"/\\"/gr . q{"};
}

# Print GUC table for one type.
sub print_one_table
{
	my ($ofh, $type) = @_;
	my $Type = ucfirst $type;

	print $ofh "\n\n";
	print $ofh "struct config_${type} ConfigureNames${Type}[] =\n";
	print $ofh "{\n";

	foreach my $entry (@{$parse})
	{
		next if $entry->{type} ne $type;

		print $ofh "#ifdef $entry->{ifdef}\n" if $entry->{ifdef};
		print $ofh "\t{\n";
		print $ofh "\t\t{\n";
		printf $ofh "\t\t\t.name = %s,\n", dquote($entry->{name});
		printf $ofh "\t\t\t.context = %s,\n", $entry->{context};
		printf $ofh "\t\t\t.group = %s,\n", $entry->{group};
		printf $ofh "\t\t\t.short_desc = gettext_noop(%s),\n",
		  dquote($entry->{short_desc});
		printf $ofh "\t\t\t.long_desc = gettext_noop(%s),\n",
		  dquote($entry->{long_desc})
		  if $entry->{long_desc};
		printf $ofh "\t\t\t.flags = %s,\n", $entry->{flags}
		  if $entry->{flags};
		print $ofh "\t\t},\n";
		printf $ofh "\t\t.variable = &%s,\n", $entry->{variable};
		printf $ofh "\t\t.boot_val = %s,\n", $entry->{boot_val};
		printf $ofh "\t\t.min = %s,\n", $entry->{min}
		  if $entry->{type} eq 'int' || $entry->{type} eq 'real';
		printf $ofh "\t\t.max = %s,\n", $entry->{max}
		  if $entry->{type} eq 'int' || $entry->{type} eq 'real';
		printf $ofh "\t\t.options = %s,\n", $entry->{options}
		  if $entry->{type} eq 'enum';
		printf $ofh "\t\t.check_hook = %s,\n", $entry->{check_hook}
		  if $entry->{check_hook};
		printf $ofh "\t\t.assign_hook = %s,\n", $entry->{assign_hook}
		  if $entry->{assign_hook};
		printf $ofh "\t\t.show_hook = %s,\n", $entry->{show_hook}
		  if $entry->{show_hook};
		print $ofh "\t},\n";
		print $ofh "#endif\n" if $entry->{ifdef};
		print $ofh "\n";
	}

	print $ofh "\t/* End-of-list marker */\n";
	print $ofh "\t{{0}}\n";
	print $ofh "};\n";

	return;
}

sub print_boilerplate
{
	my ($fh, $fname, $descr) = @_;
	printf $fh <<EOM, $fname, $descr;
/*-------------------------------------------------------------------------
 *
 * %s
 *    %s
 *
 * Portions Copyright (c) 1996-2025, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * NOTES
 *  ******************************
 *  *** DO NOT EDIT THIS FILE! ***
 *  ******************************
 *
 *  It has been GENERATED by src/backend/utils/misc/gen_guc_tables.pl
 *
 *-------------------------------------------------------------------------
 */
EOM

	return;
}
