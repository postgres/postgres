
                  Häufig gestellte Fragen (FAQ) zu PostgreSQL
                                       
   Current maintainer: Bruce Momjian (pgman@candle.pha.pa.us).
   
   Deutsche Übersetzung von Ian Barwick (barwick@gmx.net).
   
   Letzte Aktualisierung der deutschen Übersetzung: Fr., den 05.03.2004,
   23:30 CET
   
   Die aktuellste Version dieses Dokuments liegt auf der PostgreSQL
   Website:
     * http://www.PostgreSQL.org/docs/faqs/FAQ.html (engl.)
     * http://www.PostgreSQL.org/docs/faqs/FAQ_german.html (dt.)
       
   Übersetzungen dieses Dokuments in andere Sprachen sowie plattform-
   spezifische FAQs können unter
   http://www.PostgreSQL.org/docs/index.html#faqs eingesehen werden.
     _________________________________________________________________
   
                             Allgemeine Fragen
                                      
   1.1) Was ist PostgreSQL? Wie wird es ausgesprochen?
   1.2) Welchem Copyright unterliegt PostgreSQL?
   1.3) Auf welchen Unix-Plattformen läuft PostgreSQL?
   1.4) Welche Nicht-Unix-Versionen sind verfügbar?
   1.5) Woher bekomme ich PostgreSQL?
   1.6) Wo bekomme ich Support für PostgreSQL?
   1.7) Was ist die neueste Version von PostgreSQL?
   1.8) Welche Dokumentation ist für PostgreSQL verfügbar?
   1.9) Wie erfahre ich von bekannten Bugs oder fehlenden Features?
   1.10) Wie kann ich SQL lernen?
   1.11) Ist PostgreSQL Y2K (Jahr 2000) fähig?
   1.12) Wie kann ich im Entwicklerteam mitarbeiten?
   1.13) Wie sende ich einen Fehler-Bericht?
   1.14) Wie läuft PostgreSQL im Vergleich zu anderen Datenbanksystemen?
   1.15) Wie kann ich PostgreSQL finanziell unterstützen?
   
                        Fragen zu Benutzerprogrammen
                                      
   2.1) Gibt es ODBC-Treiber für PostgreSQL?
   2.2) Welche Werkzeuge gibt es, um Web-Seiten mit PostgreSQL zu
   verbinden?
   2.3) Hat PostgreSQL eine grafische Benutzerschnittstelle?
   2.4) Welche Programmiersprachen können mit PostgreSQL kommunizieren?
   
                           Administrative Fragen
                                      
   3.1) Wie installiere ich PostgreSQL woanders als in /usr/local/pgsql?
   3.2) Wenn ich den postmaster starte, erhalte ich die Nachricht "Bad
   System Call" bzw. "core dumped". Warum?
   3.3) Wenn ich versuche, den postmaster zu starten, bekomme ich
   "IpcMemoryCreate"-Fehlermeldungen. Warum?
   3.4) Wenn ich versuche, den postmaster zu starten, bekomme ich
   "IpcSemaphoreCreate"-Fehlermeldungen. Warum?
   3.5) Wie regle ich Zugriffe von anderen Rechnern?
   3.6) Wie optimiere ich die Datenbank für bessere Leistung?
   3.7) Welche Debugging-Funktionen sind bei PostgreSQL verfügbar?
   3.8) Ich bekomme die Meldung "Sorry, too many clients", wenn ich eine
   Verbindung aufzubauen versuche. Warum?
   3.9) Was befindet sich im Verzeichnis pgsql_tmp/?
   3.10) Warum muß ich bei jeder neuen Hauptversion von PostgreSQL die
   komplette Datenbank exportieren und anschließend reimportieren?
   
                             Fragen zum Betrieb
                                      
   4.1) Worin besteht der Unterschied zwischen Binary Cursors und Normal
   Cursors?
   4.2) Wie wähle ich per SELECT-Anweisung nur die ersten paar Zeilen
   bzw. eine beliebige Zeile in einer Abfrage aus?
   4.3) Wie bekomme ich eine Liste der Tabellen oder anderen Dinge, die
   ich in psql sehen kann?
   4.4) Wie entferne ich eine Spalte aus einer Tabelle? Wie ändere ich
   den Datentyp einer Spalte?
   4.5) Was ist die Maximalgröße für eine Zeile, eine Tabelle, eine
   Datenbank?
   4.6) Wieviel Plattenplatz wird benötigt, um die Daten aus einer
   typischen Textdatei abzuspeichern?
   4.7) Wie finde ich heraus, welche Indizes oder Operationen in der
   Datenbank definiert sind?
   4.8) Meine Abfragen sind langsam oder nutzen die Indizes nicht. Warum?
   4.9) Auf welche Weise kann ich sehen, wie der Abfrage-Optimierer
   ("GEQO") meine Abfrage auswertet?
   4.10) Was ist ein R-Tree Index?
   4.11) Was ist der "Genetic Query Optimizer"?
   4.12) Wie verfahre ich bei der Suche mit regulären Ausdrücken und bei
   einer Suche, bei der Groß- und Kleinschreibweisen ignoriert werden?
   Wie verwende ich bei solchen Suchabfragen einen Index?
   4.13) Wie ermittle ich in einer Abfrage, ob ein Feld NULL ist?
   4.14) Was ist der Unterschied zwischen den verschiedenen CHAR-Typen?
   4.15.1) Wie erzeuge ich ein serielles Feld mit automatischer Erhöhung
   des Wertes?
   4.15.2) Wie bekomme ich den Wert einer SERIAL-Sequenz?
   4.15.3) Führen currval() und nextval() zu einer Race-Condition mit
   anderen Nutzern?
   4.15.4) Warum werden die Sequenzwerte nach einem Transaktionsabbruch
   nicht zurückgesetzt? Warum gibt es Lücken in der Nummerierung meiner
   Sequenz-/SERIAL-Spalte?
   4.16) Was ist ein OID? Was ist ein TID?
   4.17) Welche Bedeutung haben die verschiedenen Ausdrücke, die in
   PostgreSQL benutzt werden (z.B. attribute, class,...)?
   4.18) Wieso bekomme ich den Fehler: "FATAL: Memory exhausted in
   AllocSetAlloc()"?
   4.19) Wie kann ich feststellen, welche PostgreSQL-Version bei mir
   läuft?
   4.20) Bei "large-object"-Operationen kommt die Fehlermeldung: "invalid
   large obj descriptor". Warum?
   4.21) Wie kann ich eine Spalte erstellen, deren Default-Wert immer die
   aktuelle Uhrzeit enthalten soll?
   4.22) Warum sind meine Unterabfragen (subqueries), die IN verwenden,
   so langsam?
   4.23) Wie führe ich einen OUTER JOIN durch?
   4.24) Wie kann ich Abfragen über mehrere Datenbanken hinweg ausführen?
   4.25) Wie kann ich mehrere Zeilen bzw. Spalten von einer Funktion
   zurückgeben lassen?
   4.26) Warum kann ich temporäre Tabellen in PL/PgSQL-Funktionen nicht
   zuverlässig erstellen bzw. löschen?
   4.27) Welche Möglichkeiten zur Datenbank-Replikation gibt es?
   4.28) Welche Möglichkeiten zur Verschlüsselung gibt es?
   
                            PostgreSQL erweitern
                                      
   5.1) Ich habe eine benutzerdefinierte Funktion geschrieben. Wenn ich
   sie in psql aufrufe, kommt ein core dump. Warum?
   5.2) Wie kann ich praktische neue Typen und Funktionen zu PostgreSQL
   hinzufügen?
   5.3) Wie schreibe ich eine Funktion in C, die einen Tupel
   zurückliefert?
   5.4) Ich habe eine der Quellendateien geändert. Warum macht sich die
   Änderung beim erneuten Kompilieren nicht bemerkbar?
     _________________________________________________________________
   
                             Allgemeine Fragen
                                      
    1.1) Was ist PostgreSQL? Wie wird es ausgesprochen?
    
   Die (englische) Aussprache ist "Post-Gres-Q-L". Im allgemeinen
   Sprachgebrauch hat sich auch "Postgres" durchgesetzt.
   
   PostgreSQL ist eine Weiterentwicklung des POSTGRES-Datenbank-Systems,
   eines zukunftsweisenden DBMS-Forschungsprototyps. Während PostgreSQL
   das leistungsfähige Datenmodell und die reichhaltigen Datentypen von
   POSTGRES beibehält, ersetzt es dessen PostQuel-Abfragesprache durch
   eine erweiterte Teilmenge von SQL. PostgreSQL und dessen kompletter
   Quellcode sind frei und öffentlich verfügbar.
   
   Die PostgreSQL-Entwicklung wird von einem Entwickler-Team
   durchgeführt, die alle Teilnehmer der
   PostgreSQL-Entwicklungs-Mailingliste sind. Der aktuelle Koordinator
   ist Marc G. Fournier (scrappy@PostgreSQL.org) (Anmeldemöglichkeit:
   siehe unten). Dieses Team ist für die Gesamtentwicklung von PostgreSQL
   verantwortlich. Es handelt sich um ein Gemeinschaftsprojekt, das nicht
   von einer bestimmten Firma kontrolliert wird. Lesen Sie die
   Entwickler-FAQ: http://www.PostgreSQL.org/docs/faqs/FAQ_DEV.html wenn
   Sie an einer Mitarbeit interessiert sind.
   
   Die Autoren von PostgreSQL 1.01 waren Andrew Yu und Jolly Chen. Viele
   andere haben zur Portierung, zum Testen, zur Fehlersuche und zur
   Verbesserung des Codes beigetragen. Der ursprüngliche Postgres-Code,
   von dem PostgreSQL abstammt, ist auf die Arbeit von vielen
   Studierenden und Diplomanden sowie Programmierern zurückzuführen, die
   unter der Leitung des Professors Michael Stonebraker an der
   Universität von Kalifornien, Berkeley arbeiteten.
   
   Der ursprüngliche Name der Software in Berkeley war Postgres. Als die
   SQL-Funktionalität 1995 hinzugefügt wurde, wurde sein Name zu
   Postgres95 geändert. Der Name wurde Ende 1996 in PostgreSQL geändert.
   
    1.2).Welchem Copyright unterliegt PostgreSQL?
    
   PostgreSQL unterliegt folgendem COPYRIGHT (Originaltext):
   
   PostgreSQL Data Base Management System
   
   Portions copyright (c) 1996-2002, PostgreSQL Global Development Group
   Portions Copyright (c) 1994-6 Regents of the University of California
   
   Permission to use, copy, modify, and distribute this software and its
   documentation for any purpose, without fee, and without a written
   agreement is hereby granted, provided that the above copyright notice
   and this paragraph and the following two paragraphs appear in all
   copies.
   
   IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
   FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
   INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND
   ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN
   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   
   THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
   PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
   CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
   UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   
   Bei der obigen Lizenz handelt es sich um die BSD-Lizenz, die klassiche
   Open-Source-Lizenz. Sie schränkt die Verwendung des Quellcodes in
   keine Weise ein. Wir mögen diese Lizenz und haben nicht vor, sie zu
   ändern.
   
   Es gilt die Copyright-Klausel im Original!
   
    1.3) Auf welchen Unix-Plattformen läuft PostgreSQL?
    
   Normalerweise kann PostgreSQL auf jeder modernen UNIX-kompatiblen
   Plattform eingesetzt werden. Diejenigen Plattformen, die bei der
   jeweiligen Versionsfreigabe getestet wurden, sind in den
   Installations- Anleitungen aufgelistet.
   
    1.4) Welche Nicht-Unix-Portierungen sind verfügbar?
    
   Client
   
   Es ist möglich, die libpq C-Bibliothek, psql sowie andere Client-
   Anwendungen und Schnittstellen für den Einsatz auf
   MS-Windows-Plattformen zu kompilieren. In diesem Fall läuft der Client
   auf MS-Windows und steht über TCP/IP mit einem Server in Verbindung,
   der auf einer der unterstützten Unix-Plattformen läuft. Die
   Distribution enthält die Datei win32.mak, mit der Win32
   libpq-Bibliothek und psql erzeugt werden können.
   
   Server
   
   Der Datenbankserver selber kann mit Hilfe der Cygwin-Umgebung
   (Unix/NT-Portierungsbibliotheken) auf Windows NT/2000 zum Laufen
   gebracht werden. Hierzu bitte lesen Sie die in der Distribution
   enthaltene Datei pgsql/doc/FAQ_MSWIN oder die MS-Windows-FAQ unter
   http://www.PostgreSQL.org/docs/faqs/text/FAQ_MSWIN.
   
   Eine eigenständige Portierung auf MS Win NT/2000/XP befindet sich in
   der Vorbereitung.
   
   Weitere Informationen zum Status von PostgreSQL auf der
   Microsoft-Plattform befinden sich unter
   http://techdocs.postgresql.org/guides/Windows (en.) sowie
   http://momjian.postgresql.org/main/writings/pgsql/win32.html (en.).
   
   Eine Portierung für Novell Netware 6 gibt es unter
   http://forge.novell.com.
   
    1.5) Woher bekomme ich PostgreSQL?
    
   Der zentrale FTP-Server für PostgreSQL ist der ftp-Server
   ftp://ftp.postgreSQL.org/pub. Weitere Mirror-Sites sind auf der
   PostgreSQL-Website aufgelistet.
   
    1.6) Wo bekomme ich Support für PostgreSQL?
    
   Die zentrale (englischsprachige) Mailing-Liste ist:
   mailto:pgsql-general@PostgreSQL.org .
   
   Die Liste ist Themen vorbehalten, die PostgreSQL betreffen. Die
   Anmeldung erfolgt mit einer Email an die Adresse
   pgsql-general-request@PostgreSQL.org mit folgenden Zeilen im Text
   (nicht in der Betreffzeile):
    subscribe
    end

   Es gibt auch eine Digest-Liste (eine Liste, die Mails zusammengefasst
   sendet). Um sich an dieser Digest-Liste anzumelden, senden Sie eine
   Email an pgsql-general-digest-request@PostgreSQL.org mit folgendem
   Text:
    subscribe
    end

   Es gibt noch die Bug-Mailingliste. Die Anmeldung für diese Liste
   erfolgt durch eine Email an bugs-request@PostgreSQL.org mit folgendem
   Text:
    subscribe
    end

   Die Entwickler-Mailingliste kann mit einer Email an
   pgsql-hackers-request@PostgreSQL.org abonniert werden. Die Email muß
   ebenfalls folgenden Text enthalten:
    subscribe
    end

   Eine deutschsprachige Mailing-Liste gibt es bei Yahoo Groups:
   http://de.groups.yahoo.com/group/postgres/; die Liste kann mit einer
   leeren E-Mail an postgres-subscribe@yahoogroups.de abonniert werden.
   
   Weitere Mailinglisten und Informationen zu PostgreSQL befinden sich
   auf der PostgreSQL-Homepage:
   
     http://www.PostgreSQL.org
     
   Es gibt außerdem einen IRC-Channel bei EFNet und bei Freenode, Channel
   #PostgreSQL. Unter UNIX/Linux können Sie mit z.B. irc -c '#PostgreSQL'
   "$USER" irc.phoenix.net bzw. irc -c '#PostgreSQL' "$USER"
   irc.freenode.net. daran teilnehmen.
   
   Eine Liste von Unternehmen, die Support für PostgreSQL auf
   kommerzieller Basis leisten, kann unter
   http://techdocs.postgresql.org/companies.php eingesehen werden.
   
    1.7) Was ist die neueste Version von PostgreSQL?
    
   Die neueste Version von PostgreSQL ist 7.4.2 .
   
   Die Freigabe einer neuen Version erfolgt im Schnitt ca. dreimal pro
   Jahr.
   
    1.8) Welche Dokumentation ist für PostgreSQL verfügbar?
    
   Einige Handbücher, Man-Pages und einige kleine Testprogramme sind in
   der Distribution enthalten. Siehe das /doc-Verzeichnis. Ausserdem sind
   alle Handbücher online unter http://www.PostgreSQL.org/docs/
   verfügbar.
   
   Zwei Bücher zu PostgreSQL sind online verfügbar unter
   http://www.PostgreSQL.org/docs/awbook.html und
   http://www.commandprompt.com/ppbook/ .
   
   Eine Liste lieferbarer PostgreSQL-Bücher befindet sich unter
   http://techdocs.PostgreSQL.org/techdocs/bookreviews.php Diverse
   technische Artikel befinden sich unter http://techdocs.PostgreSQL.org/
   .
   
   psql hat einige nützliche \d-Befehle, um Informationen über Typen,
   Operatoren, Funktionen, Aggregate, usw. zu zeigen.
   
    1.9) Wie erfahre ich von bekannten Bugs oder fehlenden Features?
    
   PostgreSQL unterstützt eine erweiterte Teilmenge von SQL-92. Siehe
   unsere TODO-Liste unter http://developer.PostgreSQL.org/todo.php für
   eine Auflistung der bekannten Bugs, fehlenden Features und zukünftigen
   Pläne.
   
    1.10) Wie kann ich SQL lernen?
    
   Das PostgreSQL Book auf http://www.PostgreSQL.org/docs/awbook.html
   bietet eine Einführung in SQL. Ein weiteres PostgreSQL-Buch befindet
   sich unter http://www.commandprompt.com/ppbook . Es gibt zudem nette
   Tutorials unter http://www.intermedia.net/support/sql/sqltut.shtm ,
   http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM
   und http://sqlcourse.com .
   
   Eine weitere Empfehlung ist "Teach Yourself SQL in 21 Days, Second
   Edition", es ist unter http://members.tripod.com/er4ebus/sql/index.htm
   erhältlich.
   
   Viele PostgreSQL-Anwender mögen "The Practical SQL Handbook" (Bowman
   et al., Addison Wesley). Andere dagegen mögen "The Complete Reference
   SQL" (Groff et al., McGraw-Hill).
   
    1.11) Ist PostgreSQL Y2K (Jahr 2000) fähig?
    
   Ja, wir können Datumsangaben nach dem Jahr 2000 n.Chr. und vor 2000
   v.Chr. leicht verarbeiten.
   
    1.12) Wie kann ich im Entwicklerteam mitarbeiten?
    
   Zuerst laden Sie die neuesten Quellen herunter und lesen Sie die
   PostgreSQL-Entwicklerunterlagen auf unserer Website oder in der
   Distribution. Dann melden Sie sich zu den Entwickler-Mailinglisten
   pgsql-hackers und pgsql-patches an. Anschließend senden Sie qualitativ
   hochwertige Patches an die pgsql-patches Mailingliste.
   
   Es gibt ungefähr ein Dutzend Leute, die das commit-Recht im PostgreSQL
   CVS-Archiv haben. Alle haben derart viele hochwertige Patches
   eingebracht, dass es für die CVS-Verwalter schwer war, mitzuhalten.
   Und wir hatten Vertrauen, dass die von ihnen festgelegten Änderungen
   aller Wahrscheinlichkeit nach von hoher Qualität sind.
   
    1.13) Wie sende ich einen Fehlerbericht?
    
   Bitte besuchen Sie die PostgreSQL-BugTool-Seite
   http://www.PostgreSQL.org/bugs/, die Hinweise und Anleitungen zur
   Einreichung von Fehlerberichten enthält.
   
   Überprüfe auch den ftp-Server ftp://ftp.PostgreSQL.org/pub, um
   nachzusehen, ob es eine neuere PostgreSQL-Version oder neue Patches
   gibt.
   
    1.14) Wie läuft PostgreSQL im Vergleich zu anderen Datenbanksystemen?
    
   Es gibt verschiedene Methoden, Software zu messen: Eigenschaften,
   Leistung, Zuverlässigkeit, Support und Preis.
   
   Eigenschaften
          PostgreSQL besitt die meisten Eigenschaften - wie
          Transaktionen, Unterabfragen (Subqueries), Trigger, Views und
          verfeinertes Locking - die bei großen kommerziellen DBMS
          vorhanden sind. Es bietet außerdem einige anderen
          Eigenschaften, die diese nicht haben, wie benutzerbestimmte
          Typen, Vererbung, Regeln, und die Multi-Versionen-Steuerung zum
          Verringern konkurrierender Locks.
          
   Performanz
          PostgreSQL weist eine Performanz auf, die mit der von
          kommerziellen und anderen Open-Source-Datenbanken vergleichbar
          ist. In manchen Bereichen ist es schneller, in anderen
          langsamer.
          
          Im Vergleich zu MySQL oder abgespeckten Datenbank-Systemen ist
          PostgreSQL in Lastsituationen - z.B. bei zeitgleichen Zugriffen
          durch mehrere Nutzer, komplexen Abfragen oder gleichzeitigen
          Lese- und Schreibzugriffen schneller. MySQL ist nur bei
          einfacheren SELECT-Abfragen mit wenigen Nutzern schneller.
          MySQL hat allerdings wenige der oben erwähnten Eigenschaften.
          PostgreSQL setzt auf Zuverlässigkeit und Funktionsumfang, dabei
          wird selbstredend ständig an Performanz-Verbesserungen
          gearbeitet. Ein interessanter Vergleich zwischen PostgreSQL und
          MySQL befindet sich unter dieser URL:
          http://openacs.org/philosophy/why-not-mysql.html Zu beachten
          ist außerdem, daß die MySQL-Hersteller zwar ihre Produkte als
          Open-Source vertreiben, beim kommerziellen Einsatz müssen
          jedoch gemäß den Nutzungsbedingungen Lizenzgebühren entrichtet
          werden.
          
   Zuverlässigkeit
          Wir stellen fest, dass ein DBMS wertlos ist, wenn es nicht
          zuverlässig arbeitet. Wir bemühen uns, nur streng geprüften,
          beständigen Code freizugeben, der nur ein Minimum an
          Programmfehler aufweist. Jede Freigabe hat mindestens einen
          Monat Betatest-Phase hinter sich, und unsere Freigabehistorie
          beweist, dass wir stabile, solide Versionen freigeben, die im
          Produktionsbetrieb genutzt werden können. Wir glauben, dass wir
          im Vergleich mit anderer Datenbanksoftware vorteilhaft
          dastehen.
          
   Support
          Unsere Mailinglisten bieten die Möglichkeit, gemeinsam mit
          einer großen Gruppe von Entwicklern und Benutzern mögliche
          Probleme zu lösen. Wir können nicht immer eine Fehlerbehebung
          garantieren, kommerzielle DBMS tun dies aber auch nicht. Der
          direkte Kontakt zur Entwickler- und Benutzergemeinschaft, der
          Zugriff auf die Handbücher und auf den Quellcode ermöglicht
          einen im Vergleich zu anderen DBMS höherwertigen Support. Es
          gibt jedoch auch Anbieter von kommerziellen Support-Leistungen
          (siehe FAQ-Punkt 1.6).
          
   Preis
          PostgreSQL ist frei verfügbar, sowohl für die kommerzielle wie
          für die nicht-kommerzielle Nutzung. Sie können den
          PostgreSQL-Code ohne Einschränkungen (außer denjenigen, die in
          der oben angegebene BSD-artigen Lizenz erwähnt werden) in Ihr
          Produkt integrieren.
          
    1.15) Wie kann ich PostgreSQL finanziell unterstützen?
    
   PostgreSQL hat seit dem Anfang in 1996 eine exzellente Infrastruktur.
   Dies ist Marc Fournier zu verdanken, der sie über die Jahre hinweg
   geschaffen und gepflegt hat.
   
   Eine hochwertige Infrastruktur ist für ein Open-Source-Projekt wie
   dieses sehr wichtig. Sie verhindert Probleme und Verzögerungen beim
   Fortschritt des Projekts.
   
   Selbstverständlich ist diese Infrastruktur nicht billig. Es gibt eine
   Reihe von einmaligen und monatlich wiederkehrenden Kosten, die für den
   Weiterbetrieb beglichen werden müssen. Falls Sie oder Ihre Firma dazu
   finanziell beitragen können, besuchen Sie bitte die URL
   http://store.pgsql.com/shopping/ wo Sie eine Spende abgeben können.
   
   Obwohl diese Web-Seite das Unternehmen "PostgreSQL, Inc." erwähnt, ist
   der Bereich "contributions" (Beiträge) ausschliesslich für die
   Unterstützung des PostgreSQL-Projekts da und nicht für die
   Finanzierung einer bestimmten Firma. Sie können auch gerne einen
   finanziellen Beitrag an die Kontaktadresse verschicken.
   
   Eine Möglichkeit der nicht-finanziellen Untetstützung besteht übrigens
   darin, für http://advocacy.postgresql.org (en.) bzw.
   http://advocacy.postgresql.org/?lang=de (dt.) einen Bericht über den
   erfolgreichen Einsatz von PostgreSQL in Ihrem Unternehmen oder
   Organisation bereitzustellen.
     _________________________________________________________________
   
                        Fragen zu Benutzerprogrammen
                                      
    2.1) Gibt es ODBC-Treiber für PostgreSQL?
    
   Es sind zwei ODBC-Treiber verfügbar: PsqlODBC und OpenLink ODBC.
   
   PsqlODBC kann von
   http://gborg.postgresql.org/project/psqlodbc/projdisplay.php
   heruntergeladen werden.
   
   OpenLink ODBC kann unter http://www.openlinksw.com geholt werden. Die
   Software arbeitet mit dem Standard-ODBC-Client dieser Firma, so dass
   PostgreSQL-ODBC auf jeder Client-Plattform zur Verfügung steht, die
   unterstützt wird (Win, Mac, Unix, VMS).
   
   OpenLink wird dieses Produkt wahrscheinlich an Leute verkaufen, die
   kommerziellen Support benötigen, dennoch wird immer eine
   Freeware-Version verfügbar sein. Fragen dazu bitte an
   postgres95@openlink.co.uk.
   
    2.2) Welche Werkzeuge gibt es, um Web-Seiten mit PostgreSQL zu verbinden?
    
   Eine nette Einführung zu datenbank-gestützten Webseiten kann unter
   http://www.webreview.com (engl.) abgerufen werden.
   
   Für die Web-Integration ist PHP eine ausgezeichnete Schnittstelle. PHP
   gibt es bei http://www.php.net
   
   Für komplexere Aufgaben bietet sich die Perl-Schnittstelle mit CGI.pm
   oder mod_perl.
   
    2.3) Hat PostgreSQL eine grafische Benutzerschnittstelle?
    
   Es gibt mehrere grafische Schnittstellen für PostgreSQL, darunter
   PgAccess ( http://www.pgaccess.org), PgAdmin III
   (http://www.pgadmin.org, RHDB Admin (http://sources.redhat.com/rhdb/ )
   und Rekall ( http://www.thekompany.com/products/rekall/, proprietär).
   Es gibt außerdem PHPPgAdmin ( http://phppgadmin.sourceforge.net/ ),
   eine web-basierte Schnittstelle.
   
    2.4) Welche Programmiersprachen und Schnittstellen gibt es?
    
   Die meisten gängigen Programmiersprachen bieten Schnittstellen für
   PostgreSQL.
   
   Die folgenden Schnittstellen werden mit der PostgreSQL-Distribution
   ausgeliefert:
     * C (libpq)
     * Embedded C (ecpg)
     * Java (jdbc)
     * Python (PyGreSQL)
     * TCL (libpgtcl)
       
   Weitere Schnittstellen für andere Sprachen können über
   http://gborg.postgresql.org (Bereich Drivers/Interfaces) bezogen
   werden.
     _________________________________________________________________
   
                           Administrative Fragen
                                      
    3.1) Wie installiere ich PostgreSQL woanders als in /usr/local/pgsql?
    
   Bei der Ausführung von configure die Option --prefix mit dem
   Zielverzeichnis angeben.
   
    3.2) Wenn ich den postmaster starte, erhalte ich einen Nachricht "Bad
    System Call" bzw. "core dumped". Wieso?
    
   Das kann verschiedene Ursachen haben. Überprüfen Sie zuerst, ob Ihr
   Kernel System V Extensions unterstützt. PostgreSQL benötigt
   Kernel-Unterstützung für Shared Memory und Semaphoren.
   
    3.3) Wenn ich versuche, den postmaster zu starten, bekomme ich
    "IpcMemoryCreate"-Fehlermeldungen. Warum?
    
   Entweder ist Shared Memory in Ihrem Kernel nicht korrekt konfiguriert,
   oder Sie müssen den Shared Memory Bereich vergrößern. Die genaue Größe
   hängt von Ihrer Systemarchitektur und von der Anzahl der Puffer und
   Serverprozesse ab, die Sie für postmaster konfiguriert haben. Bei den
   voreingestellten Werten für Puffer und Prozesse benötigen Sie bei den
   meisten Systemen ein Minimum von ca. 1 MB. Der "PostgreSQL
   Administrator's Guide"
   (http://www.PostgreSQL.org/docs/view.php?version=current&idoc=1&file=k
   ernel-resources.html) enthält weitere Informationen zu Shared Memory
   und Semaphores.
   
    3.4) Wenn ich versuche, den postmaster zu starten, bekomme ich
    "IpcSemaphoreCreate"-Fehlermeldungen. Warum?
    
   Falls die Fehlermeldung "IpcSemaphoreCreate: semget failed (No space
   left on device)" lautet, ist Ihr Kernel mit zu wenig Semaphoren
   konfiguriert. PostgreSQL benötigt eine Semaphore pro möglichem
   Backend-Prozess. Eine Zwischenlösung wäre, postmaster mit einer
   geringeren Anzahl an Backend-Prozessen zu starten. Benutzen Sie dazu
   die -N Option mit einem kleineren Wert als die standardmäßigen 32.
   Eine dauerhafte Lösung wäre es, die Parameter SEMMNS und SEMMNI Ihres
   Kernels zu erhöhen.
   
   Nichtfunktionierende Semaphores können außerdem bei hoher
   Datenbanklast zu Abstürzen führen.
   
   Falls die Fehlermeldung anders aussieht, ist möglicherweise keine
   Semaphoren-Unterstützung in Ihrem Kernel aktiviert. Der "PostgreSQL
   Administrator's Guide" enthält weitere Informationen zu Shared Memory
   und Semaphores.
   
    3.5) Wie regle ich Zugriffe von anderen Rechnern?
    
   PostgreSQL ist standardmäßig so eingestellt, dass Verbindungen nur vom
   lokalen Rechner über Unix Domain Sockets möglich sind. Verbindungen
   von anderen Rechnern über TCP/IP sind nur möglich, wenn der postmaster
   mit der -i Option gestartet wird und die host-basierte
   Authentifizierung in der Datei $PGDATA/pg_hba.conf entsprechend
   angepasst ist.
   
    3.6) Wie optimiere ich die Datenbank für bessere Leistung?
    
   Der Einsatz von Indizes sollte auf jeden Fall Abfragen beschleunigen.
   Die Anweisung EXPLAIN zeigt, wie PostgreSQL Abfragen interpretiert und
   welche Indizes benutzt werden.
   
   Wenn Sie eine große Anzahl von INSERT-Anweisungen durchführen, sollten
   Sie überlegen, ob die Durchführung mit der COPY-Anweisung in Frage
   kommt. Dies funktioniert wesentlich schneller als einzelne
   INSERT-Befehle. SQL-Anweisungen, die sich nicht in einem BEGIN
   WORK/COMMIT Transaktions- Block befinden, werden als eigene
   Transaktionen behandelt. Überlegen Sie, ob die Anweisungen nicht in
   einen einzelnen Transaktionsblock zusammen- gefasst werden können. Das
   reduziert den Transaktionsaufwand. Überlegen Sie auch, bei größeren
   Datenänderungen Indizes zu löschen und danach wiederherzustellen.
   
   Es gibt verschiedene Tuning-Optionen. Sie können fsync() ausschalten,
   indem Sie beim Starten des postmaster die Optionen -o -F angeben. Das
   hindert fsync()-Operationen daran, nach jeder Transaktion die Daten
   direkt auf die Festplatte zu schreiben.
   
   Sie können auch mit der -B Option des postmaster die Anzahl der Shared
   Memory Puffer für die Backend-Prozesse erhöhen. Falls Sie diesen Wert
   jedoch zu hoch setzen, kann es vorkommen, dass der postmaster nicht
   startet, weil die Obergrenze der Speicherzuweisung für Shared Memory
   überschritten wird. Jeder Puffer ist 8 kB groß, standardmäßig gibt es
   64 Puffer.
   
   Sie können auch die -S Option des Backends nutzen, um die Größe des
   Speicherplatzes für temporäres Sortieren zu erhöhen. Der -S Wert wird
   in Kilobyte gemessen und ist standardmäßig auf 512 kB festgelegt.
   
   Die CLUSTER-Anweisung kann benutzt werden, um Daten in Basistabellen
   zu gruppieren, so dass sie auf einen Index zusammengebracht werden.
   Siehe auch die CLUSTER(l) Man-Page für weitere Details.
   
    3.7) Welche Debugging-Funktionen sind für PostgreSQL verfügbar?
    
   PostgreSQL hat einige Möglichkeiten, Statusinformationen anzuzeigen,
   die bei der Fehlersuche nützlich sein können.
   
   Wenn Sie PostgreSQL mit dem --enable-cassert Option kompiliert haben,
   verfolgen zahlreiche assert()-Anweisungen den Ablauf des Backends und
   halten das Programm an, wenn etwas Unerwartetes passiert.
   
   Sowohl der postmaster als auch postgres stellen mehrere Debug-Optionen
   zur Verfügung. Stellen Sie zuerst sicher, dass Sie den Standard-Output
   und den Fehlerkanal in eine Datei umleiten, wenn Sie den postmaster
   starten:
      cd /usr/local/pgsql
      ./bin/postmaster >server.log 2>&1 &

   Dadurch wird die Datei server.log im PostgreSQL-Verzeichnis erzeugt.
   Diese Datei enthält nützliche Informationen über Probleme oder Fehler,
   die im Server aufgetreten sind. postmaster hat eine -d Option, die
   noch detailliertere Informationen liefert. Zur -d Option wird eine
   Nummer angegeben, die den Debug-Level - also die Menge der berichteten
   Information - angibt. Achtung, hohe Debug-Levels erzeugen schnell
   große Logdateien!
   
   Wenn der postmaster nicht läuft, können Sie sogar den postgres-Backend
   von der Befehlszeile ausführen und eine SQL-Anweisung direkt eingeben.
   Dies ist nur für Debugging-Zwecke zu empfehlen. Beachten Sie, dass ein
   Zeilenumbruch, und nicht das Semikolon die SQL-Anweisung beendet.
   Falls Sie PostgreSQL mit Debugging-Symbolen kompiliert haben, können
   Sie mit einem Debugger sehen, was passiert. Da das Backend jedoch
   nicht vom postmaster gestartet wurde, läuft es nicht in der gleichen
   Umgebung und deshalb können einige locking/backend Operationen nicht
   reproduziert werden.
   
   Wenn dagegen der postmaster läuft, führen Sie psql in einem Fenster
   aus, dann ermitteln Sie die Prozessnummer (PID) des
   postgres-Prozesses, der von psql verwendet wird. Binden Sie einen
   Debugger an diese PID und führen Sie Abfragen von psql aus. Wenn Sie
   den postgres-Serverstart analysieren wollen, setzen Sie die
   Umgebungsvariable PGOPTIONS="-W n", und starten Sie dann psql. Dies
   verzögert den Start um n Sekunden, damit Sie einen Debugger an den
   Prozess binden können und ggf. Breakpoints setzen, bevor die
   Startsequenz begonnen wird.
   
   Das Programm postgres hat auch die Optionen -s, -A und -t, die bei der
   Fehlersuche und Performanzmessung sehr nützlich sein können.
   
   Sie können die Anwendung auch mit Profiling kompilieren, um zu sehen,
   welche Funktionen wieviel Ausführungszeit beanspruchen. Das Backend
   Profil wird im Verzeichnis pgsql/data/base/dbname abgelegt. Das
   Client-Profil wird in das aktuelle Verzeichnis abgelegt. Bitte
   beachtern Sie, dass unter Linux PostgreSQL mit der Option
   -DLINUX_PROFILE kompiliert werden muß, um Profiling nutzen zu können.
   
    3.8) Ich bekomme die Meldung "Sorry, too many clients", wenn ich eine
    Verbindung augzubauen versuche. Warum?
    
   Sie müssen die maximale Anzahl der gleichzeitig ausfühbaren Backend-
   Prozesse hochsetzen.
   
   Die Voreinstellung ist 32 Prozesse. Sie können diese erhöhen, indem
   Sie den postmaster mit einem entsprechenden -N Parameter starten bzw.
   die Konfigurationsdatei postgresql.conf anpassen.
   
   Bitte beachten Sie, dass Sie auch -B auf ein Wert größer als die
   Voreinstellung von 64 setzen müssen, wenn Sie -N auf einen Wert höher
   als 32 setzen; -B muss mindestens das Doppelte von -N betragen, und
   einer besseren Performanz wegen sollte der Wert noch höher sein. Bei
   einer hohen Anzahl von Backend-Prozessen kann es vorkommen, dass Sie
   einige Unix-Kernel- Parameter ebenfalls erhöhen müssen. Folgende
   Parameter sind zu überprüfen: die Maximalgröße der Shared Memory
   Blocks SHMMAX; die Maximalanzahl der Semaphoren SEMMNS und SEMMNI; die
   maximale Anzahl von Prozessen NPROC; die maximale Anzahl von Prozessen
   pro User MAXUPRC; und die Maximalzahl der geöffneten Dateien NFILE und
   NINODE. Durch die Begrenzung der Anzahl erlaubter Backend-Prozesse
   wird verhindert, dass System-Ressourcen durch PostgreSQL aufgebraucht
   werden.
   
    3.9) Was befindet sich im Verzeichnis pgsql_tmp/?
    
   Dieses Verzeichnis enthält temporäre Dateien, die durch den query
   executor erzeugt werden. Wenn zum Beispiel eine Sortierung
   durchgeführt werden muß, um ein ORDER BY auszuführen, und diese
   Sortierung mehr Hauptspeicher benötigt, als mit dem Backend-Parameter
   -S erlaubt wurde, dann werden diese Dateien erzeugt, um die Daten dort
   zu auszulagern.
   
   Die temporären Dateien sollten automatisch gelöscht werden. Falls das
   Backend jedoch während einer Sortierung abstürzen sollte, bleiben sie
   erhalten. Nach einem Neustart des postmaster werden sie auomatisch
   gelöscht.
   
    3.10) Warum muß ich bei jeder neuen Hauptversion von PostgreSQL die
    komplette Datenbank exportieren und anschließend reimportieren?
    
   Zwischen "kleinen" PostgreSQL-Versionsänderungen (z.B. zwischen 7.2
   und 7.2.1) werden keine strukturellen Änderungen durchgeführt, wodurch
   ein erneutes Aus- und Einlesen der Daten nicht benötigt wird.
   Allerdings wird bei "großen" Versionsänderungen (z.B. zwischen 7.2 und
   7.3) oft das interne Format der Systemtabellen und Datendateien
   angepasst. Diese Änderungen sind oft sehr komplex, wodurch die
   Rückwärtskompatibilität der Datendateien nicht gewährleistet werden
   kann. Durch das Exportieren werden die Daten in einem generischen
   Format ausgegeben, wodurch die Importierung in das neue interne Format
   ermöglicht wird.
   
   Bei Versionenwechseln, wo kein Formatänderungen stattgefunden haben,
   kann das pg_upgrade-Skript benutzt werden, um die Daten ohne Aus- und
   Einlesen zu übertragen. Die jeweilige Dokumentation gibt an, ob für
   die betreffende Version pg_upgrade verfügbar ist.
     _________________________________________________________________
   
                             Fragen zum Betrieb
                                      
    4.1) Worin besteht der Unterschied zwischen Binary Cursors und Normal
    Cursors?
    
   Vgl. die DECLARE Man-Page für eine Beschreibung.
   
    4.2) Wie wähle ich per SELECT-Anweisung nur die ersten paar Zeilen bzw.
    eine beliebige Zeile in einer Abfrage aus?
    
   Vgl. die FETCH Man-Page, oder benutzen Sie SELECT ... LIMIT... .
   
   Selbst wenn Sie nur die ersten paar Zeilen einer Tabelle abfragen
   möchten, muß unter Umständen die komplette Abfrage abgearbeitet
   werden. Ziehen Sie also möglichst eine Abfrage in Erwägung, die eine
   ORDER BY-Anweisung benutzt, die wiederum auf indizierte Spalten
   verweist. In diesem Fall kann PostgreSQL direkt nach den gewünschten
   Zeilen suchen und braucht nicht jede mögliche Ergebniszeile
   abzuarbeiten.
   
   Bitte beachten Sie, dass mit PostgreSQL 7.3 die Syntax LIMIT n, m
   durch LIMIT n OFFSET m ersetzt wurde.
   
   Um eine beliebige Zeile auszuwählen, nutzen Sie ORDER BY random():
       SELECT spalte
         FROM tabelle
     ORDER BY random()
        LIMIT 1;


    4.3) Wie bekomme ich eine Liste der Tabellen oder anderen Dinge, die ich in
    psql sehen kann?
    
   Sie können sich die Datei pgsql/src/bin/psql/describe.c mit dem
   Quellcode für psql ansehen. Sie enthält die SQL-Abfragen, die die
   Backslash-Kommandos (\) ausführen. Sie können psql auch mit der -E
   Option starten. Danach gibt psql die Abfragen aus, die es bei der
   Ausführung der Befehle benutzt.
   
    4.4) Wie entferne ich eine Spalte aus einer Tabelle? Wie ändere ich den
    Datentyp einer Spalte?
    
   Der Syntax ALTER TABLE DROP COLUMN wird ab PostgreSQL 7.3 unterstützt.
   
   Bei früheren Versionen bietet das folgende Verfahren Ersatz:
      BEGIN;
      LOCK TABLE old_table;
      SELECT ...  -- alle außer der zu entfernenden Spalte hier auswählen
        INTO TABLE new_table
        FROM old_table;
      DROP TABLE old_table;
      ALTER TABLE new_table RENAME TO old_table;
      COMMIT;

   Um den Datentyp einer Spalte zu ändern, gehen Sie wie folgt vor:
       BEGIN;
       ALTER TABLE tabelle ADD COLUMN neue_spalte neuer_datentyp;
       UPDATE tabelle SET neue_spalte = CAST(alte_spalte AS neuer_datentyp);
       ALTER TABLE tabelle DROP COLUMN alte_spalte;
       COMMIT;


   Um den Platz zu reklamieren, der von der gelöschten Spalte verwendet
   wurde, führen Sie VACUUM FULL aus.
   
    4.5) Was ist die Maximalgröße für eine Zeile, eine Tabelle, eine Datenbank?
    
   Es bestehen folgende Obergrenzen:
    Maximale Größe eine Datenbank?           unbeschränkt (es existieren
                                               Datenbanken mit 4TB)
    Maximale Größe einer Tabelle?            32 TB
    Maximale Größe einer Zeile?              1,6 TB
    Maximale Größe einer Spalte?             1 GB
    Maximale Anzahl von Zeilen in einer Tabelle?
                                             unbeschränkt
    Maximale Anzahl von Spalten in einer Tabelle?
                                             250-1600 je nach Spaltentyp
    Maximale Anzahl von Indizies für eine Tabelle?
                                             unbeschränkt

   Selbstverständlich sind dies theoretische Werte, die oft durch die
   verfügbaren Platten- und Speicherressourcen eingeschränkt sind.
   Extreme Größen können zu Leistungseinbußen führen.
   
   Die maximale Tabellengröße von 32 TB benötigt keine
   Large-File-Unterstützung im Betriebssystem. Große Tabellen werden in
   Dateien mit einer Größe von 1 GB aufgeteilt, wodurch etwaige
   dateisystem-bedingte Beschränkungen nicht relevant sind.
   
   Die maximale Tabellengröße und die maximale Anzahl von Spalten können
   gesteigert werden, wenn die Default-Blockgröße auf 32 KB heraufgesetzt
   wird.
   
    4.6) Wieviel Plattenplatz wird benötigt, um die Daten aus einer typischen
    Textdatei abzuspeichern?
    
   Eine PostgreSQL-Datenbank kann beim Abspeichern einer einfachen
   Textdatei bis zu fünfmal mehr Platz gegenüber der eigentlichen Größe
   der Datei beanspruchen.
   
   Betrachten wir eine Datei mit 100.000 Zeilen mit einem Integer und
   einer Textbeschreibung pro Zeile. Gehen wir davon aus, dass die
   durchschnittliche Länge der Textbeschreibung 20 Byte beträgt. Die
   einfache Datei würde 2,8 MB groß sein. Die Größe der
   PostgreSQL-Datenbankdatei, die diese Daten enthält, liegt ungefähr bei
   6,4 MB:
    36 Bytes: jeder Zeilenkopf (ungefähr)
   +24 Bytes: ein Integer-Feld und ein Textfeld
   + 4 Bytes: Zeiger auf der Datenseite auf den Tupel
   -----------------------------------------------
    64 Bytes pro Zeile

   Die Größe einer Datenseite in PostgreSQL beträgt 8192 Bytes (8 KB),
   also:
   8192 Bytes pro Seite
   ---------------------   =  128 Zeilen pro Seite (abgerundet)
     64 Bytes pro Zeile

   100.000 Datenzeilen
   -----------------------  =  782 Datenbankseiten (aufgerundet)
       128 Zeilen pro Seite

   782 Datenbankseiten * 8192 Bytes pro Seite  =  6.406.144 Byte (6,4 MB)

   Indizes beanspruchen nicht so viel Platz. Da sie jedoch die Daten
   beinhalten, die sie indizieren, können auch sie sehr groß werden.
   
   NULL-Werte werden als Bitmaps gespeichert, wodurch sie sehr wenig
   Platz in Anspruch nehmen.
   
    4.7) Wie finde ich heraus, welche Indizes oder Operationen in der Datenbank
    definiert sind?
    
   psql hat eine Vielzahl von Backslash-Befehlen, mit denen solche
   Informationen angezeigt werden können. Der Befehl \? zeigt eine
   Übersicht. Außerdem zeigt der Befehl \l eine Liste von allen
   verfügbaren Datenbanken an.
   
   Die Datei pgsql/src/tutorial/syscat.source enthält außerdem viele
   SELECT-Anweisungen, mit deren Hilfe man Information über die
   Systemtabellen erhalten kann.
   
    4.8) Meine Abfragen sind langsam oder nutzen die Indizes nicht. Warum?
    
   Indizes werden nicht automatisch bei jeder Abfrage verwendet. Indizes
   werden nur dann verwendet, wenn die abzufragende Tabelle eine
   bestimmte Größe übersteigt, und die Abfrage nur eine kleine
   Prozentzahl der Tabellenzeilen abfragt. Grund hierfür ist, dass die
   durch einen Index verursachten Festplattenzugriffe manchmal langsamer
   sind als ein einfaches Auslesen aller Tabellenzeilen (sequentieller
   Scan).
   
   Um festzustellen, ob ein Index verwendet werden soll, braucht
   PostgreSQL Statistiken über die Tabelle. Diese Statistiken werden
   durch die Anweisungen VACUUM ANALYZE bzw. ANALYZE berechnet. Anhand
   der Statistiken kennt der Abfragenoptimierer die Anzahl der
   Tabellenzeilen und kann besser entscheiden, ob Indizes verwendet
   werden sollen. Statistiken sind auch bei der Feststellung optimaler
   JOIN-Reihenfolge und -Methoden wertvoll.
   
   Indizes werden normalerweise nicht in ORDER BY-Abfrage oder in JOINs
   verwendet. Ein sequentieller Scan mit anschließendem explizitem
   Sortiervorgang ist normalerweise schneller als ein Index-Scan einer
   großen Tabelle. Jedoch wird bei einer Abfrage, in der LIMIT zusammen
   mit ORDER BY verwendet wird, oftmals ein Index verwendet, da nur ein
   kleiner Abschnitt der Tabelle zurückgeliefert wird. Dadurch wird es
   auch möglich, die Minimal- und Maximalwerte einer Abfrage unter
   Verwendung von Indizes zu ermitteln:
       SELECT spalte
         FROM tabelle
     ORDER BY spalte [ DESC ]
        LIMIT 1

   (Die Aggregatfunktionen MIN() und MAX() verwenden keine Indizes).
   
   Sollte es danach aussehen, also ob der Optimierer irrtümlich einen
   sequentiellen Scan ausführt, führen Sie SET enable_seqscan TO 'off'
   aus und prüfen Sie, ob die Indexabfrage dadurch scheller geworden ist.
   
   Bei der Nutzung von Wildcard-Operatoren wie LIKE oder ~, können
   Indizes nur unter bestimmten Umständen verwendet werden:
     * Der Anfang des Suchmusters muß mit dem Anfang des Strings
       verknüpft werden, d.h.:
          + LIKE-Suchmuster dürfen nicht mit % anfangen;
          + ~ (reguläre Ausdrücke) müssen mit ^ anfangen.
     * Das Suchmuster darf nicht mit einer Zeichenklasse (z.B. [a-e])
       anfangen
       
   Suchmuster, die Gross- und Kleinschreibung nicht berücksichtigen (z.B.
   ILIKE bzw. ~*), verwenden keine Indizes. Stattdessen können
   funktionale Indizes verwendet werden, die im Punkt 4.12 beschrieben
   werden.
   
   Die C-Locale muß während der Datenbank-Initialisierung mit initdb
   bestimmt worden sein.
   
    4.9) Auf welche Weise kann ich sehen, wie der Abfrage-Optimierer meine
    Abfrage auswertet?
    
   Vgl. die EXPLAIN Man-Page.
   
    4.10) Was ist ein R-Tree Index?
    
   Ein R-Tree Index wird benutzt, um räumliche Daten zu indizieren. Ein
   Hash-Index kann nicht für Bereichssuchen genutzt werden. Ein B-Tree
   Index kann nur für Bereichssuchen in eindimensionalen Daten genutzt
   werden. R-Trees können multi-dimensionale Daten abhandeln. Ein
   Beispiel: Wenn ein R-Tree Index auf ein Attribut vom Typ POINT
   gebildet wird, dann kann das System Abfragen wie z.B. "Zeige alle
   Punkte, die sich in einem umgebenden Rechteck befinden" effizienter
   beantworten.
   
   Die kanonische Veröffentlichung, die das originale R-Tree Design
   beschreibt, ist:
   
   Guttman, A. "R-Trees: A Dynamic Index Structure for Spatial
   Searching." Proc of the 1984 ACM SIGMOD Int'l Conf on Mgmt of Data,
   45-57.
   
   Sie können dieses Werk auch in Stonebrakers "Readings in Database
   Systems" finden.
   
   Die eingebauten R-Trees können Polygone und Rechtecke verarbeiten.
   Theoretisch können R-Trees auf eine hohe Anzahl von Dimensionen
   erweitert werden. Praktisch bedingt diese Erweiterung eine Menge
   Arbeit und wir haben derzeit keinerlei Dokumentation darüber, wie das
   zu machen wäre.
   
    4.11) Was ist der "Genetic Query Optimizer"?
    
   Das GEQO-Modul in PostgreSQL soll dazu dienen, das Optimierungsproblem
   beim JOIN von vielen Tabellen auf der Basis genetischer Algorithmen
   (GA) zu lösen. Es ermöglicht die Behandlung von großen JOIN-Queries
   durch eine nicht-erschöpfende Suche.
   
    4.12) Wie verfahre ich bei der Suche mit regulären Ausdrücken und bei einer
    Suche, bei der Groß- und Kleinschreibweisen ignoriert werden? Wie verwende
    ich einen Index bei solchen Suchabfragen?
    
   Der Operator ~ bewirkt die Anwendung eines regulären Ausdrucks. ~*
   führt zur Anwendung eines regulären Ausdrucks mit Ignorierung der
   Groß- und Kleinschreibung.
   
   Gleichheitsvergleiche, die Groß- und Kleinschreibung ignorieren,
   werden in der Regel so ausgedruckt:
      SELECT *
        FROM tabelle
       WHERE LOWER(spalte) = 'abc'

   Ein funktionaler Index, der wie folgt erstellt wird, wird auf jeden
   Fall verwendet:
      CREATE INDEX tabelle_index ON tabelle (LOWER(spalte))

    4.13) Wie ermittle ich in einer Abfrage, ob ein Feld NULL ist?
    
   Testen Sie die Spalte mit IS NULL bzw. IS NOT NULL.
   
    4.14) Was ist der Unterschied zwischen den verschiedenen CHAR-Typen?
    
Typ           interner Name   Bemerkungen
-------------------------------------------------
VARCHAR(n)    varchar         die Größe legt die Maximallänge fest; kein
                               Ausfüllen mit Leerzeichen
CHAR(n)       bpchar          mit Leerzeichen gefüllt bis zur angegebenen Länge
TEXT          text            Die Länge wird nur durch die maximale Zeilenlänge
                               beschränkt
BYTEA         bytea           Bytearray mit variabler Länge
"char"        char            1 Zeichen

   Der interne Name kommt vor allem in den Systemkatalogen und in manchen
   Fehlermeldungen vor.
   
   Die ersten vier Typen sind "varlena"-Typen (d.h. die ersten vier Bytes
   geben die Länge an, gefolgt von den Daten). Daher ist der tatsächlich
   belegte Platz immer etwas mehr als die deklarierte Feldgröße.
   Allerdings wird unter Umständen auf diese Datentypen Datenkompression
   durch das TOAST- Verfahren angewendet, womit der tatsächlich belegte
   Platz auch geringer als erwartet ausfallen kann.
   
   Für die Speicherung von Zeichenketten variabler Länge empfiehlt sich
   VARCHAR(n). Die maximale Länge eines VARCHAR(n)-Felds wird bei der
   Tabellendefinition festgelegt. TEXT setzt keine Längengrenze,
   allerdings gibt es eine systembedingte Obergrenze von 1 GB.
   
   CHAR(n) ist geeignet für die Speicherung von Zeichenketten, die alle
   die gleiche Länge haben. Bitte beachten Sie, dass CHAR(n) automatisch
   Zeichenketten bis zur definierten Feldlänge mit Leerzeichen ausfüllt,
   während bei VARCHAR(n) nur die tatsächlich eingegebene Zeichenkette
   gespeichert wird.
   
   BYTEA ist für binäre Daten, besonders für Werte, die NULL-Bytes haben.
   
   Die hier erwähnten Typen weisen ähnliche Performanzeigenschaften auf.
   
    4.15.1) Wie erzeuge ich ein serielles Feld mit automatischer Erhöhung des
    Werts?
    
   PostgreSQL bietet einen SERIAL-Datentyp. Dieser erzeugt automatisch
   eine Sequenz auf die angegebene Spalte. Zum Beispiel:
      CREATE TABLE person (
          id   SERIAL,
          name TEXT
      )

   wird automatisch in:
      CREATE SEQUENCE person_id_seq;
      CREATE TABLE person (
        id   INT4 NOT NULL DEFAULT nextval('person_id_seq'),
        name TEXT
      );

   umgewandelt.
   
   Die create_sequence Man-Page liefert weitere Informationen über
   Sequenzen. Es ist auch möglich, den OID-Wert jeder Spalte als
   einmaligen Wert einzusetzen. Sollten Sie allerdings die Datenbank
   exportieren und reimportieren wollen, müssen Sie die Option -o von
   pg_dump bzw. COPY WITH OIDS verwenden, um die OIDs beizubehalten.
   
    4.15.2) Wie bekomme ich den Wert einer SERIAL-Sequenz?
    
   Eine Möglichkeit wäre, mit der nextval()-Funktion den nächsten
   SERIAL-Wert von dem Sequenzobjekt vor der Auszuführung einer
   INSERT-Anweisung anzufordern und ihn dann explizit in die
   INSERT-Anweisung einzubinden. Anhand der Beispieltabelle in 4.15.1
   könnte dieser Vorgang in einer Pseudosprache so aussehen:
    new_id = output of execute("SELECT nextval('person_id_seq')");
    execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");

   Danach stünde der neue Wert in der Variablen new_id für die Verwendung
   in weiteren Abfragen zur Verfügung, zum Beispiel als Fremdschlüssel
   zur Tabelle 'person'). Bitte beachten Sie, dass der Name des
   automatisch erstellten SEQUENCE-Objektes folgenden Name hat:
   <table>_<serialcolumn>_seq wobei 'table' und 'serialcolumn' die Namen
   der jeweils betreffenden Tabelle / Spalte darstellen.
   
   Als weitere Möglichkeit können Sie nach einer INSERT-Anweisung den
   automatisch eingefügten SERIAL-Wert mit der currval()-Funktion
   zurückgeben lassen:
    execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");
    new_id = output of execute("SELECT currval('person_id_seq')");

   Schließlich besteht noch die Möglichkeit, den von einer
   INSERT-Anweisung zurückgelieferten OID-Wert als einmaligen Wert zu
   verwenden. Dieser Ansatz ist allerdings PostgreSQL-spezifisch;
   außerdem wird nach ca. 4 Milliarden Einträgen der OID-Wert wieder auf
   eine kleine Zahl gesetzt, ist also nicht garantiert einmalig.
   
   In Perl mit dem DBD::Pg-Modul wird der OID-Wert nach einem
   $sth->excute() über $sth->{pg_oid_status} zurückgeliefert.
   
    4.15.3) Führen currval() und nextval() zu einer Race-Condition mit anderen
    Nutzern?
    
   Nein. Die Funktionen liefern einen Wert zurück, der von Ihrem Backend
   bestimmt wird, und der anderen Benutzern nicht zur Verfügung steht.
   
    4.15.4) Warum werden die Sequenzwerte nach einem Transaktionsabbruch nicht
    zurückgesetzt? Warum gibt es Lücken in der Nummerierung meiner
    Sequenz-/SERIAL-Spalte?
    
   Um die konkurrente Verarbeitung zu verbessern, werden Sequenzwerte
   nach Bedarf an laufende Transaktionen zugeteilt und erst beim Abschluß
   der Transaktion gesperrt. Durch abgebrochene Transaktionen werden
   Lücken in der Sequenznummerierung verursacht.
   
    4.16) Was ist ein OID? Was ist ein TID?
    
   OIDs sind PostgreSQLs Antwort auf eindeutige Zeilen-IDs. Jede Zeile,
   die in PostgreSQL erzeugt wird, bekommt eine eindeutige OID. Alle
   OIDs, die durch initdb erzeugt werden, sind kleiner als 16384 (siehe
   include/access/transam.h). Alle OIDs, die durch den Benutzer erzeugt
   werden, sind gleich oder größer als dieser Wert. Standardmäßig sind
   all OIDs nicht nur innerhalb einer Tabelle oder Datenbank, sondern in
   der gesamten PostgreSQL-Installation einmalig.
   
   PostgreSQL benutzt OIDs in seinen internen Systemtabellen, um Zeilen
   in JOINs zwischen Tabellen zu verknüpfen. Es ist möglich, einen Index
   für die OID-Spalte zu erstellen, wodurch schnellere Zugriffszeiten
   erreicht werden können. Es wird empfohlen, OID-Werte in Spalten vom
   Typ OID zu speichern.
   
   OIDs werden allen neuen Zeilen von einem zentralen Bereich, der von
   allen Datenbanken genutzt wird, zugewiesen. Nichts hindert Sie daran,
   die OID zu ändern, oder eine Kopie der Tabelle mit den originalen Oids
   anzulegen:
      CREATE TABLE new_table(old_oid OID, mycol INT);
      SELECT INTO new SELECT old_oid, mycol FROM old;
      COPY new TO '/tmp/pgtable';
      DELETE FROM new;
      COPY new WITH OIDS FROM '/tmp/pgtable';

    4.17) Welche Bedeutung haben die verschiedenen Ausdrücke, die in PostgreSQL
    benutzt werden (z.B. attribute, class,...)?
    
   Einige der Quelltexte und die ältere Dokumentation nutzen allgemeine
   Begriffe. Hier sind einige aufgeführt:
     * row, record, tuple
     * attribute, field, column
     * table, class
     * retrieve, SELECT
     * replace, UPDATE
     * append, INSERT
     * oid, serial value
     * portal, cursor
     * range variable, table name, table alias
       
   Eine allgemeine Liste der Datenbank-Terminologie erhalten Sie hier:
   http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary
   /glossary.html (engl.).
   
    4.18) Wieso bekomme ich einen Fehler: "ERROR: Memory exhausted in
    AllocSetAlloc()"?
    
   Wahrscheinlich gibt es keinen virtuellen Speicher mehr in Ihrem System
   oder Ihr Kernel hat niedrige Höchstgrenzen für bestimmte Ressourcen.
   Probieren Sie vor dem Start von postmaster folgendes:
      ulimit -d 262144
      limit datasize 256m

   Je nach benutzter Shell wird nur einer dieser Befehle erfolgreich
   ausgeführt werden. Auf jedem Fall wird die Grenze des Datensegments
   für Prozesse erhöht werden und eventuell die erfolgreiche Ausführung
   der Abfrage ermöglichen. Falls Sie ein Problem mit dem SQL-CLient
   haben, weil das Backend zu viele Daten zurückliefert, versuchen Sie
   dies vor dem Start des SQL-Clients.
   
    4.19) Wie kann ich feststellen, welche PostgreSQL-Version bei mir läuft?
    
   Geben Sie in psql SELECT VERSION(); ein.
   
    4.20) Bei "large-object"-Operationen kommt die Fehlermeldung: "invalid
    large obj descriptor". Warum?
    
   Sie sollten die Anweisungen BEGIN WORK und COMMIT bei jeden Gebrauch
   von Large Objects benutzen. Also um lo_open ... lo_close.
   
   Derzeit erzwingt PostgreSQL diese Regel, indem es die Handles der
   Large Objects beim COMMIT der Transaktion schließt. So führt der erste
   Versuch, etwas mit dem Large Object zu machen, zu einer Meldung
   "invalid large obj descriptor". Solange Sie keine Transaktionen
   benutzen, wird der Code, der in älteren PostgreSQL-Versionen
   funktionierte, nun diese Fehlermeldung erzeugen.
   
   Falls Sie eine Client-Schnittstelle wie ODBC benutzen, kann es sein,
   dass die auto-commit-Option ausgeschaltet werden muss.
   
    4.21) Wie kann ich eine Spalte erstellen, deren Default-Wert immer die
    aktuelle Uhrzeit enthalten soll?
    
   Dazu verwenden Sie CURRENT_TIMESTAMP:
      CREATE TABLE test (x int, modtime timestamp DEFAULT CURRENT_TIMESTAMP );

    4.22) Warum sind meine Unterabfragen (subqueries), die IN verwenden, so
    langsam?
    
   In Versionen vor 7.4 werden Unterabfragen mit der äusseren Abfrage
   verbunden, in dem für jede Reihe der äusseren Query die Ergebnisse der
   Unterabfrage sequentiell geprüft werden. Um dies zu vermeiden, kann
   man IN durch EXISTS ersetzen, z.B.:
      SELECT *
        FROM tabelle_1
       WHERE spalte1 IN (SELECT spalte2 FROM tabelle_2)

   in:
      SELECT *
        FROM tabelle_1
       WHERE EXISTS (SELECT spalte2 FROM tabelle_2 WHERE spalte1 = spalte2)

   Damit diese Abfrage effizient durchgeführt wird, sollte für 'spalte2'
   ein Index angelegt worden sein. Ab PostgreSQL 7.4 IN verwendet die
   gleichen Methoden wie die normale Tabellenverknüpfung und ist daher
   soger EXISTS vorzuziehen.
   
    4.23) Wie führe ich einen OUTER JOIN durch?
    
   PostgreSQL ab der Version 7.1 unterstützt OUTER JOINs nach dem SQL-
   Standardsyntax. Hier zwei Beispiele:
      SELECT *
        FROM tabelle_1 t1
             LEFT OUTER JOIN tabelle_2 t2 ON (t1.spalte = t2.spalte)

   bzw.:
      SELECT *
        FROM tabelle_1 t1
             LEFT OUTER JOIN tabelle_2 t2 USING (spalte)

   Diese identischen Abfragen verknüpfen tabelle_1 mit tabelle_2 über die
   Spalte 'spalte' und geben außerdem alle unverknüpften Zeilen in
   tabelle_1 (diejenigen, die keine Entsprechung in tabelle_2 haben)
   zurück. Ein FULL JOIN würde dagegen alle verknüpften Zeilen sowie
   jeweils alle unverknüpften Zeilen aus den beiden Tabellen verknüpfen.
   Die Angabe von OUTER ist nicht zwingend und kann in LEFT, RIGHT und
   FULL-Verknüpfungen weggelassen werden. Normale Verknüpfungen sind
   INNER JOINs.
   
   In früheren Versionen von PostgreSQL können OUTER JOINs mittels UNION
   und NOT IN simuliert werden. Zum Beispiel 'tabelle_1' und 'tabelle_2'
   können als LEFT OUTER JOIN auch so verknüpft werden:
      SELECT t1.spalte1, t2.spalte2
        FROM tabelle_1 t1, tabelle_2 t2
       WHERE t1.spalte1 = t2.spalte1
       UNION ALL
      SELECT t1.spalte1, NULL
        FROM tabelle_1 t1
       WHERE t1.spalte1 NOT IN (SELECT t2.spalte1 FROM tabelle_2 t2)
       ORDER BY spalte1

    4.24) Wie kann ich Abfragen über mehrere Datenbanken hinweg ausführen?
    
   Es gibt keinen Weg, innerhalb einer Abfrage auf mehr als eine
   Datenbank zuzugreifen. Da PostgreSQL datenbank-spezifische
   Systemkataloge lädt, ist eine datenbankübergreifende Abfrage nicht
   möglich.
   
   contrib/dblink ist eine Erweiterung, die datenbankübergreifende
   Abfragen ermöglicht.
   
   Es ist natürlich möglich, dass eine Client-Anwendung gleichzeitige
   Verbindungen zu verschiedenen Datenbanken aufbaut und selber
   Datensätze zusammenfügt.
   
   Ab 7.3 unterstützt PostgreSQL schemas, die die Aufteilung einer
   Datenbank in mehrere logische Bereiche ermöglichen. Bei vielen
   Anwendungen könnten dies einen geeigneten Ersatz für den Zugriff auf
   eine andere Datenbank bieten.
   
    4.25) Wie kann ich mehrere Zeilen bzw. Spalten von einer Funktion
    zurückgeben lassen?
    
   Ab 7.3 können Funktionen mehrere Zeilen und Spalten zurückgeben, vgl.:
   http://techdocs.postgresql.org/guides/SetReturningFunctions.
   
    4.26) Warum kann ich temporäre Tabellen in PL/PgSQL-Funktionen nicht
    zuverlässig erstellen bzw. löschen?
    
   PL/PgSQL verarbeitet die Inhalte einer Funktion in einer Cache. Dies
   hat eine unangenehme Nebenwirkung, nämlich dass wenn eine PL/PgSQL-
   Funktion auf eine temporäre Tabelle zugreift, und diese Tabelle
   anschließend gelöscht bzw. neu erstellt wird, die Funktion
   fehlschlagen wird, da die gecachte Funktionsinhalte noch auf die alte
   temporäre Tabelle zeigen.
   
   Die Lösung für diese Probleme besteht darin, in der Funktion mittels
   EXECUTE auf temporäre Tabellen zuzugreifen. Diese bewirkt, dass bei
   jedem Funktionsruf die betreffende Abfrage von PL/PgSQL neu geparst
   wird.
   
    4.27) Welche Möglichkeiten zur Datenbank-Replikation gibt es?
    
   Es existieren mehrere Ansätze zur Master/Slave-Replikation in
   PostgreSQL. In diesen werden Datenänderungen in der Master-Datenbank
   durchgeführt und an Slave-Datenbanken weitergeleitet. Informationen
   über diese Lösungen befinden sich auf der folgenden Seite (unten):
   http://gborg.PostgreSQL.org/genpage?replication_research .
   
   Eine Multi-Master-Lösung befindet sich in der Entwicklung. Näheres
   dazu befindet sich hier:
   http://gborg.PostgreSQL.org/project/pgreplication/projdisplay.php .
   
    4.28) Welche Möglichkeiten zur Verschlüsselung gibt es?
    
     * contrib/pgcrypto enthält diverse Funktionen für die Benützung mit
       SQL-Abfragen.
     * Um Verbindungen zwischen dem Server und Client-Anwendungen zu
       verschlüsseln, muss in der Server-Konfigurationsdatei
       postgresql.conf die ssl-Option auf true (Voreinstellung: false)
       gesetzt werden und ein passender host- bzw. hostssl-Eintrag muss
       in pg_hba.conf vorhanden sein. Zudem muss die sslmode-Einstellung
       beim Client nicht auf disable gesetzt werden. (Bitte beachten Sie
       auch, daß neben der eingebauten SSL-Unterstützung verschlüsselte
       Verbindungen auch über externe Anwendungen wie stunnel oder ssh
       aufgebaut werden können).
     * Die Passwörter der Datenbanknutzer werden ab Version 7.3
       automatisch verschlüsselt (in früheren Versionen muß der Parameter
       PASSWORD_ENCRYPTION in postgresql.conf explizit eingeschaltet
       werden).
     * Betrieb des Servers auf einem verschlüsselten Dateisystem.
     _________________________________________________________________
   
                            PostgreSQL erweitern
                                      
    5.1) Ich habe eine benutzerdefinierte Funktion geschrieben. Wenn ich sie in
    psql aufrufe, kommt ein core dump. Warum?
    
   Dieses Problem kann viele Ursachen haben. Testen Sie Ihre Funktion
   zuerst in einem eigenen Testprogramm.
   
    5.2) Wie kann ich praktische neue Typen und Funktionen zu PostgreSQL
    hinzufügen?
    
   Senden Sie Ihre Beiträge an die Mailing Liste pgsql-hackers, und sie
   werden nach Prüfung eventuell ins contrib/ Verzeichnis des Quellcodes
   aufgenommen werden.
   
    5.3) Wie schreibe ich eine Funktion in C, die einen Tupel zurückliefert?
    
   Ab PostgreSQL 7.3 werden Funktionen, die Tupel zurückliefern, in C,
   PL/PgSQL und SQL unterstützt. Der Programmer's Guide enthält weitere
   Informationen dazu. Ein Bespiel einer solchen Funktion befindet sich
   in contrib/tablefunc.
   
    5.4) Ich habe eine der Quellendateien geändert. Warum macht sich die
    Änderung beim erneuten Kompilieren nicht bemerkbar?
    
   Die Makefiles enthalten nicht die richtigen Abhängigkeiten für
   include- Dateien. Sie müssen ein "make clean" und dann ein weiteres
   "make" ausführen. Wenn Sie gcc benutzen, können Sie die
   "--enable-depend"-Option des configure- Skripts benutzen, damit der
   Compiler die Abhängigkeiten automatisch ermittelt.
     _________________________________________________________________
   
    Anmerkungen des Übersetzers
    
   Die englische Vorlage dieser FAQ wird ständig überarbeitet. Daher
   liegt die Übersetzung nicht immer auf dem aktuellsten Stand.
   
   Die aktuellste Version der deutschen Übersetzung befindet sich immer
   unter http://sql-info.de/postgresql/FAQ_german.html. Diese
   "Arbeitsversion" enthält eventuell Änderungen, die noch nicht auf der
   PostgreSQL-Website eingebunden worden sind.
   
   Über Verbesserungshinweise und Korrekturvorschläge sowie
   Verständnisfragen zum Inhalt der FAQ freue ich mich. Ich nehme auch
   allgemeine Fragen zu PostgreSQL gerne entgegen, verweise jedoch auf
   die Mailing-Listen als schnelle und zuverlässige Anlaufstellen.
