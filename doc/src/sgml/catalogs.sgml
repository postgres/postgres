<!--
 Documentation of the system catalogs, directed toward PostgreSQL developers
 $Header: /cvsroot/pgsql/doc/src/sgml/catalogs.sgml,v 2.78 2003/11/02 12:53:57 petere Exp $
 -->

<chapter id="catalogs">
 <title>System Catalogs</title>

  <para>
   The system catalogs are the place where a relational database
   management system stores schema metadata, such as information about
   tables and columns, and internal bookkeeping information.
   <productname>PostgreSQL</productname>'s system catalogs are regular
   tables.  You can drop and recreate the tables, add columns, insert
   and update values, and severely mess up your system that way.
   Normally, one should not change the system catalogs by hand, there
   are always SQL commands to do that.  (For example, <command>CREATE
   DATABASE</command> inserts a row into the
   <structname>pg_database</structname> catalog --- and actually
   creates the database on disk.)  There are some exceptions for
   particularly esoteric operations, such as adding index access methods.
  </para>

 <sect1 id="catalogs-overview">
  <title>Overview</title>

  <para>
   <xref linkend="catalog-table"> lists the system catalogs.
   More detailed documentation of each catalog follows below.
  </para>

  <para>
   Most system catalogs are copied from the template database during
   database creation and are thereafter database-specific. A few
   catalogs are physically shared across all databases in a cluster;
   these are marked in the descriptions of the individual catalogs.
  </para>

  <table id="catalog-table">
   <title>System Catalogs</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>Catalog Name</entry>
      <entry>Purpose</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="catalog-pg-aggregate"><structname>pg_aggregate</structname></link></entry>
      <entry>aggregate functions</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-am"><structname>pg_am</structname></link></entry>
      <entry>index access methods</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amop"><structname>pg_amop</structname></link></entry>
      <entry>access method operators</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link></entry>
      <entry>access method support procedures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link></entry>
      <entry>column default values</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link></entry>
      <entry>table columns (<quote>attributes</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-cast"><structname>pg_cast</structname></link></entry>
      <entry>casts (data type conversions)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-class"><structname>pg_class</structname></link></entry>
      <entry>tables, indexes, sequences (<quote>relations</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
      <entry>check constraints, unique constraints, primary key constraints, foreign key constraints</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-conversion"><structname>pg_conversion</structname></link></entry>
      <entry>encoding conversion information</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-database"><structname>pg_database</structname></link></entry>
      <entry>databases within this database cluster</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-depend"><structname>pg_depend</structname></link></entry>
      <entry>dependencies between database objects</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-description"><structname>pg_description</structname></link></entry>
      <entry>descriptions or comments on database objects</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-group"><structname>pg_group</structname></link></entry>
      <entry>groups of database users</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-index"><structname>pg_index</structname></link></entry>
      <entry>additional index information</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-inherits"><structname>pg_inherits</structname></link></entry>
      <entry>table inheritance hierarchy</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-language"><structname>pg_language</structname></link></entry>
      <entry>languages for writing functions</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link></entry>
      <entry>large objects</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-listener"><structname>pg_listener</structname></link></entry>
      <entry>asynchronous notification support</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link></entry>
      <entry>schemas</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link></entry>
      <entry>index access method operator classes</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link></entry>
      <entry>operators</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link></entry>
      <entry>functions and procedures</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
      <entry>query rewrite rules</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link></entry>
      <entry>database users</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link></entry>
      <entry>planner statistics</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
      <entry>triggers</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-type"><structname>pg_type</structname></link></entry>
      <entry>data types</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-aggregate">
  <title><structname>pg_aggregate</structname></title>

  <indexterm zone="catalog-pg-aggregate">
   <primary>pg_aggregate</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_aggregate</structname> stores information about
   aggregate functions.  An aggregate function is a function that
   operates on a set of values (typically one column from each row
   that matches a query condition) and returns a single value computed
   from all these values.  Typical aggregate functions are
   <function>sum</function>, <function>count</function>, and
   <function>max</function>.  Each entry in
   <structname>pg_aggregate</structname> is an extension of an entry
   in <structname>pg_proc</structname>.  The <structname>pg_proc</structname>
   entry carries the aggregate's name, input and output data types, and
   other information that is similar to ordinary functions.
  </para>

  <table>
   <title><structname>pg_aggregate</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>aggfnoid</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><structname>pg_proc</structname> OID of the aggregate function</entry>
     </row>
     <row>
      <entry><structfield>aggtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Transition function</entry>
     </row>
     <row>
      <entry><structfield>aggfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Final function (zero if none)</entry>
     </row>
     <row>
      <entry><structfield>aggtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>The type of the aggregate function's internal transition (state) data</entry>
     </row>
     <row>
      <entry><structfield>agginitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       The initial value of the transition state.  This is a text
       field containing the initial value in its external string
       representation.  If the value is null, the transition state
       value starts out null.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   New aggregate functions are registered with the <command>CREATE
   AGGREGATE</command> command.  See <xref linkend="xaggr"> for more
   information about writing aggregate functions and the meaning of
   the transition functions, etc.
  </para>

 </sect1>


 <sect1 id="catalog-pg-am">
  <title><structname>pg_am</structname></title>

  <indexterm zone="catalog-pg-am">
   <primary>pg_am</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_am</structname> stores information about index access
   methods.  There is one row for each index access method supported by
   the system.
  </para>

  <table>
   <title><structname>pg_am</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the access method</entry>
     </row>

     <row>
      <entry><structfield>amowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usesysid</literal></entry>
      <entry>User ID of the owner (currently not used)</entry>
     </row>

     <row>
      <entry><structfield>amstrategies</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of operator strategies for this access method</entry>
     </row>

     <row>
      <entry><structfield>amsupport</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of support routines for this access method</entry>
     </row>

     <row>
      <entry><structfield>amorderstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Zero if the index offers no sort order, otherwise the strategy
      number of the strategy operator that describes the sort order</entry>
     </row>

     <row>
      <entry><structfield>amcanunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Does the access method support unique indexes?</entry>
     </row>

     <row>
      <entry><structfield>amcanmulticol</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Does the access method support multicolumn indexes?</entry>
     </row>

     <row>
      <entry><structfield>amindexnulls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Does the access method support null index entries?</entry>
     </row>

     <row>
      <entry><structfield>amconcurrent</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Does the access method support concurrent updates?</entry>
     </row>

     <row>
      <entry><structfield>amgettuple</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Next valid tuple</quote> function</entry>
     </row>

     <row>
      <entry><structfield>aminsert</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Insert this tuple</quote> function</entry>
     </row>

     <row>
      <entry><structfield>ambeginscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Start new scan</quote> function</entry>
     </row>

     <row>
      <entry><structfield>amrescan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Restart this scan</quote> function</entry>
     </row>

     <row>
      <entry><structfield>amendscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>End this scan</quote> function</entry>
     </row>

     <row>
      <entry><structfield>ammarkpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Mark current scan position</quote> function</entry>
     </row>

     <row>
      <entry><structfield>amrestrpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Restore marked scan position</quote> function</entry>
     </row>

     <row>
      <entry><structfield>ambuild</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry><quote>Build new index</quote> function</entry>
     </row>

     <row>
      <entry><structfield>ambulkdelete</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Bulk-delete function</entry>
     </row>

     <row>
      <entry><structfield>amvacuumcleanup</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Post-<command>VACUUM</command> cleanup function</entry>
     </row>

     <row>
      <entry><structfield>amcostestimate</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Function to estimate cost of an index scan</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

   <para>
    An index access method that supports multiple columns (has
    <structfield>amcanmulticol</structfield> true) <emphasis>must</>
    support indexing null values in columns after the first, because the planner
    will assume the index can be used for queries on just the first
    column(s).  For example, consider an index on (a,b) and a query with
    <literal>WHERE a = 4</literal>.  The system will assume the index can be used to scan for
    rows with <literal>a = 4</literal>, which is wrong if the index omits rows where <literal>b</> is null.
    It is, however, OK to omit rows where the first indexed column is null.
    (GiST currently does so.)
    <structfield>amindexnulls</structfield> should be set true only if the
    index access method indexes all rows, including arbitrary combinations of null values.
   </para>

 </sect1>


 <sect1 id="catalog-pg-amop">
  <title><structname>pg_amop</structname></title>

  <indexterm zone="catalog-pg-amop">
   <primary>pg_amop</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_amop</structname> stores information about operators
   associated with index access method operator classes.  There is one
   row for each operator that is a member of an operator class.
  </para>

  <table>
   <title><structname>pg_amop</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amopclaid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>The index operator class this entry is for</entry>
     </row>

     <row>
      <entry><structfield>amopstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Operator strategy number</entry>
     </row>

     <row>
      <entry><structfield>amopreqcheck</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Index hit must be rechecked</entry>
     </row>

     <row>
      <entry><structfield>amopopr</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>OID of the operator</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-amproc">
  <title><structname>pg_amproc</structname></title>

  <indexterm zone="catalog-pg-amproc">
   <primary>pg_amproc</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_amproc</structname> stores information about support
   procedures
   associated with index access method operator classes.  There is one
   row for each support procedure belonging to an operator class.
  </para>

  <table>
   <title><structname>pg_amproc</structname> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>amopclaid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>The index operator class this entry is for</entry>
     </row>

     <row>
      <entry><structfield>amprocnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Support procedure number</entry>
     </row>

     <row>
      <entry><structfield>amproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>OID of the procedure</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
  <title><structname>pg_attrdef</structname></title>

  <indexterm zone="catalog-pg-attrdef">
   <primary>pg_attrdef</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_attrdef</structname> stores column default values.  The main information
   about columns is stored in <structname>pg_attribute</structname>
   (see below).  Only columns that explicitly specify a default value
   (when the table is created or the column is added) will have an
   entry here.
  </para>

  <table>
   <title><structname>pg_attrdef</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>adrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this column belongs to</entry>
     </row>

     <row>
      <entry><structfield>adnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>The number of the column</entry>
     </row>

     <row>
      <entry><structfield>adbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>The internal representation of the column default value</entry>
     </row>

     <row>
      <entry><structfield>adsrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>A human-readable representation of the default value</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-attribute">
  <title><structname>pg_attribute</structname></title>

  <indexterm zone="catalog-pg-attribute">
   <primary>pg_attribute</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_attribute</structname> stores information about
   table columns.  There will be exactly one
   <structname>pg_attribute</structname> row for every column in every
   table in the database.  (There will also be attribute entries for
   indexes and other objects.  See <structname>pg_class</structname>.)
  </para>

  <para>
   The term attribute is equivalent to column and is used for
   historical reasons.
  </para>

  <table>
   <title><structname>pg_attribute</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>attrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this column belongs to</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>The column name</entry>
     </row>

     <row>
      <entry><structfield>atttypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>The data type of this column</entry>
     </row>

     <row>
      <entry><structfield>attstattarget</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>attstattarget</structfield> controls the level of detail
       of statistics accumulated for this column by
       <command>ANALYZE</command>.
       A zero value indicates that no statistics should be collected.
       A negative value says to use the system default statistics target.
       The exact meaning of positive values is data type-dependent.
       For scalar data types, <structfield>attstattarget</structfield>
       is both the target number of <quote>most common values</quote>
       to collect, and the target number of histogram bins to create.
      </entry>
     </row>

     <row>
      <entry><structfield>attlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       A copy of <literal>pg_type.typlen</literal> of this column's
       type
      </entry>
     </row>

     <row>
      <entry><structfield>attnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       The number of the column.  Ordinary columns are numbered from 1
       up.  System columns, such as <structfield>oid</structfield>,
       have (arbitrary) negative numbers.
      </entry>
     </row>

     <row>
      <entry><structfield>attndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Number of dimensions, if the column is an array type; otherwise 0.
       (Presently, the number of dimensions of an array is not enforced,
       so any nonzero value effectively means <quote>it's an array</>.)
      </entry>
     </row>

     <row>
      <entry><structfield>attcacheoff</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Always -1 in storage, but when loaded into a row descriptor
       in memory this may be updated to cache the offset of the attribute
       within the row.
      </entry>
     </row>

     <row>
      <entry><structfield>atttypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <structfield>atttypmod</structfield> records type-specific data
       supplied at table creation time (for example, the maximum
       length of a <type>varchar</type> column).  It is passed to
       type-specific input functions and length coercion functions.
       The value will generally be -1 for types that do not need <structfield>atttypmod</>.
      </entry>
     </row>

     <row>
      <entry><structfield>attbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       A copy of <literal>pg_type.typbyval</> of this column's type
      </entry>
     </row>

     <row>
      <entry><structfield>attstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Normally a copy of <literal>pg_type.typstorage</> of this
       column's type.  For TOAST-able data types, this can be altered
       after column creation to control storage policy.
      </entry>
     </row>

     <row>
      <entry><structfield>attisset</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true, this attribute is a set.  In that case, what is really
       stored in the attribute is the OID of a row in the
       <structname>pg_proc</structname> catalog.  The
       <structname>pg_proc</structname> row contains the query
       string that defines this set, i.e., the query to run to get
       the set.  So the <structfield>atttypid</structfield> (see
       above) refers to the type returned by this query, but the
       actual length of this attribute is the length (size) of an
       <type>oid</type>.  --- At least this is the theory.  All this
       is probably quite broken these days.
      </entry>
     </row>

     <row>
      <entry><structfield>attalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A copy of <literal>pg_type.typalign</> of this column's type
      </entry>
     </row>

     <row>
      <entry><structfield>attnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This represents a not-null constraint.  It is possible to
       change this column to enable or disable the constraint.
      </entry>
     </row>

     <row>
      <entry><structfield>atthasdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column has a default value, in which case there will be a
       corresponding entry in the <structname>pg_attrdef</structname>
       catalog that actually defines the value.
      </entry>
     </row>

     <row>
      <entry><structfield>attisdropped</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column has been dropped and is no longer valid.  A dropped
       column is still physically present in the table, but is
       ignored by the parser and so cannot be accessed via SQL.
      </entry>
     </row>

     <row>
      <entry><structfield>attislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This column is defined locally in the relation.  Note that a column may
       be locally defined and inherited simultaneously.
      </entry>
     </row>

     <row>
      <entry><structfield>attinhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       The number of direct ancestors this column has.  A column with a 
       nonzero number of ancestors cannot be dropped nor renamed.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-cast">
  <title><structname>pg_cast</structname></title>

  <indexterm zone="catalog-pg-cast">
   <primary>pg_cast</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_cast</structname> stores data type conversion paths,
   both built-in paths and those defined with <command>CREATE CAST</command>.
  </para>

  <table>
   <title><structfield>pg_cast</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>castsource</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID of the source data type</entry>
     </row>

     <row>
      <entry><structfield>casttarget</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>OID of the target data type</entry>
     </row>

     <row>
      <entry><structfield>castfunc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       The OID of the function to use to perform this cast.  Zero is
       stored if the data types are binary compatible (that is, no
       run-time operation is needed to perform the cast).
      </entry>
     </row>

     <row>
      <entry><structfield>castcontext</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Indicates what contexts the cast may be invoked in.
       <literal>e</> means only as an explicit cast (using
       <literal>CAST</>, <literal>::</>, or function-call syntax).
       <literal>a</> means implicitly in assignment
       to a target column, as well as explicitly.
       <literal>i</> means implicitly in expressions, as well as the
       other cases.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-class">
  <title><structname>pg_class</structname></title>

  <indexterm zone="catalog-pg-class">
   <primary>pg_class</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_class</structname> catalogs tables and most
   everything else that has columns or is otherwise similar to a
   table.  This includes indexes (but see also
   <structname>pg_index</structname>), sequences, views, and some
   kinds of special relation; see <structfield>relkind</>.
   Below, when we mean all of these
   kinds of objects we speak of <quote>relations</quote>.  Not all
   columns are meaningful for all relation types.
  </para>

  <table>
   <title><structname>pg_class</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the table, index, view, etc.</entry>
     </row>

     <row>
      <entry><structfield>relnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this relation
      </entry>
     </row>

     <row>
      <entry><structfield>reltype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       The OID of the data type that corresponds to this table, if any
       (zero for indexes, which have no <structname>pg_type</> entry)
      </entry>
     </row>

     <row>
      <entry><structfield>relowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usesysid</literal></entry>
      <entry>Owner of the relation</entry>
     </row>

     <row>
      <entry><structfield>relam</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>If this is an index, the access method used (B-tree, hash, etc.)</entry>
     </row>

     <row>
      <entry><structfield>relfilenode</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Name of the on-disk file of this relation; 0 if none</entry>
     </row>

     <row>
      <entry><structfield>relpages</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Size of the on-disk representation of this table in pages (size
       <symbol>BLCKSZ</symbol>).
       This is only an estimate used by the planner.
       It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and <command>CREATE INDEX</command>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltuples</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
       Number of rows in the table.
       This is only an estimate used by the planner.
       It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and <command>CREATE INDEX</command>.
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID of the TOAST table associated with this table, 0 if none.
       The TOAST table stores large attributes <quote>out of
       line</quote> in a secondary table.
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastidxid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       For a TOAST table, the OID of its index.  0 if not a TOAST table.
      </entry>
     </row>

     <row>
      <entry><structfield>relhasindex</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if this is a table and it has (or recently had) any
       indexes. This is set by <command>CREATE INDEX</command>, but
       not cleared immediately by <command>DROP INDEX</command>.
       <command>VACUUM</command> clears <structfield>relhasindex</> if it finds the
       table has no indexes.
      </entry>
     </row>

     <row>
      <entry><structfield>relisshared</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if this table is shared across all databases in the
      cluster.  Only certain system catalogs (such as
      <structname>pg_database</structname>) are shared.</entry>
     </row>

     <row>
      <entry><structfield>relkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>r</> = ordinary table, <literal>i</> = index,
       <literal>S</> = sequence, <literal>v</> = view, <literal>c</> =
       composite type, <literal>s</> = special, <literal>t</> = TOAST
       table
      </entry>
     </row>

     <row>
      <entry><structfield>relnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of user columns in the relation (system columns not
       counted).  There must be this many corresponding entries in
       <structname>pg_attribute</structname>.  See also
       <literal>pg_attribute.attnum</literal>.
      </entry>
     </row>

     <row>
      <entry><structfield>relchecks</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of check constraints on the table; see
       <structname>pg_constraint</structname> catalog
      </entry>
     </row>

     <row>
      <entry><structfield>reltriggers</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       Number of triggers on the table; see
       <structname>pg_trigger</structname> catalog
      </entry>
     </row>

     <row>
      <entry><structfield>relukeys</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>unused  (<emphasis>not</emphasis> the number of unique keys)</entry>
     </row>

     <row>
      <entry><structfield>relfkeys</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>unused  (<emphasis>not</emphasis> the number of foreign keys on the table)</entry>
     </row>

     <row>
      <entry><structfield>relrefs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>unused</entry>
     </row>

     <row>
      <entry><structfield>relhasoids</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if we generate an OID for each row of the relation.
      </entry>
     </row>

     <row>
      <entry><structfield>relhaspkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if the table has (or once had) a primary key.
      </entry>
     </row>

     <row>
      <entry><structfield>relhasrules</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Table has rules; see
       <structname>pg_rewrite</structname> catalog
      </entry>
     </row>

     <row>
      <entry><structfield>relhassubclass</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>At least one table inherits from this one</entry>
     </row>

     <row>
      <entry><structfield>relacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       Access privileges; see the descriptions of
       <command>GRANT</command> and <command>REVOKE</command> for
       details.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-constraint">
  <title><structname>pg_constraint</structname></title>

  <indexterm zone="catalog-pg-constraint">
   <primary>pg_constraint</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_constraint</structname> stores check, primary key, unique, and foreign
   key constraints on tables.  (Column constraints are not treated
   specially.  Every column constraint is equivalent to some table
   constraint.)  Not-null constraints are represented in the
   <structname>pg_attribute</> catalog.
  </para>

  <para>
   Check constraints on domains are stored here, too.
  </para>

  <table>
   <title><structname>pg_constraint</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Constraint name (not necessarily unique!)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this constraint
      </entry>
     </row>

     <row>
      <entry><structfield>contype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
        <literal>c</> = check constraint,
        <literal>f</> = foreign key constraint,
        <literal>p</> = primary key constraint,
        <literal>u</> = unique constraint
      </entry>
     </row>

     <row>
      <entry><structfield>condeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Is the constraint deferrable?</entry>
     </row>

     <row>
      <entry><structfield>condeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Is the constraint deferred by default?</entry>
     </row>

     <row>
      <entry><structfield>conrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this constraint is on; 0 if not a table constraint</entry>
     </row>

     <row>
      <entry><structfield>contypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>The domain this constraint is on; 0 if not a domain constraint</entry>
     </row>

     <row>
      <entry><structfield>confrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>If a foreign key, the referenced table; else 0</entry>
     </row>

     <row>
      <entry><structfield>confupdtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Foreign key update action code</entry>
     </row>

     <row>
      <entry><structfield>confdeltype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Foreign key deletion action code</entry>
     </row>

     <row>
      <entry><structfield>confmatchtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Foreign key match type</entry>
     </row>

     <row>
      <entry><structfield>conkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</></entry>
      <entry>If a table constraint, list of columns which the constraint constrains</entry>
     </row>

     <row>
      <entry><structfield>confkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</></entry>
      <entry>If a foreign key, list of the referenced columns</entry>
     </row>

     <row>
      <entry><structfield>conbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>If a check constraint, an internal representation of the expression</entry>
     </row>

     <row>
      <entry><structfield>consrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>If a check constraint, a human-readable representation of the expression</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <structfield>consrc</structfield> is not updated when referenced objects
    change; for example, it won't track renaming of columns.  Rather than
    relying on this field, it's best to use <function>pg_get_constraintdef()</>
    to extract the definition of a check constraint.
   </para>
  </note>

  <note>
   <para>
    <literal>pg_class.relchecks</literal> needs to agree with the
    number of check-constraint entries found in this table for the
    given relation.
   </para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-conversion">
  <title><structname>pg_conversion</structname></title>

  <indexterm zone="catalog-pg-conversion">
   <primary>pg_conversion</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_conversion</structname> stores encoding conversion information. See
   <command>CREATE CONVERSION</command> for more information.
  </para>

  <table>
   <title><structname>pg_conversion</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Conversion name (unique within a namespace)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this conversion
      </entry>
     </row>

     <row>
      <entry><structfield>conowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usesysid</literal></entry>
      <entry>Owner of the conversion</entry>
     </row>

     <row>
      <entry><structfield>conforencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Source encoding ID</entry>
     </row>

     <row>
      <entry><structfield>contoencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Destination encoding ID</entry>
     </row>

     <row>
      <entry><structfield>conproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Conversion procedure</entry>
     </row>

     <row>
      <entry><structfield>condefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if this is the default conversion</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-database">
  <title><structname>pg_database</structname></title>

  <indexterm zone="catalog-pg-database">
   <primary>pg_database</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_database</structname> stores information
   about the available databases.  Databases are created with the
   <command>CREATE DATABASE</command> command.  Consult
   <xref linkend="managing-databases"> for details about the meaning of some of the
   parameters.
  </para>

  <para>
   Unlike most system catalogs, <structname>pg_database</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_database</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title><structname>pg_database</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>datname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Database name</entry>
     </row>

     <row>
      <entry><structfield>datdba</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usesysid</literal></entry>
      <entry>Owner of the database, usually the user who created it</entry>
     </row>

     <row>
      <entry><structfield>encoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Character encoding for this database</entry>
     </row>

     <row>
      <entry><structfield>datistemplate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If true then this database can be used in the
       <literal>TEMPLATE</literal> clause of <command>CREATE
       DATABASE</command> to create a new database as a clone of
       this one.
      </entry>
     </row>

     <row>
      <entry><structfield>datallowconn</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       If false then no one can connect to this database.  This is
       used to protect the <literal>template0</> database from being altered.
      </entry>
     </row>

     <row>
      <entry><structfield>datlastsysoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>
       Last system OID in the database; useful
       particularly to <application>pg_dump</application>
      </entry>
     </row>

     <row>
      <entry><structfield>datvacuumxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       All rows inserted or deleted by transaction IDs before this one
       have been marked as known committed or known aborted in this database.
       This is used to determine when commit-log space can be recycled.
      </entry>
     </row>

     <row>
      <entry><structfield>datfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       All rows inserted by transaction IDs before this one have been
       relabeled with a permanent (<quote>frozen</>) transaction ID in this
       database.  This is useful to check whether a database must be vacuumed
       soon to avoid transaction ID wrap-around problems.
      </entry>
     </row>

     <row>
      <entry><structfield>datpath</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       If the database is stored at an alternative location then this
       records the location.  It's either an environment variable name
       or an absolute path, depending how it was entered.
      </entry>
     </row>

     <row>
      <entry><structfield>datconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Session defaults for run-time configuration variables</entry>
     </row>

     <row>
      <entry><structfield>datacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Access privileges</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-depend">
  <title><structname>pg_depend</structname></title>

  <indexterm zone="catalog-pg-depend">
   <primary>pg_depend</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_depend</structname> records the dependency
   relationships between database objects.  This information allows
   <command>DROP</> commands to find which other objects must be dropped
   by <command>DROP CASCADE</> or prevent dropping in the <command>DROP
   RESTRICT</> case.
  </para>

  <table>
   <title><structname>pg_depend</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog the dependent object is in</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the specific dependent object</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a table column, this is the column number (the
       <structfield>objid</> and <structfield>classid</> refer to the
       table itself).  For all other object types, this column is
       zero.
      </entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog the referenced object is in</entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the specific referenced object</entry>
     </row>

     <row>
      <entry><structfield>refobjsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a table column, this is the column number (the
       <structfield>refobjid</> and <structfield>refclassid</> refer
       to the table itself).  For all other object types, this column
       is zero.
      </entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       A code defining the specific semantics of this dependency relationship; see text.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   In all cases, a <structname>pg_depend</structname> entry indicates that the
   referenced object may not be dropped without also dropping the dependent
   object.  However, there are several subflavors identified by
   <structfield>deptype</>:

   <variablelist>
    <varlistentry>
     <term><symbol>DEPENDENCY_NORMAL</> (<literal>n</>)</term>
     <listitem>
      <para>
       A normal relationship between separately-created objects.  The
       dependent object may be dropped without affecting the
       referenced object.  The referenced object may only be dropped
       by specifying <literal>CASCADE</>, in which case the dependent
       object is dropped, too.  Example: a table column has a normal
       dependency on its data type.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO</> (<literal>a</>)</term>
     <listitem>
      <para>
       The dependent object can be dropped separately from the
       referenced object, and should be automatically dropped
       (regardless of <literal>RESTRICT</> or <literal>CASCADE</>
       mode) if the referenced object is dropped.  Example: a named
       constraint on a table is made autodependent on the table, so
       that it will go away if the table is dropped.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_INTERNAL</> (<literal>i</>)</term>
     <listitem>
      <para>
       The dependent object was created as part of creation of the
       referenced object, and is really just a part of its internal
       implementation.  A <command>DROP</> of the dependent object
       will be disallowed outright (we'll tell the user to issue a
       <command>DROP</> against the referenced object, instead).  A
       <command>DROP</> of the referenced object will be propagated
       through to drop the dependent object whether
       <command>CASCADE</> is specified or not.  Example: a trigger
       that's created to enforce a foreign-key constraint is made
       internally dependent on the constraint's
       <structname>pg_constraint</> entry.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PIN</> (<literal>p</>)</term>
     <listitem>
      <para>
       There is no dependent object; this type of entry is a signal
       that the system itself depends on the referenced object, and so
       that object must never be deleted.  Entries of this type are
       created only by <command>initdb</command>.  The columns for the
       dependent object contain zeroes.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Other dependency flavors may be needed in future.
  </para>

 </sect1>


 <sect1 id="catalog-pg-description">
  <title><structname>pg_description</structname></title>

  <indexterm zone="catalog-pg-description">
   <primary>pg_description</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_description</> can store an optional description or
   comment for each database object.  Descriptions can be manipulated
   with the <command>COMMENT</command> command and viewed with
   <application>psql</application>'s <literal>\d</literal> commands.
   Descriptions of many built-in system objects are provided in the initial
   contents of <structname>pg_description</structname>.
  </para>

  <table>
   <title><structname>pg_description</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry>any OID column</entry>
      <entry>The OID of the object this description pertains to</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the system catalog this object appears in</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       For a comment on a table column, this is the column number (the
       <structfield>objoid</> and <structfield>classoid</> refer to
       the table itself).  For all other object types, this column is
       zero.
      </entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Arbitrary text that serves as the description of this object.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-group">
  <title><structname>pg_group</structname></title>

  <indexterm zone="catalog-pg-group">
   <primary>pg_group</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_group</structname> defines groups and stores what users belong to what
   groups.  Groups are created with the <command>CREATE
   GROUP</command> command.  Consult <xref linkend="user-manag"> for information
   about user privilege management.
  </para>

  <para>
   Because user and group identities are cluster-wide,
   <structname>pg_group</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_group</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title><structname>pg_group</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>groname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the group</entry>
     </row>

     <row>
      <entry><structfield>grosysid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>An arbitrary number to identify this group</entry>
     </row>

     <row>
      <entry><structfield>grolist</structfield></entry>
      <entry><type>int4[]</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usesysid</literal></entry>
      <entry>An array containing the IDs of the users in this group</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-index">
  <title><structname>pg_index</structname></title>

  <indexterm zone="catalog-pg-index">
   <primary>pg_index</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_index</structname> contains part of the information
   about indexes.  The rest is mostly in
   <structname>pg_class</structname>.
  </para>

  <table>
   <title><structname>pg_index</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>indexrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the <structname>pg_class</> entry for this index</entry>
     </row>

     <row>
      <entry><structfield>indrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The OID of the <structname>pg_class</> entry for the table this index is for</entry>
     </row>

     <row>
      <entry><structfield>indkey</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       This is an array of <structfield>indnatts</structfield> (up to
       <symbol>INDEX_MAX_KEYS</symbol>) values that indicate which
       table columns this index indexes.  For example a value of
       <literal>1 3</literal> would mean that the first and the third table
       columns make up the index key.  A zero in this array indicates that the
       corresponding index attribute is an expression over the table columns,
       rather than a simple column reference.
      </entry>
     </row>

     <row>
      <entry><structfield>indclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</entry>
      <entry>
       For each column in the index key this contains the OID of
       the operator class to use.  See
       <structname>pg_opclass</structname> for details.
      </entry>
     </row>

     <row>
      <entry><structfield>indnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>The number of columns in the index (duplicates
      <literal>pg_class.relnatts</literal>)</entry>
     </row>

     <row>
      <entry><structfield>indisunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this is a unique index.</entry>
     </row>

     <row>
      <entry><structfield>indisprimary</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, this index represents the primary key of the table.
      (<structfield>indisunique</> should always be true when this is true.)</entry>
     </row>

     <row>
      <entry><structfield>indisclustered</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>If true, the table was last clustered on this index.</entry>
     </row>

     <row>
      <entry><structfield>indexprs</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Expression trees (in <function>nodeToString()</function> representation)
      for index attributes that are not simple column references.  This is a
      list with one element for each zero entry in <structfield>indkey</>.
      Null if all index attributes are simple references.</entry>
     </row>

     <row>
      <entry><structfield>indpred</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Expression tree (in <function>nodeToString()</function> representation)
      for partial index predicate.  Null if not a partial index.</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
  <title><structname>pg_inherits</structname></title>

  <indexterm zone="catalog-pg-inherits">
   <primary>pg_inherits</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_inherits</> records information about
   table inheritance hierarchies.
  </para>

  <table>
   <title><structname>pg_inherits</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>inhrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       The OID of the child table.
      </entry>
     </row>

     <row>
      <entry><structfield>inhparent</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       The OID of the parent table.
      </entry>
     </row>

     <row>
      <entry><structfield>inhseqno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       If there is more than one parent for a child table (multiple
       inheritance), this number tells the order in which the
       inherited columns are to be arranged.  The count starts at 1.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-language">
  <title><structname>pg_language</structname></title>

  <indexterm zone="catalog-pg-language">
   <primary>pg_language</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_language</structname> registers call interfaces or
   languages in which you can write functions or stored procedures.
   See under <command>CREATE LANGUAGE</command> and in
   <xref linkend="xplang"> for more information about language handlers.
  </para>

  <table>
   <title><structname>pg_language</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>lanname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the language (to be specified when creating a function)</entry>
     </row>

     <row>
      <entry><structfield>lanispl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This is false for internal languages (such as
       <acronym>SQL</acronym>) and true for user-defined languages.
       Currently, <application>pg_dump</application> still uses this
       to determine which languages need to be dumped, but this may be
       replaced by a different mechanism sometime.
      </entry>
     </row>

     <row>
      <entry><structfield>lanpltrusted</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       This is a trusted language.  See under <command>CREATE
       LANGUAGE</command> what this means.  If this is an internal
       language (<structfield>lanispl</structfield> is false) then
       this column is meaningless.
      </entry>
     </row>

     <row>
      <entry><structfield>lanplcallfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       For noninternal languages this references the language
       handler, which is a special function that is responsible for
       executing all functions that are written in the particular
       language.
      </entry>
     </row>

     <row>
      <entry><structfield>lanvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       This references a language validator function that is responsible
       for checking the syntax and validity of new functions when they
       are created. See under <command>CREATE LANGUAGE</command> for
       further information about validators.
      </entry>
     </row>

     <row>
      <entry><structfield>lanacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Access privileges</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
  <title><structname>pg_largeobject</structname></title>

  <indexterm zone="catalog-pg-largeobject">
   <primary>pg_largeobject</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_largeobject</structname> holds the data making up
   <quote>large objects</quote>.  A large object is identified by an
   OID assigned when it is created.  Each large object is broken into
   segments or <quote>pages</> small enough to be conveniently stored as rows
   in <structname>pg_largeobject</structname>.
   The amount of data per page is defined to be <literal>LOBLKSIZE</> (which is currently
   <literal>BLCKSZ/4</>, or typically 2 kB).
  </para>

  <table>
   <title><structname>pg_largeobject</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>loid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>Identifier of the large object that includes this page</entry>
     </row>

     <row>
      <entry><structfield>pageno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>Page number of this page within its large object
      (counting from zero)</entry>
     </row>

     <row>
      <entry><structfield>data</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       Actual data stored in the large object.
       This will never be more than <symbol>LOBLKSIZE</> bytes and may be less.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Each row of <structname>pg_largeobject</structname> holds data
   for one page of a large object, beginning at
   byte offset (<literal>pageno * LOBLKSIZE</>) within the object.  The implementation
   allows sparse storage: pages may be missing, and may be shorter than
   <literal>LOBLKSIZE</> bytes even if they are not the last page of the object.
   Missing regions within a large object read as zeroes.
  </para>

 </sect1>


 <sect1 id="catalog-pg-listener">
  <title><structname>pg_listener</structname></title>

  <indexterm zone="catalog-pg-listener">
   <primary>pg_listener</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_listener</structname> supports the <command>LISTEN</>
   and <command>NOTIFY</> commands.  A listener creates an entry in
   <structname>pg_listener</structname> for each notification name
   it is listening for.  A notifier scans <structname>pg_listener</structname>
   and updates each matching entry to show that a notification has occurred.
   The notifier also sends a signal (using the PID recorded in the table)
   to awaken the listener from sleep.
  </para>

  <table>
   <title><structname>pg_listener</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Notify condition name.  (The name need not match any actual
      relation in the database; the name <structfield>relname</> is historical.)
      </entry>
     </row>

     <row>
      <entry><structfield>listenerpid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>PID of the server process that created this entry.</entry>
     </row>

     <row>
      <entry><structfield>notification</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       Zero if no event is pending for this listener.  If an event is
       pending, the PID of the server process that sent the notification.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-namespace">
  <title><structname>pg_namespace</structname></title>

  <indexterm zone="catalog-pg-namespace">
   <primary>pg_namespace</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_namespace</> stores namespaces.
   A namespace is the structure underlying SQL schemas: each namespace
   can have a separate collection of relations, types, etc. without name
   conflicts.
  </para>

  <table>
   <title><structname>pg_namespace</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>nspname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the namespace</entry>
     </row>

     <row>
      <entry><structfield>nspowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usesysid</literal></entry>
      <entry>Owner of the namespace</entry>
     </row>

     <row>
      <entry><structfield>nspacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Access privileges</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-opclass">
  <title><structname>pg_opclass</structname></title>

  <indexterm zone="catalog-pg-opclass">
   <primary>pg_opclass</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_opclass</structname> defines
   index access method operator classes.  Each operator class defines
   semantics for index columns of a particular data type and a particular
   index access method.  Note that there can be multiple operator classes
   for a given data type/access method combination, thus supporting multiple
   behaviors.
  </para>

  <para>
   Operator classes are described at length in <xref linkend="xindex">.
  </para>

  <table>
   <title><structname>pg_opclass</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>opcamid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <entry>Index access method operator class is for</entry>
     </row>

     <row>
      <entry><structfield>opcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of this operator class</entry>
     </row>

     <row>
      <entry><structfield>opcnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>Namespace of this operator class</entry>
     </row>

     <row>
      <entry><structfield>opcowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usesysid</literal></entry>
      <entry>Operator class owner</entry>
     </row>

     <row>
      <entry><structfield>opcintype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Input data type of the operator class</entry>
     </row>

     <row>
      <entry><structfield>opcdefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if this operator class is the default for <structfield>opcintype</></entry>
     </row>

     <row>
      <entry><structfield>opckeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type of index data, or zero if same as <structfield>opcintype</></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   The majority of the information defining an operator class is actually
   not in its <structname>pg_opclass</structname> row, but in the associated
   rows in <structname>pg_amop</structname> and
   <structname>pg_amproc</structname>.  Those rows are considered to be
   part of the operator class definition --- this is not unlike the way
   that a relation is defined by a single <structname>pg_class</structname>
   row plus associated rows in <structname>pg_attribute</structname> and
   other tables.
  </para>

 </sect1>


 <sect1 id="catalog-pg-operator">
  <title><structname>pg_operator</structname></title>

  <indexterm zone="catalog-pg-operator">
   <primary>pg_operator</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_operator</> stores information about operators.  See
   <command>CREATE OPERATOR</command> and <xref linkend="xoper"> for
   details on these operator parameters.
  </para>

  <table>
   <title><structname>pg_operator</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oprname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the operator</entry>
     </row>

     <row>
      <entry><structfield>oprnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this operator
      </entry>
     </row>

     <row>
      <entry><structfield>oprowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usesysid</literal></entry>
      <entry>Owner of the operator</entry>
     </row>

     <row>
      <entry><structfield>oprkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <literal>b</> = infix (<quote>both</quote>), <literal>l</> = prefix
       (<quote>left</quote>), <literal>r</> = postfix (<quote>right</quote>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprcanhash</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>This operator supports hash joins</entry>
     </row>

     <row>
      <entry><structfield>oprleft</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type of the left operand</entry>
     </row>

     <row>
      <entry><structfield>oprright</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type of the right operand</entry>
     </row>

     <row>
      <entry><structfield>oprresult</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Type of the result</entry>
     </row>

     <row>
      <entry><structfield>oprcom</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Commutator of this operator, if any</entry>
     </row>

     <row>
      <entry><structfield>oprnegate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>Negator of this operator, if any</entry>
     </row>

     <row>
      <entry><structfield>oprlsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       If this operator supports merge joins, the operator that sorts
       the type of the left-hand operand (<literal>L&lt;L</>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprrsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       If this operator supports merge joins, the operator that sorts
       the type of the right-hand operand (<literal>R&lt;R</>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprltcmpop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       If this operator supports merge joins, the less-than operator that
       compares the left and right operand types (<literal>L&lt;R</>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprgtcmpop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       If this operator supports merge joins, the greater-than operator that
       compares the left and right operand types (<literal>L&gt;R</>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprcode</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Function that implements this operator</entry>
     </row>

     <row>
      <entry><structfield>oprrest</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Restriction selectivity estimation function for this operator</entry>
     </row>

     <row>
      <entry><structfield>oprjoin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Join selectivity estimation function for this operator</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Unused column contain zeroes, for example <structfield>oprleft</structfield> is zero for a
   prefix operator.
  </para>

 </sect1>


 <sect1 id="catalog-pg-proc">
  <title><structname>pg_proc</structname></title>

  <indexterm zone="catalog-pg-proc">
   <primary>pg_proc</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_proc</> stores information about functions (or procedures).
   The description of <command>CREATE FUNCTION</command> and
   <xref linkend="xfunc"> contain more information about the meaning of
   some columns.
  </para>

  <para>
   The table contains data for aggregate functions as well as plain functions.
   If <structfield>proisagg</structfield> is true, there should be a matching
   row in <structfield>pg_aggregate</structfield>.
  </para>

  <table>
   <title><structname>pg_proc</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>proname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Name of the function</entry>
     </row>

     <row>
      <entry><structfield>pronamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this function
      </entry>
     </row>

     <row>
      <entry><structfield>proowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usesysid</literal></entry>
      <entry>Owner of the function</entry>
     </row>

     <row>
      <entry><structfield>prolang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-language"><structname>pg_langauge</structname></link>.oid</literal></entry>
      <entry>Implementation language or call interface of this function</entry>
     </row>

     <row>
      <entry><structfield>proisagg</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function is an aggregate function</entry>
     </row>

     <row>
      <entry><structfield>prosecdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function is a security definer (i.e., a <quote>setuid</>
      function)</entry>
     </row>

     <row>
      <entry><structfield>proisstrict</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       Function returns null if any call argument is null.  In that
       case the function won't actually be called at all.  Functions
       that are not <quote>strict</quote> must be prepared to handle
       null inputs.
      </entry>
     </row>

     <row>
      <entry><structfield>proretset</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>Function returns a set (i.e., multiple values of the specified
      data type)</entry>
     </row>

     <row>
      <entry><structfield>provolatile</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>provolatile</structfield> tells whether the function's
       result depends only on its input arguments, or is affected by outside
       factors.
       It is <literal>i</literal> for <quote>immutable</> functions,
       which always deliver the same result for the same inputs.
       It is <literal>s</literal> for <quote>stable</> functions,
       whose results (for fixed inputs) do not change within a scan.
       It is <literal>v</literal> for <quote>volatile</> functions,
       whose results may change at any time.  (Use <literal>v</literal> also
       for functions with side-effects, so that calls to them cannot get
       optimized away.)
      </entry>
     </row>

     <row>
      <entry><structfield>pronargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of arguments</entry>
     </row>

     <row>
      <entry><structfield>prorettype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>Data type of the return value</entry>
     </row>

     <row>
      <entry><structfield>proargtypes</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>An array with the data types of the function arguments</entry>
     </row>

     <row>
      <entry><structfield>prosrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       This tells the function handler how to invoke the function.  It
       might be the actual source code of the function for interpreted
       languages, a link symbol, a file name, or just about anything
       else, depending on the implementation language/call convention.
      </entry>
     </row>

     <row>
      <entry><structfield>probin</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>Additional information about how to invoke the function.
      Again, the interpretation is language-specific.
      </entry>
     </row>

     <row>
      <entry><structfield>proacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>Access privileges</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structfield>prosrc</structfield> contains the function's C-language
   name (link symbol) for compiled functions, both built-in and
   dynamically loaded.  For all other language types,
   <structfield>prosrc</structfield> contains the function's source
   text.  <structfield>probin</structfield> is unused except for
   dynamically-loaded C functions, for which it gives the name of the
   shared library file containing the function.
  </para>

 </sect1>

 <sect1 id="catalog-pg-rewrite">
  <title><structname>pg_rewrite</structname></title>

  <indexterm zone="catalog-pg-rewrite">
   <primary>pg_rewrite</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_rewrite</structname> stores rewrite rules for tables and views.
  </para>

  <table>
   <title><structname>pg_rewrite</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Rule name</entry>
     </row>

     <row>
      <entry><structfield>ev_class</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this rule is for</entry>
     </row>

     <row>
      <entry><structfield>ev_attr</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>The column this rule is for (currently, always zero to
      indicate the whole table)</entry>
     </row>

     <row>
      <entry><structfield>ev_type</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       Event type that the rule is for: 1 = <command>SELECT</>, 2 =
       <command>UPDATE</>, 3 = <command>INSERT</>, 4 =
       <command>DELETE</>
      </entry>
     </row>

     <row>
      <entry><structfield>is_instead</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if the rule is an <literal>INSTEAD</literal> rule</entry>
     </row>

     <row>
      <entry><structfield>ev_qual</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Expression tree (in the form of a
       <function>nodeToString()</function> representation) for the
       rule's qualifying condition
      </entry>
     </row>

     <row>
      <entry><structfield>ev_action</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       Query tree (in the form of a
       <function>nodeToString()</function> representation) for the
       rule's action
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <literal>pg_class.relhasrules</literal>
    must be true if a table has any rules in this catalog.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-shadow">
  <title><structname>pg_shadow</structname></title>

  <indexterm zone="catalog-pg-shadow">
   <primary>pg_shadow</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_shadow</structname> contains information about
   database users.  The name stems from the fact that this table
   should not be readable by the public since it contains passwords.
   <link linkend="view-pg-user"><structname>pg_user</structname></link>
   is a publicly readable view on
   <structname>pg_shadow</structname> that blanks out the password field.
  </para>

  <para>
   <xref linkend="user-manag"> contains detailed information about user and
   privilege management.
  </para>

  <para>
   Because user identities are cluster-wide,
   <structname>pg_shadow</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_shadow</structname> per cluster, not
   one per database.
  </para>

  <table>
   <title><structname>pg_shadow</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>User name</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>User id (arbitrary number used to reference this user)</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>User may create databases</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>User is a superuser</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       User may update system catalogs.  (Even a superuser may not do
       this unless this column is true.)
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Password</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <entry>Account expiry time (only used for password authentication)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Session defaults for run-time configuration variables</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-statistic">
  <title><structname>pg_statistic</structname></title>

  <indexterm zone="catalog-pg-statistic">
   <primary>pg_statistic</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_statistic</structname> stores statistical data about
   the contents of the database.  Entries are created by
   <command>ANALYZE</command> and subsequently used by the query planner.
   There is one entry for each table column that has been analyzed.
   Note that all the statistical data is inherently approximate,
   even assuming that it is up-to-date.
  </para>

  <para>
   Since different kinds of statistics may be appropriate for different
   kinds of data, <structname>pg_statistic</structname> is designed not
   to assume very much about what sort of statistics it stores.  Only
   extremely general statistics (such as nullness) are given dedicated
   columns in <structname>pg_statistic</structname>.  Everything else
   is stored in <quote>slots</quote>, which are groups of associated columns whose
   content is identified by a code number in one of the slot's columns.
   For more information see
   <filename>src/include/catalog/pg_statistic.h</filename>.
  </para>

  <para>
   <structname>pg_statistic</structname> should not be readable by the
   public, since even statistical information about a table's contents
   may be considered sensitive.  (Example: minimum and maximum values
   of a salary column might be quite interesting.)
   <link linkend="view-pg-stats"><structname>pg_stats</structname></link>
   is a publicly readable view on
   <structname>pg_statistic</structname> that only exposes information
   about those tables that are readable by the current user.
  </para>

  <table>
   <title><structname>pg_statistic</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>starelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table that the described column belongs to</entry>
     </row>

     <row>
      <entry><structfield>staattnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>The number of the described column</entry>
     </row>

     <row>
      <entry><structfield>stanullfrac</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>The fraction of the column's entries that are null</entry>
     </row>

     <row>
      <entry><structfield>stawidth</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>The average stored width, in bytes, of nonnull entries</entry>
     </row>

     <row>
      <entry><structfield>stadistinct</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>The number of distinct nonnull data values in the column.
      A value greater than zero is the actual number of distinct values.
      A value less than zero is the negative of a fraction of the number
      of rows in the table (for example, a column in which values appear about
      twice on the average could be represented by <structfield>stadistinct</> = -0.5).
      A zero value means the number of distinct values is unknown.
      </entry>
     </row>

     <row>
      <entry><structfield>stakind<replaceable>N</></structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       A code number indicating the kind of statistics stored in the
       <replaceable>N</>th <quote>slot</quote> of the
       <structname>pg_statistic</structname> row.
      </entry>
     </row>

     <row>
      <entry><structfield>staop<replaceable>N</></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       An operator used to derive the statistics stored in the
       <replaceable>N</>th <quote>slot</quote>.  For example, a
       histogram slot would show the <literal>&lt;</literal> operator
       that defines the sort order of the data.
      </entry>
     </row>

     <row>
      <entry><structfield>stanumbers<replaceable>N</></structfield></entry>
      <entry><type>float4[]</type></entry>
      <entry></entry>
      <entry>
       Numerical statistics of the appropriate kind for the
       <replaceable>N</>th <quote>slot</quote>, or null if the slot
       kind does not involve numerical values.
      </entry>
     </row>

     <row>
      <entry><structfield>stavalues<replaceable>N</></structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       Column data values of the appropriate kind for the
       <replaceable>N</>th <quote>slot</quote>, or null if the slot
       kind does not store any data values.  Each array's element
       values are actually of the specific column's data type, so there
       is no way to define these columns' type more specifically than
       <type>anyarray</>.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-trigger">
  <title><structname>pg_trigger</structname></title>

  <indexterm zone="catalog-pg-trigger">
   <primary>pg_trigger</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_trigger</structname> stores triggers on tables.  See under
   <command>CREATE TRIGGER</command> for more information.
  </para>

  <table>
   <title><structname>pg_trigger</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tgrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table this trigger is on</entry>
     </row>

     <row>
      <entry><structfield>tgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Trigger name (must be unique among triggers of same table)</entry>
     </row>

     <row>
      <entry><structfield>tgfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>The function to be called</entry>
     </row>

     <row>
      <entry><structfield>tgtype</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Bit mask identifying trigger conditions</entry>
     </row>

     <row>
      <entry><structfield>tgenabled</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if trigger is enabled (not presently checked everywhere
      it should be, so disabling a trigger by setting this false does not
      work reliably)</entry>
     </row>

     <row>
      <entry><structfield>tgisconstraint</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if trigger implements a referential integrity constraint</entry>
     </row>

     <row>
      <entry><structfield>tgconstrname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Referential integrity constraint name</entry>
     </row>

     <row>
      <entry><structfield>tgconstrrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>The table referenced by an referential integrity constraint</entry>
     </row>

     <row>
      <entry><structfield>tgdeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if deferrable</entry>
     </row>

     <row>
      <entry><structfield>tginitdeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>True if initially deferred</entry>
     </row>

     <row>
      <entry><structfield>tgnargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>Number of argument strings passed to trigger function</entry>
     </row>

     <row>
      <entry><structfield>tgattr</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>Currently unused</entry>
     </row>

     <row>
      <entry><structfield>tgargs</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>Argument strings to pass to trigger, each null-terminated</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <para>
    <literal>pg_class.reltriggers</literal> needs to match up with the
    entries in this table.
   </para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-type">
  <title><structname>pg_type</structname></title>

  <indexterm zone="catalog-pg-type">
   <primary>pg_type</primary>
  </indexterm>

  <para>
   The catalog <structname>pg_type</structname> stores information about data types.  Base types
   (scalar types) are created with <command>CREATE TYPE</command>.
   A composite type is automatically created for each table in the database, to
   represent the row structure of the table.  It is also possible to create
   composite types with <command>CREATE TYPE AS</command> and
   domains with <command>CREATE DOMAIN</command>.
  </para>

  <table>
   <title><structname>pg_type</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>typname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>Data type name</entry>
     </row>

     <row>
      <entry><structfield>typnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       The OID of the namespace that contains this type
      </entry>
     </row>

     <row>
      <entry><structfield>typowner</structfield></entry>
      <entry><type>int4</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usesysid</literal></entry>
      <entry>Owner of the type</entry>
     </row>

     <row>
      <entry><structfield>typlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       For a fixed-size type, <structfield>typlen</structfield> is the number
       of bytes in the internal representation of the type.  But for a
       variable-length type, <structfield>typlen</structfield> is negative.
       -1 indicates a <quote>varlena</> type (one that has a length word),
       -2 indicates a null-terminated C string.
      </entry>
     </row>

     <row>
      <entry><structfield>typbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <structfield>typbyval</structfield> determines whether internal
       routines pass a value of this type by value or by reference.
       <structfield>typbyval</structfield> had better be false if
       <structfield>typlen</structfield> is not 1, 2, or 4 (or 8 on machines
       where Datum is 8 bytes).
       Variable-length types are always passed by reference. Note that
       <structfield>typbyval</structfield> can be false even if the
       length would allow pass-by-value; this is currently true for
       type <type>float4</type>, for example.
      </entry>
     </row>

     <row>
      <entry><structfield>typtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <structfield>typtype</structfield> is <literal>b</literal> for
       a base type, <literal>c</literal> for a composite type (i.e., a
       table's row type), <literal>d</literal> for a domain, or
       <literal>p</literal> for a pseudo-type.  See also
       <structfield>typrelid</structfield> and
       <structfield>typbasetype</structfield>.
      </entry>
     </row>

     <row>
      <entry><structfield>typisdefined</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       True if the type is defined, false if this is a placeholder
       entry for a not-yet-defined type.  When
       <structfield>typisdefined</structfield> is false, nothing
       except the type name, namespace, and OID can be relied on.
      </entry>
     </row>

     <row>
      <entry><structfield>typdelim</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>Character that separates two values of this type when parsing
      array input.  Note that the delimiter is associated with the array
      element data type, not the array data type.</entry>
     </row>

     <row>
      <entry><structfield>typrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       If this is a composite type (see
       <structfield>typtype</structfield>), then this column points to
       the <structname>pg_class</structname> entry that defines the
       corresponding table.  (For a free-standing composite type, the
       <structname>pg_class</structname> entry doesn't really represent
       a table, but it is needed anyway for the type's
       <structname>pg_attribute</structname> entries to link to.)
       Zero for base types.
      </entry>
     </row>

     <row>
      <entry><structfield>typelem</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       If <structfield>typelem</structfield> is not 0 then it
       identifies another row in <structname>pg_type</structname>.
       The current type can then be subscripted like an array yielding
       values of type <structfield>typelem</structfield>.  A
       <quote>true</quote> array type is variable length
       (<structfield>typlen</structfield> = -1),
       but some fixed-length (<structfield>typlen</structfield> &gt; 0) types
       also have nonzero <structfield>typelem</structfield>, for example
       <type>name</type> and <type>oidvector</type>.
       If a fixed-length type has a <structfield>typelem</structfield> then
       its internal representation must be some number of values of the
       <structfield>typelem</structfield> data type with no other data.
       Variable-length array types have a header defined by the array
       subroutines.
      </entry>
     </row>

     <row>
      <entry><structfield>typinput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Input conversion function (text format)</entry>
     </row>

     <row>
      <entry><structfield>typoutput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Output conversion function (text format)</entry>
     </row>

     <row>
      <entry><structfield>typreceive</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Input conversion function (binary format), or 0 if none</entry>
     </row>

     <row>
      <entry><structfield>typsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>Output conversion function (binary format), or 0 if none</entry>
     </row>

     <row>
      <entry><structfield>typalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>

       <structfield>typalign</structfield> is the alignment required
       when storing a value of this type.  It applies to storage on
       disk as well as most representations of the value inside
       <productname>PostgreSQL</>.
       When multiple values are stored consecutively, such
       as in the representation of a complete row on disk, padding is
       inserted before a datum of this type so that it begins on the
       specified boundary.  The alignment reference is the beginning
       of the first datum in the sequence.
      </para><para>
       Possible values are:
       <itemizedlist>
        <listitem>
         <para><literal>c</> = <type>char</type> alignment, i.e., no alignment needed.</para>
        </listitem>
        <listitem>
         <para><literal>s</> = <type>short</type> alignment (2 bytes on most machines).</para>
        </listitem>
        <listitem>
         <para><literal>i</> = <type>int</type> alignment (4 bytes on most machines).</para>
        </listitem>
        <listitem>
         <para><literal>d</> = <type>double</type> alignment (8 bytes on many machines, but by no means all).</para>
        </listitem>
       </itemizedlist>
      </para><note>
       <para>
        For types used in system tables, it is critical that the size
        and alignment defined in <structname>pg_type</structname>
        agree with the way that the compiler will lay out the column in
        a structure representing a table row.
       </para>
      </note></entry>
     </row>

     <row>
      <entry><structfield>typstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typstorage</structfield> tells for varlena
       types (those with <structfield>typlen</structfield> = -1) if
       the type is prepared for toasting and what the default strategy
       for attributes of this type should be.
       Possible values are
       <itemizedlist>
        <listitem>
         <para><literal>p</>: Value must always be stored plain.</para>
        </listitem>
        <listitem>
         <para>
          <literal>e</>: Value can be stored in a <quote>secondary</quote>
          relation (if relation has one, see
          <literal>pg_class.reltoastrelid</literal>).
         </para>
        </listitem>
        <listitem>
         <para><literal>m</>: Value can be stored compressed inline.</para>
        </listitem>
        <listitem>
         <para><literal>x</>: Value can be stored compressed inline or stored in <quote>secondary</quote> storage.</para>
        </listitem>
       </itemizedlist>
       Note that <literal>m</> columns can also be moved out to secondary
       storage, but only as a last resort (<literal>e</> and <literal>x</> columns are
       moved first).
      </para></entry>
     </row>

     <row>
      <entry><structfield>typnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typnotnull</structfield> represents a not-null
       constraint on a type.  Used for domains only.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typbasetype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry><para>
       If this is a domain (see <structfield>typtype</structfield>),
       then <structfield>typbasetype</structfield> identifies
       the type that this one is based on.  Zero if not a domain.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typtypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       Domains use <structfield>typtypmod</structfield> to record the <literal>typmod</>
       to be applied to their base type (-1 if base type does not use a
       <literal>typmod</>).  -1 if this type is not a domain.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typndims</structfield> is the number of array dimensions
       for a domain that is an array (that is, <structfield>typbasetype</> is an array type;
       the domain's <structfield>typelem</> will match the base type's <structfield>typelem</structfield>).
       Zero for types other than array domains.
       </para></entry>
     </row>

     <row>
      <entry><structfield>typdefaultbin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       If <structfield>typdefaultbin</> is not null, it is the <function>nodeToString()</function>
       representation of a default expression for the type.  This is
       only used for domains.
      </para></entry>
     </row>

     <row>
      <entry><structfield>typdefault</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><para>
       <structfield>typdefault</> is null if the type has no associated
       default value. If <structfield>typdefaultbin</> is not null,
       <structfield>typdefault</> must contain a human-readable version of the
       default expression represented by <structfield>typdefaultbin</>.  If
       <structfield>typdefaultbin</> is null and <structfield>typdefault</> is
       not, then <structfield>typdefault</> is the external representation of
       the type's default value, which may be fed to the type's input
       converter to produce a constant.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="views-overview">
  <title>System Views</title>

  <para>
   In addition to the system catalogs, <productname>PostgreSQL</productname>
   provides a number of built-in views.  The system views provide convenient
   access to some commonly used queries on the system catalogs.  Some of these
   views provide access to internal server state, as well.
  </para>

  <para>
   <xref linkend="view-table"> lists the system views described here.
   More detailed documentation of each view follows below.
   There are some additional views that provide access to the results of
   the statistics collector; they are described in <xref
   linkend="monitoring-stats-views-table">.
  </para>

  <para>
   The information schema (<xref linkend="information-schema">) provides
   an alternative set of views which overlap the functionality of the system
   views.  Since the information schema is SQL-standard whereas the views
   described here are <productname>PostgreSQL</productname>-specific,
   it's usually better to use the information schema if it provides all
   the information you need.
  </para>

  <para>
   Except where noted, all the views described here are read-only.
  </para>

  <table id="view-table">
   <title>System Views</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>View Name</entry>
      <entry>Purpose</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="view-pg-indexes"><structname>pg_indexes</structname></link></entry>
      <entry>indexes</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-locks"><structname>pg_locks</structname></link></entry>
      <entry>currently held locks</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-rules"><structname>pg_rules</structname></link></entry>
      <entry>rules</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-settings"><structname>pg_settings</structname></link></entry>
      <entry>parameter settings</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-stats"><structname>pg_stats</structname></link></entry>
      <entry>planner statistics</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-tables"><structname>pg_tables</structname></link></entry>
      <entry>tables</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user"><structname>pg_user</structname></link></entry>
      <entry>database users</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-views"><structname>pg_views</structname></link></entry>
      <entry>views</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-indexes">
  <title><structname>pg_indexes</structname></title>

  <indexterm zone="view-pg-indexes">
   <primary>pg_indexes</primary>
  </indexterm>

  <para>
   The view <structname>pg_indexes</structname> provides access to
   useful information about each index in the database.
  </para>

  <table>
   <title><structname>pg_indexes</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>name of schema containing table and index</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>name of table the index is for</entry>
     </row>
     <row>
      <entry><structfield>indexname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>name of index</entry>
     </row>
     <row>
      <entry><structfield>indexdef</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>index definition (a reconstructed creation command)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-locks">
  <title><structname>pg_locks</structname></title>

  <indexterm zone="view-pg-locks">
   <primary>pg_locks</primary>
  </indexterm>

  <para>
   The view <structname>pg_locks</structname> provides access to
   information about the locks held by open transactions within the
   database server.  See <xref linkend="mvcc"> for more discussion
   of locking.
  </para>

  <para>
   <structname>pg_locks</structname> contains one row per active lockable
   object, requested lock mode, and relevant transaction.  Thus, the same
   lockable object may
   appear many times, if multiple transactions are holding or waiting
   for locks on it.  However, an object that currently has no locks on it
   will not appear at all.  A lockable object is either a relation (e.g., a
   table) or a transaction ID.
  </para>

  <para>
   Note that this view includes only table-level
   locks, not row-level ones.  If a transaction is waiting for a
   row-level lock, it will appear in the view as waiting for the
   transaction ID of the current holder of that row lock.
  </para>

  <table>
   <title><structname>pg_locks</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>relation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       OID of the locked relation, or NULL if the lockable object
       is a transaction ID
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>
       OID of the database in which the locked relation exists, or
       zero if the locked relation is a globally-shared table, or
       NULL if the lockable object is a transaction ID
      </entry>
     </row>
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       ID of a transaction, or NULL if the lockable object is a relation
      </entry>
     </row>
     <row>
      <entry><structfield>pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>process ID of a server process holding or awaiting this
      lock</entry>
     </row>
     <row>
      <entry><structfield>mode</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>name of the lock mode held or desired by this process (see <xref
      linkend="locking-tables">)</entry>
     </row>
     <row>
      <entry><structfield>granted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <entry>true if lock is held, false if lock is awaited</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structfield>granted</structfield> is true in a row representing a lock
   held by the indicated session.  False indicates that this session is
   currently waiting to acquire this lock, which implies that some other
   session is holding a conflicting lock mode on the same lockable object.
   The waiting session will sleep until the other lock is released (or a
   deadlock situation is detected). A single session can be waiting to acquire
   at most one lock at a time.
  </para>

  <para>
   Every transaction holds an exclusive lock on its transaction ID for its
   entire duration. If one transaction finds it necessary to wait specifically
   for another transaction, it does so by attempting to acquire share lock on
   the other transaction ID. That will succeed only when the other transaction
   terminates and releases its locks. 
  </para>

  <para>
   When the <structname>pg_locks</structname> view is accessed, the
   internal lock manager data structures are momentarily locked, and
   a copy is made for the view to display.  This ensures that the
   view produces a consistent set of results, while not blocking
   normal lock manager operations longer than necessary.  Nonetheless
   there could be some impact on database performance if this view is
   read often.
  </para>

  <para>
   <structname>pg_locks</structname> provides a global view of all locks
   in the database cluster, not only those relevant to the current database.
   Although its <structfield>relation</structfield> column can be joined
   against <structname>pg_class</>.<structfield>oid</> to identify locked
   relations, this will only work correctly for relations in the current
   database (those for which the <structfield>database</structfield> column
   is either the current database's OID or zero).
  </para>

  <para>
   If you have enabled the statistics collector, the
   <structfield>pid</structfield> column can be joined to the
   <structfield>procpid</structfield> column of the
   <structname>pg_stat_activity</structname> view to get more
   information on the session holding or waiting to hold the lock.
  </para>

 </sect1>

 <sect1 id="view-pg-rules">
  <title><structname>pg_rules</structname></title>

  <indexterm zone="view-pg-rules">
   <primary>pg_rules</primary>
  </indexterm>

  <para>
   The view <structname>pg_rules</structname> provides access to
   useful information about query rewrite rules.
  </para>

  <table>
   <title><structname>pg_rules</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>name of schema containing table</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>name of table the rule is for</entry>
     </row>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.rulename</literal></entry>
      <entry>name of rule</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>rule definition (a reconstructed creation command)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_rules</structname> view excludes the ON SELECT rules of
   views; those can be seen in <structname>pg_views</structname>.
  </para>

 </sect1>

 <sect1 id="view-pg-settings">
  <title><structname>pg_settings</structname></title>

  <indexterm zone="view-pg-settings">
   <primary>pg_settings</primary>
  </indexterm>

  <para>
   The view <structname>pg_settings</structname> provides access to
   run-time parameters of the server.  It is essentially an alternative
   interface to the <command>SHOW</> and <command>SET</> commands.
   It also provides access to some facts about each parameter that are
   not directly available from <command>SHOW</>, such as minimum and
   maximum values.
  </para>

  <table>
   <title><structname>pg_settings</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>run-time configuration parameter name</entry>
     </row>
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>current value of the parameter</entry>
     </row>
     <row>
      <entry><structfield>context</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>context required to set the parameter's value</entry>
     </row>
     <row>
      <entry><structfield>vartype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>parameter type (<literal>bool</>, <literal>integer</>,
       <literal>real</>, or <literal>string</>)
      </entry>
     </row>
     <row>
      <entry><structfield>source</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>source of the current parameter value</entry>
     </row>
     <row>
      <entry><structfield>min_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>minimum allowed value of the parameter (NULL for nonnumeric
      values)</entry>
     </row>
     <row>
      <entry><structfield>max_val</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>maximum allowed value of the parameter (NULL for nonnumeric
      values)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  
  <para>
   The <structname>pg_settings</structname> view cannot be inserted into or
   deleted from, but it can be updated.  An <command>UPDATE</command> applied
   to a row of <structname>pg_settings</structname> is equivalent to executing
   the <xref linkend="SQL-SET" endterm="SQL-SET-title"> command on that named
   parameter. The change only affects the value used by the current
   session. If an <command>UPDATE</command> is issued within a transaction
   that is later aborted, the effects of the <command>UPDATE</command> command
   disappear when the transaction is rolled back. Once the surrounding
   transaction is committed, the effects will persist until the end of the
   session, unless overridden by another <command>UPDATE</command> or
   <command>SET</command>.
  </para>

 </sect1>

 <sect1 id="view-pg-stats">
  <title><structname>pg_stats</structname></title>

  <indexterm zone="view-pg-stats">
   <primary>pg_stats</primary>
  </indexterm>

  <para>
   The view <structname>pg_stats</structname> provides access to
   the information stored in the <link
   linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>
   catalog.  This view allows access only to rows of
   <structname>pg_statistic</structname> that correspond to tables the
   user has permission to read, and therefore it is safe to allow public
   read access to this view.
  </para>

  <para>
   <structname>pg_stats</structname> is also designed to present the
   information in a more readable format than the underlying catalog
   --- at the cost that its schema must be extended whenever new slot types
   are defined for <structname>pg_statistic</structname>.
  </para>

  <table>
   <title><structname>pg_stats</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>name of schema containing table</entry>
     </row>

     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>name of table</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attname</literal></entry>
      <entry>name of the column described by this row</entry>
     </row>

     <row>
      <entry><structfield>null_frac</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>fraction of column entries that are null</entry>
     </row>

     <row>
      <entry><structfield>avg_width</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>average width in bytes of column's entries</entry>
     </row>

     <row>
      <entry><structfield>n_distinct</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>If greater than zero, the estimated number of distinct values
      in the column.  If less than zero, the negative of the number of
      distinct values divided by the number of rows.  (The negated form
      is used when <command>ANALYZE</> believes that the number of distinct
      values
      is likely to increase as the table grows; the positive form is used
      when the column seems to have a fixed number of possible values.)
      For example, -1 indicates a unique column in which the number of
      distinct values is the same as the number of rows.
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_vals</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>A list of the most common values in the column. (NULL if
      no values seem to be more common than any others.)</entry>
     </row>

     <row>
      <entry><structfield>most_common_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>A list of the frequencies of the most common values,
      i.e., number of occurrences of each divided by total number of rows.
      (NULL when <structfield>most_common_vals</structfield> is.)
     </entry>
     </row>

     <row>
      <entry><structfield>histogram_bounds</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>A list of values that divide the column's values into
      groups of approximately equal population.  The values in
      <structfield>most_common_vals</>, if present, are omitted from this
      histogram calculation.  (This column is NULL if the column data type
      does not have a <literal>&lt;</> operator or if the
      <structfield>most_common_vals</> list accounts for the entire
      population.)
      </entry>
     </row>

     <row>
      <entry><structfield>correlation</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>Statistical correlation between physical row ordering and
      logical ordering of the column values.  This ranges from -1 to +1.
      When the value is near -1 or +1, an index scan on the column will
      be estimated to be cheaper than when it is near zero, due to reduction
      of random access to the disk.  (This column is NULL if the column data
      type does not have a <literal>&lt;</> operator.)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The maximum number of entries in the <structfield>most_common_vals</>
   and <structfield>histogram_bounds</> arrays can be set on a
   column-by-column basis using the <command>ALTER TABLE SET STATISTICS</>
   command, or globally by setting the
   <varname>default_statistics_target</varname> runtime parameter.
  </para>

 </sect1>

 <sect1 id="view-pg-tables">
  <title><structname>pg_tables</structname></title>

  <indexterm zone="view-pg-tables">
   <primary>pg_tables</primary>
  </indexterm>

  <para>
   The view <structname>pg_tables</structname> provides access to
   useful information about each table in the database.
  </para>

  <table>
   <title><structname>pg_tables</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>name of schema containing table</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>name of table</entry>
     </row>
     <row>
      <entry><structfield>tableowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usename</literal></entry>
      <entry>name of table's owner</entry>
     </row>
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasindex</literal></entry>
      <entry>true if table has (or recently had) any indexes</entry>
     </row>
     <row>
      <entry><structfield>hasrules</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasrules</literal></entry>
      <entry>true if table has rules</entry>
     </row>
     <row>
      <entry><structfield>hastriggers</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.reltriggers</literal></entry>
      <entry>true if table has triggers</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user">
  <title><structname>pg_user</structname></title>

  <indexterm zone="view-pg-user">
   <primary>pg_user</primary>
  </indexterm>

  <para>
   The view <structname>pg_user</structname> provides access to
   information about database users.  This is simply a publicly
   readable view of 
   <link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>
   that blanks out the password field.
  </para>

  <table>
   <title><structname>pg_user</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <entry>User name</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>User id (arbitrary number used to reference this user)</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>User may create databases</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>User is a superuser</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       User may update system catalogs.  (Even a superuser may not do
       this unless this column is true.)
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Not the password (always reads as <literal>********</>)</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <entry>Account expiry time (only used for password authentication)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>Session defaults for run-time configuration variables</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-views">
  <title><structname>pg_views</structname></title>

  <indexterm zone="view-pg-views">
   <primary>pg_views</primary>
  </indexterm>

  <para>
   The view <structname>pg_views</structname> provides access to
   useful information about each view in the database.
  </para>

  <table>
   <title><structname>pg_views</> Columns</title>

   <tgroup cols=4>
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <entry>name of schema containing view</entry>
     </row>
     <row>
      <entry><structfield>viewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <entry>name of view</entry>
     </row>
     <row>
      <entry><structfield>viewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-shadow"><structname>pg_shadow</structname></link>.usename</literal></entry>
      <entry>name of view's owner</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>view definition (a reconstructed SELECT query)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-tabs-mode:nil
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/share/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
