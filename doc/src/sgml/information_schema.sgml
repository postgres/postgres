<!-- $Header: /cvsroot/pgsql/doc/src/sgml/information_schema.sgml,v 1.10.2.4 2005/12/08 20:44:18 petere Exp $ -->

<chapter id="information-schema">
 <title>The Information Schema</title>

 <indexterm zone="information-schema">
  <primary>information schema</primary>
 </indexterm>

 <para>
  The information schema consists of a set of views that contain
  information about the objects defined in the current database.  The
  information schema is defined in the SQL standard and can therefore
  be expected to be portable and remain stable --- unlike the system
  catalogs, which are specific to
  <productname>PostgreSQL</productname> and are modelled after
  implementation concerns.  The information schema views do not,
  however, contain information about
  <productname>PostgreSQL</productname>-specific features; to inquire
  about those you need to query the system catalogs or other
  <productname>PostgreSQL</productname>-specific views.
 </para>

 <sect1 id="infoschema-schema">
  <title>The Schema</title>

  <para>
   The information schema itself is a schema named
   <literal>information_schema</literal>.  This schema automatically
   exists in all databases.  The owner of this schema is the initial
   database user in the cluster, and that user naturally has all the
   privileges on this schema, including the ability to drop it (but
   the space savings achieved by this are minuscule).
  </para>

  <para>
   By default, the information schema is not in the schema search
   path, so you need to access all objects in it through qualified
   names.  Since the names of some of the objects in the information
   schema are generic names that might occur in user applications, you
   should be careful if you want to put the information schema in the
   path.
  </para>
 </sect1>

 <sect1 id="infoschema-datatypes">
  <title>Data Types</title>

  <para>
   The columns of the information schema views use special data types
   that are defined in the information schema.  These are defined as
   simple domains over ordinary built-in types.  You should not use
   these types for work outside the information schema, but your
   applications must be prepared for them if they select from the
   information schema.
  </para>

  <para>
   These types are:

   <variablelist>
    <varlistentry>
     <term><type>cardinal_number</type></term>
     <listitem>
      <para>
       A nonnegative integer.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>character_data</type></term>
     <listitem>
      <para>
       A character string (without specific maximum length).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>sql_identifier</type></term>
     <listitem>
      <para>
       A character string.  This type is used for SQL identifiers, the
       type <type>character_data</type> is used for any other kind of
       text data.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>time_stamp</type></term>
     <listitem>
      <para>
       A domain over the type <type>timestamp</type>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Every column in the information schema has one of these four types.
  </para>

  <para>
   Boolean (true/false) data is represented in the information schema
   by a column of type <type>character_data</type> that contains
   either <literal>YES</literal> or <literal>NO</literal>.  (The
   information schema was invented before the type
   <type>boolean</type> was added to the SQL standard, so this
   convention is necessary to keep the information schema backward
   compatible.)
  </para>
 </sect1>

 <sect1 id="infoschema-information-schema-catalog-name">
  <title><literal>information_schema_catalog_name</literal></title>

  <para>
   <literal>information_schema_catalog_name</literal> is a table that
   always contains one row and one column containing the name of the
   current database (current catalog, in SQL terminology).
  </para>

  <table>
   <title><literal>information_schema_catalog_name</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains this information schema</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-applicable-roles">
  <title><literal>applicable_roles</literal></title>

  <para>
   The view <literal>applicable_roles</literal> identifies all groups
   that the current user is a member of.  (A role is the same thing as
   a group.)  Generally, it is better to use the view
   <literal>enabled_roles</literal> instead of this one; see also
   there.
  </para>

  <table>
   <title><literal>applicable_roles</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Always the name of the current user</entry>
     </row>

     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of a group</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraints">
  <title><literal>check_constraints</literal></title>

  <para>
   The view <literal>check_constraints</literal> contains all check
   constraints, either defined on a table or on a domain, that are
   owned by the current user.  (The owner of the table or domain is
   the owner of the constraint.)
  </para>

  <table>
   <title><literal>check_constraints</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the database containing the constraint (always the current database)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the schema containing the constraint</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the constraint</entry>
     </row>

     <row>
      <entry><literal>check_clause</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>The check expression of the check constraint</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-domain-usage">
  <title><literal>column_domain_usage</literal></title>

  <para>
   The view <literal>column_domain_usage</literal> identifies all
   columns (of a table or a view) that make use of some domain defined
   in the current database and owned by the current user.
  </para>

  <table>
   <title><literal>column_domain_usage</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the domain (always the current database)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the domain</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the domain</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the table (always the current database)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-privileges">
  <title><literal>column_privileges</literal></title>

  <para>
   The view <literal>column_privileges</literal> identifies all
   privileges granted on columns to the current user or by the current
   user.  There is one row for each combination of column, grantor,
   and grantee.  Privileges granted to groups are identified in the
   view <literal>role_column_grants</literal>.
  </para>

  <para>
   In <productname>PostgreSQL</productname>, you can only grant
   privileges on entire tables, not individual columns.  Therefore,
   this view contains the same information as
   <literal>table_privileges</literal>, just represented through one
   row for each column in each appropriate table, but it only covers
   privilege types where column granularity is possible:
   <literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal>, <literal>REFERENCES</literal>.  If you
   want to make your applications fit for possible future
   developments, it is generally the right choice to use this view
   instead of <literal>table_privileges</literal> if one of those
   privilege types is concerned.
  </para>

  <table>
   <title><literal>column_privileges</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the user that granted the privilege</entry>
     </row>

     <row>
      <entry><literal>grantee</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the user or group that the privilege was granted to</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the table that contains the column (always the current database)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table that contains the column</entry>
     </row>

     <row>
      <entry><literal>table_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table that contains the column</entry>
     </row>

     <row>
      <entry><literal>column_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>, or
       <literal>REFERENCES</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Note that the column <literal>grantee</literal> makes no
   distinction between users and groups.  If you have users and groups
   with the same name, there is unfortunately no way to distinguish
   them.  A future version of <productname>PostgreSQL</productname>
   will possibly prohibit having users and groups with the same name.
  </para>
 </sect1>

 <sect1 id="infoschema-column-udt-usage">
  <title><literal>column_udt_usage</literal></title>

  <para>
   The view <literal>column_udt_usage</literal> identifies all columns
   that use data types owned by the current user.  Note that in
   <productname>PostgreSQL</productname>, built-in data types behave
   like user-defined types, so they are included here as well.  See
   also <xref linkend="infoschema-columns"> for details.
  </para>

  <table>
   <title><literal>column_udt_usage</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that the column data type (the underlying
       type of the domain, if applicable) is defined in (always the
       current database)
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that the column data type (the underlying
       type of the domain, if applicable) is defined in
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the column data type (the underlying type of the
       domain, if applicable)
      </entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the table (always the current database)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-columns">
  <title><literal>columns</literal></title>

  <para>
   The view <literal>columns</literal> contains information about all
   table columns (or view columns) in the database.  System columns
   (<literal>oid</>, etc.) are not included.  Only those columns are
   shown that the current user has access to (by way of being the
   owner or having some privilege).
  </para>

  <table>
   <title><literal>columns</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the table (always the current database)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>

     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column</entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Ordinal position of the column within the table (count starts at 1)</entry>
     </row>

     <row>
      <entry><literal>column_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Default expression of the column (null if the current user is
       not the owner of the table containing the column)
      </entry>
     </row>

     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> if the column is possibly nullable,
       <literal>NO</literal> if it is known not nullable.  A not-null
       constraint is one way a column can be known not nullable, but
       there may be others.
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Data type of the column, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).  If the column is based on a domain, this column
       refers to the type underlying the domain (and the domain is
       identified in <literal>domain_name</literal> and associated
       columns).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a character or bit
       string type, the declared maximum length; null for all other
       data types or if no maximum length was declared.
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a character type,
       the maximum possible length in octets (bytes) of a datum (this
       should not be of concern to <productname>PostgreSQL</productname> users); null for all
       other data types.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a numeric type, this
       column contains the (declared or implicit) precision of the
       type for this column.  The precision indicates the number of
       significant digits.  It may be expressed in decimal (base 10)
       or binary (base 2) terms, as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a numeric type, this
       column indicates in which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.  For all other data types, this column is null.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies an exact numeric
       type, this column contains the (declared or implicit) scale of
       the type for this column.  The scale indicates the number of
       significant digits to the right of the decimal point.  It may
       be expressed in decimal (base 10) or binary (base 2) terms, as
       specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a date, time, or
       interval type, the declared precision; null for all other data
       types or if no precision was declared.
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Not yet implemented</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Not yet implemented</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       If the column has a domain type, the name of the database that
       the domain is defined in (always the current database), else
       null.
      </entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       If the column has a domain type, the name of the schema that
       the domain is defined in, else null.
      </entry>
     </row>

     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>If the column has a domain type, the name of the domain, else null.</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that the column data type (the underlying
       type of the domain, if applicable) is defined in (always the
       current database)
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that the column data type (the underlying
       type of the domain, if applicable) is defined in
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the column data type (the underlying type of the
       domain, if applicable)
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, because arrays always have unlimited maximum cardinality in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       An identifier of the data type descriptor of the column, unique
       among the data type descriptors pertaining to the table.  This
       is mainly useful for joining with other instances of such
       identifiers.  (The specific format of the identifier is not
       defined and not guaranteed to remain the same in future
       versions.)
      </entry>
     </row>

     <row>
      <entry><literal>is_self_referencing</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Since data types can be defined in a variety of ways in SQL, and
   <productname>PostgreSQL</productname> contains additional ways to
   define data types, their representation in the information schema
   can be somewhat difficult.  The column <literal>data_type</literal>
   is supposed to identify the underlying built-in type of the column.
   In <productname>PostgreSQL</productname>, this means that the type
   is defined in the system catalog schema
   <literal>pg_catalog</literal>.  This column may be useful if the
   application can handle the well-known built-in types specially (for
   example, format the numeric types differently or use the data in
   the precision columns).  The columns <literal>udt_name</literal>,
   <literal>udt_schema</literal>, and <literal>udt_catalog</literal>
   always identify the underlying data type of the column, even if the
   column is based on a domain.  (Since
   <productname>PostgreSQL</productname> treats built-in types like
   user-defined types, built-in types appear here as well.  This is an
   extension of the SQL standard.)  These columns should be used if an
   application wants to process data differently according to the
   type, because in that case it wouldn't matter if the column is
   really based on a domain.  If the column is based on a domain, the
   identity of the domain is stored in the columns
   <literal>domain_name</literal>, <literal>domain_schema</literal>,
   and <literal>domain_catalog</literal>.  If you want to pair up
   columns with their associated data types and treat domains as
   separate types, you could write <literal>coalesce(domain_name,
   udt_name)</literal>, etc.
  </para>
 </sect1>

 <sect1 id="infoschema-constraint-column-usage">
  <title><literal>constraint_column_usage</literal></title>

  <para>
   The view <literal>constraint_column_usage</literal> identifies all
   columns in the current database that are used by some constraint.
   Only those columns are shown that are contained in a table owned
   the current user.  For a check constraint, this view identifies the
   columns that are used in the check expression.  For a foreign key
   constraint, this view identifies the columns that the foreign key
   references.  For a unique or primary key constraint, this view
   identifies the constrained columns.
  </para>

  <table>
   <title><literal>constraint_column_usage</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that contains the
       column that is used by some constraint (always the current
       database)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that contains the table that contains the
       column that is used by some constraint
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the table that contains the column that is used by some
       constraint
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the column that is used by some constraint
      </entry>
     </row>

     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the constraint (always the current database)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the constraint</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the constraint</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-constraint-table-usage">
  <title><literal>constraint_table_usage</literal></title>

  <para>
   The view <literal>constraint_table_usage</literal> identifies all
   tables in the current database that are used by some constraint and
   are owned by the current user.  (This is different from the view
   <literal>table_constraints</literal>, which identifies all table
   constraints along with the table they are defined on.)  For a
   foreign key constraint, this view identifies the table that the
   foreign key references.  For a unique or primary key constraint,
   this view simply identifies the table the constraint belongs to.
   Check constraints and not-null constraints are not included in this
   view.
  </para>

  <table>
   <title><literal>constraint_table_usage</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that is used by
       some constraint (always the current database)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that contains the table that is used by some
       constraint
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table that is used by some constraint</entry>
     </row>

     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the constraint (always the current database)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the constraint</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the constraint</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-data-type-privileges">
  <title><literal>data_type_privileges</literal></title>

  <para>
   The view <literal>data_type_privileges</literal> identifies all
   data type descriptors that the current user has access to, by way
   of being the owner of the described object or having some privilege
   for it.  A data type descriptor is generated whenever a data type
   is used in the definition of a table column, a domain, or a
   function (as parameter or return type) and stores some information
   about how the data type is used in that instance (for example, the
   declared maximum length, if applicable).  Each data type
   descriptors is assigned an arbitrary identifier that is unique
   among the data type descriptor identifiers assigned for one object
   (table, domain, function).  This view is probably not useful for
   applications, but it is used to define some other views in the
   information schema.
  </para>

  <table>
   <title><literal>data_type_privileges</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the described object (always the current database)</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the described object</entry>
     </row>

     <row>
      <entry><literal>object_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the described object</entry>
     </row>

     <row>
      <entry><literal>object_type</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       The type of the described object: one of
       <literal>TABLE</literal> (the data type descriptor pertains to
       a column of that table), <literal>DOMAIN</literal> (the data
       type descriptors pertains to that domain),
       <literal>ROUTINE</literal> (the data type descriptor pertains
       to a parameter or the return data type of that function).
      </entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       The identifier of the data type descriptor, which is unique
       among the data type descriptors for that same object.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-constraints">
  <title><literal>domain_constraints</literal></title>

  <para>
   The view <literal>domain_constraints</literal> contains all
   constraints belonging to domains owned by the current user.
  </para>

  <table>
   <title><literal>domain_constraints</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the constraint (always the current database)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the constraint</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the constraint</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the domain (always the current database)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the domain</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the domain</entry>
     </row>

     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> if the constraint is deferrable, <literal>NO</literal> if not</entry>
     </row>

     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> if the constraint is deferrable and initially deferred, <literal>NO</literal> if not</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-udt-usage">
  <title><literal>domain_udt_usage</literal></title>

  <para>
   The view <literal>domain_udt_usage</literal> identifies all columns
   that use data types owned by the current user. Note that in
   <productname>PostgreSQL</productname>, built-in data types behave
   like user-defined types, so they are included here as well.
  </para>

  <table>
   <title><literal>domain_udt_usage</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the domain data type is defined in (always the current database)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that the domain data type is defined in</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the domain data type</entry>
     </row>

     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the domain (always the current database)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the domain</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the domain</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domains">
  <title><literal>domains</literal></title>

  <para>
   The view <literal>domains</literal> contains all domains defined in
   the current database.
  </para>

  <table>
   <title><literal>domains</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the domain (always the current database)</entry>
     </row>

     <row>
      <entry><literal>domain_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the domain</entry>
     </row>

     <row>
      <entry><literal>domain_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the domain</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Data type of the domain, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If the domain has a character or bit string type, the declared
       maximum length; null for all other data types or if no maximum
       length was declared.
      </entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If the domain has a character type, the maximum possible length
       in octets (bytes) of a datum (this should not be of concern to
       <productname>PostgreSQL</productname> users); null for all
       other data types.
      </entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If the domain has a numeric type, this column contains the
       (declared or implicit) precision of the type for this column.
       The precision indicates the number of significant digits.  It
       may be expressed in decimal (base 10) or binary (base 2) terms,
       as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If the domain has a numeric type, this column indicates in
       which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.  For all other data types, this column is null.
      </entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If the domain has an exact numeric type, this column contains
       the (declared or implicit) scale of the type for this column.
       The scale indicates the number of significant digits to the
       right of the decimal point.  It may be expressed in decimal
       (base 10) or binary (base 2) terms, as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If the domain has a date, time, or interval type, the declared
       precision; null for all other data types or if no precision was
       declared.
      </entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Not yet implemented</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Not yet implemented</entry>
     </row>

     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Default expression of the domain</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the domain data type is defined in (always the current database)</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that the domain data type is defined in</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the domain data type</entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, because arrays always have unlimited maximum cardinality in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       An identifier of the data type descriptor of the domain, unique
       among the data type descriptors pertaining to the domain (which
       is trivial, because a domain only contains one data type
       descriptor).  This is mainly useful for joining with other
       instances of such identifiers.  (The specific format of the
       identifier is not defined and not guaranteed to remain the same
       in future versions.)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-element-types">
  <title><literal>element_types</literal></title>

  <para>
   The view <literal>element_types</literal> contains the data type
   descriptors of the elements of arrays.  When a table column,
   domain, function parameter, or function return value is defined to
   be of an array type, the respective information schema view only
   contains <literal>ARRAY</literal> in the column
   <literal>data_type</literal>.  To obtain information on the element
   type of the array, you can join the respective view with this view.
   For example, to show the columns of a table with data types and
   array element types, if applicable, you could do
<programlisting>
SELECT c.column_name, c.data_type, e.data_type AS element_type
FROM information_schema.columns c LEFT JOIN information_schema.element_types e
     ON ((c.table_catalog, c.table_schema, c.table_name, 'TABLE', c.dtd_identifier)
       = (e.object_catalog, e.object_schema, e.object_name, e.object_type, e.array_type_identifier))
WHERE c.table_schema = '...' AND c.table_name = '...'
ORDER BY c.ordinal_position;
</programlisting>
   This view only includes objects that the current user has access
   to, by way of being the owner or having some privilege.
  </para>

  <table>
   <title><literal>element_types</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the object that uses the
       array being described (always the current database)
      </entry>
     </row>

     <row>
      <entry><literal>object_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that contains the object that uses the array
       being described
      </entry>
     </row>

     <row>
      <entry><literal>object_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the object that uses the array being described
      </entry>
     </row>

     <row>
      <entry><literal>object_type</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       The type of the object that uses the array being described: one
       of <literal>TABLE</literal> (the array is used by a column of
       that table), <literal>DOMAIN</literal> (the array is used by
       that domain), <literal>ROUTINE</literal> (the array is used by
       a parameter or the return data type of that function).
      </entry>
     </row>

     <row>
      <entry><literal>array_type_identifier</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       The identifier of the data type descriptor of the array being
       described.  Use this to join with the
       <literal>dtd_identifier</literal> columns of other information
       schema views.
      </entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Data type of the array elements, if it is a built-in type, else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null, since this information is not applied to array element data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null, since this information is not applied to array element data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Not yet implemented</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that the data type of the elements is
       defined in (always the current database)
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that the data type of the elements is
       defined in
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the data type of the elements
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, because arrays always have unlimited maximum cardinality in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       An identifier of the data type descriptor of the element.  This
       is currently not useful.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-enabled-roles">
  <title><literal>enabled_roles</literal></title>

  <para>
   The view <literal>enabled_roles</literal> identifies all groups
   that the current user is a member of.  (A role is the same thing as
   a group.)  The difference between this view and
   <literal>applicable_roles</literal> is that in the future there may
   be a mechanism to enable and disable groups during a session.  In
   that case this view identifies those groups that are currently
   enabled.
  </para>

  <table>
   <title><literal>enabled_roles</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of a group</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-key-column-usage">
  <title><literal>key_column_usage</literal></title>

  <para>
   The view <literal>key_column_usage</literal> identifies all columns
   in the current database that are restricted by some unique, primary
   key, or foreign key constraint.  Check constraints are not included
   in this view.  Only those columns are shown that are contained in a
   table owned the current user.
  </para>

  <table>
   <title><literal>key_column_usage</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the constraint (always the current database)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the constraint</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the constraint</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that contains the
       column that is restricted by some constraint (always the
       current database)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that contains the table that contains the
       column that is restricted by some constraint
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the table that contains the column that is restricted
       by some constraint
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the column that is restricted by some constraint
      </entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal</entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Ordinal position of the column within the constraint key (count
       starts at 1)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-parameters">
  <title><literal>parameters</literal></title>

  <para>
   The view <literal>parameters</literal> contains information about
   the parameters (arguments) all functions in the current database.
   Only those functions are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>

  <table>
   <title><literal>parameters</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"> for more information.
      </entry>
     </row>

     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Ordinal position of the parameter in the argument list of the
       function (count starts at 1)
      </entry>
     </row>

     <row>
      <entry><literal>parameter_mode</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Always <literal>IN</literal>, meaning input parameter (In the
       future there might be other parameter modes.)
      </entry>
     </row>

     <row>
      <entry><literal>is_result</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>parameter_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Always null, since PostgreSQL does not support named parameters</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Data type of the parameter, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that the data type of the parameter is
       defined in (always the current database)
      </entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that the data type of the parameter is
       defined in
      </entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the data type of the parameter
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, because arrays always have unlimited maximum cardinality in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       An identifier of the data type descriptor of the parameter,
       unique among the data type descriptors pertaining to the
       function.  This is mainly useful for joining with other
       instances of such identifiers.  (The specific format of the
       identifier is not defined and not guaranteed to remain the same
       in future versions.)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-referential-constraints">
  <title><literal>referential_constraints</literal></title>

  <para>
   The view <literal>referential_constraints</literal> contains all
   referential (foreign key) constraints in the current database that
   belong to a table owned by the current user.
  </para>

  <table>
   <title><literal>referential_constraints</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the database containing the constraint (always the current database)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the schema containing the constraint</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the constraint</entry>
     </row>

     <row>
      <entry><literal>unique_constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Name of the database that contains the unique or primary key
       constraint that the foreign key constraint references (always
       the current database)
      </entry>
     </row>

     <row>
      <entry><literal>unique_constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Name of the schema that contains the unique or primary key
       constraint that the foreign key constraint references
      </entry>
     </row>

     <row>
      <entry><literal>unique_constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Name of the unique or primary key constraint that the foreign
       key constraint references
      </entry>
     </row>

     <row>
      <entry><literal>match_option</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Match option of the foreign key constraint:
       <literal>FULL</literal>, <literal>PARTIAL</literal>, or
       <literal>NONE</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>update_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Update rule of the foreign key constraint:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal>, or
       <literal>NO ACTION</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>delete_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Delete rule of the foreign key constraint:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal>, or
       <literal>NO ACTION</literal>.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-column-grants">
  <title><literal>role_column_grants</literal></title>

  <para>
   The view <literal>role_column_grants</literal> identifies all
   privileges granted on columns to a group that the current user is a
   member of.  Further information can be found under
   <literal>column_privileges</literal>.
  </para>

  <table>
   <title><literal>role_column_grants</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the user that granted the privilege</entry>
     </row>

     <row>
      <entry><literal>grantee</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the group that the privilege was granted to</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the table that contains the column (always the current database)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table that contains the column</entry>
     </row>

     <row>
      <entry><literal>table_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table that contains the column</entry>
     </row>

     <row>
      <entry><literal>column_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>, or
       <literal>REFERENCES</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-routine-grants">
  <title><literal>role_routine_grants</literal></title>

  <para>
   The view <literal>role_routine_grants</literal> identifies all
   privileges granted on functions to a group that the current user is
   a member of.  Further information can be found under
   <literal>routine_privileges</literal>.
  </para>

  <table>
   <title><literal>role_routine_grants</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the user that granted the privilege</entry>
     </row>

     <row>
      <entry><literal>grantee</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the group that the privilege was granted to</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"> for more information.
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the function (may be duplicated in case of overloading)</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>Always <literal>EXECUTE</literal> (the only privilege type for functions)</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-table-grants">
  <title><literal>role_table_grants</literal></title>

  <para>
   The view <literal>role_table_grants</literal> identifies all
   privileges granted on tables or views to a group that the current
   user is a member of.  Further information can be found under
   <literal>table_privileges</literal>.
  </para>

  <table>
   <title><literal>role_table_grants</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the user that granted the privilege</entry>
     </row>

     <row>
      <entry><literal>grantee</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the group that the privilege was granted to</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the table (always the current database)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type of the privilege: <literal>SELECT</literal>,
       <literal>DELETE</literal>, <literal>INSERT</literal>,
       <literal>UPDATE</literal>, <literal>REFERENCES</literal>,
       <literal>RULE</literal>, or <literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>

     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-usage-grants">
  <title><literal>role_usage_grants</literal></title>

  <para>
   The view <literal>role_usage_grants</literal> is meant to identify
   <literal>USAGE</literal> privileges granted on various kinds of
   objects to a group that the current user is a member of.  In
   <productname>PostgreSQL</productname>, this currently only applies
   to domains, and since domains do not have real privileges in
   <productname>PostgreSQL</productname>, this view is empty.  Further
   information can be found under <literal>usage_privileges</literal>.
   In the future, this view may contain more useful information.
  </para>

  <table>
   <title><literal>role_usage_grants</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>In the future, the name of the user that granted the privilege</entry>
     </row>

     <row>
      <entry><literal>grantee</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>In the future, the name of the group that the privilege was granted to</entry>
     </row>

     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the object (always the current database)</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the object</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the object</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>In the future, the type of the object</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>Always <literal>USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-privileges">
  <title><literal>routine_privileges</literal></title>

  <para>
   The view <literal>routine_privileges</literal> identifies all
   privileges granted on functions to the current user or by the
   current user.  There is one row for each combination of function,
   grantor, and grantee.  Privileges granted to groups are identified
   in the view <literal>role_routine_grants</literal>.
  </para>

  <table>
   <title><literal>routine_privileges</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the user that granted the privilege</entry>
     </row>

     <row>
      <entry><literal>grantee</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the user or group that the privilege was granted to</entry>
     </row>

     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"> for more information.
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the function (may be duplicated in case of overloading)</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>Always <literal>EXECUTE</literal> (the only privilege type for functions)</entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Note that the column <literal>grantee</literal> makes no
   distinction between users and groups.  If you have users and groups
   with the same name, there is unfortunately no way to distinguish
   them.  A future version of <productname>PostgreSQL</productname>
   will possibly prohibit having users and groups with the same name.
  </para>
 </sect1>

 <sect1 id="infoschema-routines">
  <title><literal>routines</literal></title>

  <para>
   The view <literal>routines</literal> contains all functions in the
   current database.  Only those functions are shown that the current
   user has access to (by way of being the owner or having some
   privilege).
  </para>

  <table>
   <title><literal>routines</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>

     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>

     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       The <quote>specific name</quote> of the function.  This is a
       name that uniquely identifies the function in the schema, even
       if the real name of the function is overloaded.  The format of
       the specific name is not defined, it should only be used to
       compare it to other instances of specific routine names.
      </entry>
     </row>

     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>

     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>

     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the function (may be duplicated in case of overloading)</entry>
     </row>

     <row>
      <entry><literal>routine_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Always <literal>FUNCTION</literal> (In the future there might
       be other types of routines.)
      </entry>
     </row>

     <row>
      <entry><literal>module_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>module_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>module_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Return data type of the function, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>type_udt_name</literal> and associated
       columns).
      </entry>
     </row>

     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null, since this information is not applied to return data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null, since this information is not applied to return data types in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that the return data type of the function
       is defined in (always the current database)
      </entry>
     </row>

     <row>
      <entry><literal>type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that the return data type of the function is
       defined in
      </entry>
     </row>

     <row>
      <entry><literal>type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the return data type of the function
      </entry>
     </row>

     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, because arrays always have unlimited maximum cardinality in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       An identifier of the data type descriptor of the return data
       type of this function, unique among the data type descriptors
       pertaining to the function.  This is mainly useful for joining
       with other instances of such identifiers.  (The specific format
       of the identifier is not defined and not guaranteed to remain
       the same in future versions.)
      </entry>
     </row>

     <row>
      <entry><literal>routine_body</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If the function is an SQL function, then
       <literal>SQL</literal>, else <literal>EXTERNAL</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>routine_definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The source text of the function (null if the current user is
       not the owner of the function).  (According to the SQL
       standard, this column is only applicable if
       <literal>routine_body</literal> is <literal>SQL</literal>, but
       in <productname>PostgreSQL</productname> it will contain
       whatever source text was specified when the function was
       created.)
      </entry>
     </row>

     <row>
      <entry><literal>external_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If this function is a C function, then the external name (link
       symbol) of the function; else null.  (This works out to be the
       same value that is shown in
       <literal>routine_definition</literal>.)
      </entry>
     </row>

     <row>
      <entry><literal>external_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>The language the function is written in</entry>
     </row>

     <row>
      <entry><literal>parameter_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Always <literal>GENERAL</literal> (The SQL standard defines
       other parameter styles, which are not available in PostgreSQL.)
      </entry>
     </row>

     <row>
      <entry><literal>is_deterministic</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If the function is declared immutable (called deterministic in
       the SQL standard), then <literal>YES</literal>, else
       <literal>NO</literal>.  (You cannot query the other volatility
       levels available in PostgreSQL through the information schema.)
      </entry>
     </row>

     <row>
      <entry><literal>sql_data_access</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Always <literal>MODIFIES</literal>, meaning that the function
       possibly modifies SQL data.  This information is not useful for
       PostgreSQL.
      </entry>
     </row>

     <row>
      <entry><literal>is_null_call</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If the function automatically returns null if any of its
       arguments are null, then <literal>YES</literal>, else
       <literal>NO</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>schema_level_routine</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Always <literal>YES</literal> (The opposite would be a method
       of a user-defined type, which is a feature not available in
       PostgreSQL.)
      </entry>
     </row>

     <row>
      <entry><literal>max_dynamic_result_sets</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>is_user_defined_cast</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>is_implicitly_invocable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>security_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If the function runs with the privileges of the current user,
       then <literal>INVOKER</literal>, if the function runs with the
       privileges of the user who defined it, then
       <literal>DEFINER</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>to_sql_specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-schemata">
  <title><literal>schemata</literal></title>

  <para>
   The view <literal>schemata</literal> contains all schemas in the
   current database that are owned by the current user.
  </para>

  <table>
   <title><literal>schemata</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the schema is contained in (always the current database)</entry>
     </row>

     <row>
      <entry><literal>schema_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema</entry>
     </row>

     <row>
      <entry><literal>schema_owner</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the owner of the schema</entry>
     </row>

     <row>
      <entry><literal>default_character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>default_character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>default_character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-features">
  <title><literal>sql_features</literal></title>

  <para>
   The table <literal>sql_features</literal> contains information
   about which formal features defined in the SQL standard are
   supported by <productname>PostgreSQL</productname>.  This is the
   same information that is presented in <xref linkend="features">.
   There you can also find some additional background information.
  </para>

  <table>
   <title><literal>sql_features</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Identifier string of the feature</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the feature</entry>
     </row>

     <row>
      <entry><literal>sub_feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Identifier string of the subfeature, or a zero-length string if not a subfeature</entry>
     </row>

     <row>
      <entry><literal>sub_feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the subfeature, or a zero-length string if not a subfeature</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> if the feature is fully supported by the
       current version of PostgreSQL, <literal>NO</literal> if not
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Always null, since the PostgreSQL development group does not
       perform formal testing of feature conformance
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Possibly a comment about the supported status of the feature</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-implementation-info">
  <title><literal>sql_implementation_info</literal></title>

  <para>
   The table <literal>sql_information_info</literal> contains
   information about various aspects that are left
   implementation-defined by the SQL standard.  This information is
   primarily intended for use in the context of the ODBC interface;
   users of other interfaces will probably find this information to be
   of little use.  For this reason, the individual implementation
   information items are not described here; you will find them in the
   description of the ODBC interface.
  </para>

  <table>
   <title><literal>sql_implementation_info</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>implementation_info_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Identifier string of the implementation information item</entry>
     </row>

     <row>
      <entry><literal>implementation_info_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the implementation information item</entry>
     </row>

     <row>
      <entry><literal>integer_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Value of the implementation information item, or null if the
       value is contained in the column
       <literal>character_value</literal>
      </entry>
     </row>

     <row>
      <entry><literal>character_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Value of the implementation information item, or null if the
       value is contained in the column
       <literal>integer_value</literal>
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Possibly a comment pertaining to the implementation information item</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-languages">
  <title><literal>sql_languages</literal></title>

  <para>
   The table <literal>sql_languages</literal> contains one row for
   each SQL language binding that is supported by
   <productname>PostgreSQL</productname>.
   <productname>PostgreSQL</productname> supports direct SQL and
   embedded SQL in C; that is all you will learn from this table.
  </para>

  <table>
   <title><literal>sql_languages</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sql_language_source</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The name of the source of the language definition; always
       <literal>ISO 9075</literal>, that is, the SQL standard
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_year</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The year the standard referenced in
       <literal>sql_language_source</literal> was approved; currently
       <literal>1999</>
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_comformance</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The standard conformance level for the language binding.  For
       ISO 9075:1999 this is always <literal>CORE</literal>.
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_integrity</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null (This value is relevant to an earlier version of the SQL standard.)</entry>
     </row>

     <row>
      <entry><literal>sql_language_implementation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null</entry>
     </row>

     <row>
      <entry><literal>sql_language_binding_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The language binding style, either <literal>DIRECT</literal> or
       <literal>EMBEDDED</literal>
      </entry>
     </row>

     <row>
      <entry><literal>sql_language_programming_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The programming language, if the binding style is
       <literal>EMBEDDED</literal>, else null.  PostgreSQL only
       supports the language C.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-packages">
  <title><literal>sql_packages</literal></title>

  <para>
   The table <literal>sql_packages</literal> contains information
   about which features packages defined in the SQL standard are
   supported by <productname>PostgreSQL</productname>.  Refer to <xref
   linkend="features"> for background information on feature packages.
  </para>

  <table>
   <title><literal>sql_packages</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Identifier string of the package</entry>
     </row>

     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the package</entry>
     </row>

     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>YES</literal> if the package is fully supported by the
       current version of PostgreSQL, <literal>NO</literal> if not
      </entry>
     </row>

     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Always null, since the PostgreSQL development group does not
       perform formal testing of feature conformance
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Possibly a comment about the supported status of the package</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing">
  <title><literal>sql_sizing</literal></title>

  <para>
   The table <literal>sql_sizing</literal> contains information about
   various size limits and maximum values in
   <productname>PostgreSQL</productname>.  This information is
   primarily intended for use in the context of the ODBC interface;
   users of other interfaces will probably find this information to be
   of little use.  For this reason, the individual sizing items are
   not described here; you will find them in the description of the
   ODBC interface.
  </para>

  <table>
   <title><literal>sql_sizing</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Identifier of the sizing item</entry>
     </row>

     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the sizing item</entry>
     </row>

     <row>
      <entry><literal>supported_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Value of the sizing item, or 0 if the size is unlimited or
       cannot be determined, or null if the features for which the
       sizing item is applicable are not supported
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Possibly a comment pertaining to the sizing item</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing-profiles">
  <title><literal>sql_sizing_profiles</literal></title>

  <para>
   The table <literal>sql_sizing_profiles</literal> contains
   information about the <literal>sql_sizing</literal> values that are
   required by various profiles of the SQL standard.  PostgreSQL does
   not track any SQL profiles, so this table is empty.
  </para>

  <table>
   <title><literal>sql_sizing_profiles</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Identifier of the sizing item</entry>
     </row>

     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the sizing item</entry>
     </row>

     <row>
      <entry><literal>profile_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Identifier string of a profile</entry>
     </row>

     <row>
      <entry><literal>required_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       The value required by the SQL profile for the sizing item, or 0
       if the profile places no limit on the sizing item, or null if
       the profile does not require any of the features for which the
       sizing item is applicable
      </entry>
     </row>

     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Possibly a comment pertaining to the sizing item within the profile</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-constraints">
  <title><literal>table_constraints</literal></title>

  <para>
   The view <literal>table_constraints</literal> contains all
   constraints belonging to tables owned by the current user.
  </para>

  <table>
   <title><literal>table_constraints</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the constraint (always the current database)</entry>
     </row>

     <row>
      <entry><literal>constraint_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the constraint</entry>
     </row>

     <row>
      <entry><literal>constraint_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the constraint</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the table (always the current database)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>

     <row>
      <entry><literal>constraint_type</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type of the constraint: <literal>CHECK</literal>,
       <literal>FOREIGN KEY</literal>, <literal>PRIMARY KEY</literal>,
       or <literal>UNIQUE</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> if the constraint is deferrable, <literal>NO</literal> if not</entry>
     </row>

     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> if the constraint is deferrable and initially deferred, <literal>NO</literal> if not</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-privileges">
  <title><literal>table_privileges</literal></title>

  <para>
   The view <literal>table_privileges</literal> identifies all
   privileges granted on tables or views to the current user or by the
   current user.  There is one row for each combination of table,
   grantor, and grantee.  Privileges granted to groups are identified
   in the view <literal>role_table_grants</literal>.
  </para>

  <table>
   <title><literal>table_privileges</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the user that granted the privilege</entry>
     </row>

     <row>
      <entry><literal>grantee</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the user or group that the privilege was granted to</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the table (always the current database)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type of the privilege: <literal>SELECT</literal>,
       <literal>DELETE</literal>, <literal>INSERT</literal>,
       <literal>UPDATE</literal>, <literal>REFERENCES</literal>,
       <literal>RULE</literal>, or <literal>TRIGGER</literal>
      </entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>

     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Note that the column <literal>grantee</literal> makes no
   distinction between users and groups.  If you have users and groups
   with the same name, there is unfortunately no way to distinguish
   them.  A future version of <productname>PostgreSQL</productname>
   will possibly prohibit having users and groups with the same name.
  </para>
 </sect1>

 <sect1 id="infoschema-tables">
  <title><literal>tables</literal></title>

  <para>
   The view <literal>tables</literal> contains all tables and views
   defined in the current database.  Only those tables and views are
   shown that the current user has access to (by way of being the
   owner or having some privilege).
  </para>

  <table>
   <title><literal>tables</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the table (always the current database)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table</entry>
     </row>

     <row>
      <entry><literal>table_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>

     <row>
      <entry><literal>table_type</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type of the table: <literal>BASE TABLE</literal> for a
       persistent base table (the normal table type),
       <literal>VIEW</literal> for a view, or <literal>LOCAL
       TEMPORARY</literal> for a temporary table
      </entry>
     </row>

     <row>
      <entry><literal>self_referencing_column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>reference_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggers">
  <title><literal>triggers</literal></title>

  <para>
   The view <literal>triggers</literal> contains all triggers defined
   in the current database that are owned by the current user.  (The
   owner of the table is the owner of the trigger.)
  </para>

  <table>
   <title><literal>triggers</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the trigger (always the current database)</entry>
     </row>

     <row>
      <entry><literal>trigger_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the trigger</entry>
     </row>

     <row>
      <entry><literal>trigger_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the trigger</entry>
     </row>

     <row>
      <entry><literal>event_manipulation</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       Event that fires the trigger (<literal>INSERT</literal>,
       <literal>UPDATE</literal>, or <literal>DELETE</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that the trigger
       is defined on (always the current database)
      </entry>
     </row>

     <row>
      <entry><literal>event_object_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table that the trigger is defined on</entry>
     </row>

     <row>
      <entry><literal>event_object_table</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table that the trigger is defined on</entry>
     </row>

     <row>
      <entry><literal>action_order</literal</entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Not yet implemented</entry>
     </row>

     <row>
      <entry><literal>action_condition</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>action_statement</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       Statement that is executed by the trigger (currently always
       <literal>EXECUTE PROCEDURE
       <replaceable>function</replaceable>(...)</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>action_orientation</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       Identifies whether the trigger fires once for each processed
       row or once for each statement (<literal>ROW</literal> or
       <literal>STATEMENT</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>condition_timing</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       Time at which the trigger fires (<literal>BEFORE</literal> or
       <literal>AFTER</literal>)
      </entry>
     </row>

     <row>
      <entry><literal>condition_reference_old_table</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>condition_reference_new_table</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Triggers in <productname>PostgreSQL</productname> have two
   incompatibilities with the SQL standard that affect the
   representation in the information schema.  First, trigger names are
   local to the table in <productname>PostgreSQL</productname>, rather
   than independent schema objects.  Therefore there may be duplicate
   trigger names defined in one schema, as long as they belong to
   different tables.  (<literal>trigger_catalog</literal> and
   <literal>trigger_schema</literal> are really the values pertaining
   to the table that the trigger is defined on.)  Second, triggers can
   be defined to fire on multiple events in
   <productname>PostgreSQL</productname> (e.g., <literal>ON INSERT OR
   UPDATE</literal>), whereas the SQL standard only allows one.  If a
   trigger is defined to fire on multiple events, it is represented as
   multiple rows in the information schema, one for each type of
   event.  As a consequence of these two issues, the primary key of
   the view <literal>triggers</literal> is really
   <literal>(trigger_catalog, trigger_schema, trigger_name,
   event_object_table, event_manipulation)</literal> instead of
   <literal>(trigger_catalog, trigger_schema, trigger_name)</literal>,
   which is what the SQL standard specifies.  Nonetheless, if you
   define your triggers in a manner that conforms with the SQL
   standard (trigger names unique in the schema and only one event
   type per trigger), this will not affect you.
  </para>
 </sect1>

 <sect1 id="infoschema-usage-privileges">
  <title><literal>usage_privileges</literal></title>

  <para>
   The view <literal>usage_privileges</literal> is meant to identify
   <literal>USAGE</literal> privileges granted on various kinds of
   objects to the current user or by the current user.  In
   <productname>PostgreSQL</productname>, this currently only applies
   to domains, and since domains do not have real privileges in
   <productname>PostgreSQL</productname>, this view shows implicit
   <literal>USAGE</literal> privileges granted to
   <literal>PUBLIC</literal> for all domains.  In the future, this
   view may contain more useful information.
  </para>

  <table>
   <title><literal>usage_privileges</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Currently set to the name of the owner of the object</entry>
     </row>

     <row>
      <entry><literal>grantee</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Currently always <literal>PUBLIC</literal></entry>
     </row>

     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the object (always the current database)</entry>
     </row>

     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the object</entry>
     </row>

     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the object</entry>
     </row>

     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Currently always <literal>DOMAIN</literal></entry>
     </row>

     <row>
      <entry><literal>privilege_type</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>Always <literal>USAGE</literal></entry>
     </row>

     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Currently always <literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-column-usage">
  <title><literal>view_column_usage</literal></title>

  <para>
   The view <literal>view_column_usage</literal> identifies all
   columns that are used in the query expression of a view (the
   <command>SELECT</command> statement that defines the view).  A
   column is only included if the current user is the owner of the
   table that contains the column.
  </para>

  <note>
   <para>
    Columns of system tables are not included.  This should be fixed
    sometime.
   </para>
  </note>

  <table>
   <title><literal>view_column_usage</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the view (always the current database)</entry>
     </row>

     <row>
      <entry><literal>view_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the view</entry>
     </row>

     <row>
      <entry><literal>view_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the view</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that contains the
       column that is used by the view (always the current database)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that contains the table that contains the
       column that is used by the view
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the table that contains the column that is used by the
       view
      </entry>
     </row>

     <row>
      <entry><literal>column_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column that is used by the view</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-table-usage">
  <title><literal>view_table_usage</literal></title>

  <para>
   The view <literal>view_table_usage</literal> identifies all tables
   that are used in the query expression of a view (the
   <command>SELECT</command> statement that defines the view).  A
   table is only included if the current user is the owner of that
   table.
  </para>

  <note>
   <para>
    System tables are not included.  This should be fixed sometime.
   </para>
  </note>

  <table>
   <title><literal>view_table_usage</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the view (always the current database)</entry>
     </row>

     <row>
      <entry><literal>view_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the view</entry>
     </row>

     <row>
      <entry><literal>view_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the view</entry>
     </row>

     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that is
       used by the view (always the current database)
      </entry>
     </row>

     <row>
      <entry><literal>table_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that contains the table that is used by the
       view
      </entry>
     </row>

     <row>
      <entry><literal>table_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the table that is used by the view
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-views">
  <title><literal>views</literal></title>

  <para>
   The view <literal>views</literal> contains all views defined in the
   current database.  Only those views are shown that the current user
   has access to (by way of being the owner or having some privilege).
  </para>

  <table>
   <title><literal>views</literal> Columns</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the view (always the current database)</entry>
     </row>

     <row>
      <entry><literal>table_schema</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the view</entry>
     </row>

     <row>
      <entry><literal>table_name</literal</entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the view</entry>
     </row>

     <row>
      <entry><literal>view definition</literal</entry>
      <entry><type>character_data</type></entry>
      <entry>
       Query expression defining the view (null if the current user is
       not the owner of the view)
      </entry>
     </row>

     <row>
      <entry><literal>check_option</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in PostgreSQL</entry>
     </row>

     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Not yet implemented</entry>
     </row>

     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Not yet implemented</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

</chapter>
