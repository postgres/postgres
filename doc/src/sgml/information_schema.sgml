<!-- doc/src/sgml/information_schema.sgml -->

<chapter id="information-schema">
 <title>The Information Schema</title>

 <indexterm zone="information-schema">
  <primary>information schema</primary>
 </indexterm>

 <para>
  The information schema consists of a set of views that contain
  information about the objects defined in the current database.  The
  information schema is defined in the SQL standard and can therefore
  be expected to be portable and remain stable &mdash; unlike the system
  catalogs, which are specific to
  <productname>PostgreSQL</productname> and are modeled after
  implementation concerns.  The information schema views do not,
  however, contain information about
  <productname>PostgreSQL</productname>-specific features; to inquire
  about those you need to query the system catalogs or other
  <productname>PostgreSQL</productname>-specific views.
 </para>

 <note>
  <para>
   When querying the database for constraint information, it is possible
   for a standard-compliant query that expects to return one row to
   return several.  This is because the SQL standard requires constraint
   names to be unique within a schema, but
   <productname>PostgreSQL</productname> does not enforce this
   restriction.  <productname>PostgreSQL</productname>
   automatically-generated constraint names avoid duplicates in the
   same schema, but users can specify such duplicate names.
  </para>

  <para>
   This problem can appear when querying information schema views such
   as <literal>check_constraint_routine_usage</literal>,
   <literal>check_constraints</literal>, <literal>domain_constraints</literal>, and
   <literal>referential_constraints</literal>.  Some other views have similar
   issues but contain the table name to help distinguish duplicate
   rows, e.g., <literal>constraint_column_usage</literal>,
   <literal>constraint_table_usage</literal>, <literal>table_constraints</literal>.
  </para>
 </note>


 <sect1 id="infoschema-schema">
  <title>The Schema</title>

  <para>
   The information schema itself is a schema named
   <literal>information_schema</literal>.  This schema automatically
   exists in all databases.  The owner of this schema is the initial
   database user in the cluster, and that user naturally has all the
   privileges on this schema, including the ability to drop it (but
   the space savings achieved by that are minuscule).
  </para>

  <para>
   By default, the information schema is not in the schema search
   path, so you need to access all objects in it through qualified
   names.  Since the names of some of the objects in the information
   schema are generic names that might occur in user applications, you
   should be careful if you want to put the information schema in the
   path.
  </para>
 </sect1>

 <sect1 id="infoschema-datatypes">
  <title>Data Types</title>

  <para>
   The columns of the information schema views use special data types
   that are defined in the information schema.  These are defined as
   simple domains over ordinary built-in types.  You should not use
   these types for work outside the information schema, but your
   applications must be prepared for them if they select from the
   information schema.
  </para>

  <para>
   These types are:

   <variablelist>
    <varlistentry>
     <term><type>cardinal_number</type></term>
     <listitem>
      <para>
       A nonnegative integer.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>character_data</type></term>
     <listitem>
      <para>
       A character string (without specific maximum length).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>sql_identifier</type></term>
     <listitem>
      <para>
       A character string.  This type is used for SQL identifiers, the
       type <type>character_data</type> is used for any other kind of
       text data.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>time_stamp</type></term>
     <listitem>
      <para>
       A domain over the type <type>timestamp with time zone</type>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>yes_or_no</type></term>
     <listitem>
      <para>
       A character string domain that contains
       either <literal>YES</literal> or <literal>NO</literal>.  This
       is used to represent Boolean (true/false) data in the
       information schema.  (The information schema was invented
       before the type <type>boolean</type> was added to the SQL
       standard, so this convention is necessary to keep the
       information schema backward compatible.)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Every column in the information schema has one of these five types.
  </para>
 </sect1>

 <sect1 id="infoschema-information-schema-catalog-name">
  <title><literal>information_schema_catalog_name</literal></title>

  <para>
   <literal>information_schema_catalog_name</literal> is a table that
   always contains one row and one column containing the name of the
   current database (current catalog, in SQL terminology).
  </para>

  <table>
   <title><structname>information_schema_catalog_name</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>catalog_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains this information schema
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-administrable-role-authorizations">
  <title><literal>administrable_role_&zwsp;authorizations</literal></title>

  <para>
   The view <literal>administrable_role_authorizations</literal>
   identifies all roles that the current user has the admin option
   for.
  </para>

  <table>
   <title><structname>administrable_role_authorizations</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantee</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role to which this role membership was granted (can
       be the current user, or a different role in case of nested role
       memberships)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>role_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of a role
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_grantable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Always <literal>YES</literal>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-applicable-roles">
  <title><literal>applicable_roles</literal></title>

  <para>
   The view <literal>applicable_roles</literal> identifies all roles
   whose privileges the current user can use.  This means there is
   some chain of role grants from the current user to the role in
   question.  The current user itself is also an applicable role.  The
   set of applicable roles is generally used for permission checking.
   <indexterm><primary>applicable role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>applicable</secondary></indexterm>
  </para>

  <table>
   <title><structname>applicable_roles</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantee</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role to which this role membership was granted (can
       be the current user, or a different role in case of nested role
       memberships)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>role_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of a role
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_grantable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the grantee has the admin option on
       the role, <literal>NO</literal> if not
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-attributes">
  <title><literal>attributes</literal></title>

  <para>
   The view <literal>attributes</literal> contains information about
   the attributes of composite data types defined in the database.
   (Note that the view does not give information about table columns,
   which are sometimes called attributes in PostgreSQL contexts.)
   Only those attributes are shown that the current user has access to (by way
   of being the owner of or having some privilege on the type).
  </para>

  <table>
   <title><structname>attributes</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the data type (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the data type
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the data type
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>attribute_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the attribute
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ordinal_position</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Ordinal position of the attribute within the data type (count starts at 1)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>attribute_default</structfield> <type>character_data</type>
      </para>
      <para>
       Default expression of the attribute
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_nullable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the attribute is possibly nullable,
       <literal>NO</literal> if it is known not nullable.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>data_type</structfield> <type>character_data</type>
      </para>
      <para>
       Data type of the attribute, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>attribute_udt_name</literal> and
       associated columns).
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies a character or bit
       string type, the declared maximum length; null for all other
       data types or if no maximum length was declared.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_octet_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies a character type,
       the maximum possible length in octets (bytes) of a datum; null
       for all other data types.  The maximum octet length depends on
       the declared character maximum length (see above) and the
       server encoding.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the collation of the attribute
       (always the current database), null if default or the data type
       of the attribute is not collatable
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the collation of the attribute,
       null if default or the data type of the attribute is not
       collatable
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the collation of the attribute, null if default or the
       data type of the attribute is not collatable
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies a numeric type, this
       column contains the (declared or implicit) precision of the
       type for this attribute.  The precision indicates the number of
       significant digits.  It can be expressed in decimal (base 10)
       or binary (base 2) terms, as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies a numeric type, this
       column indicates in which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.  For all other data types, this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_scale</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies an exact numeric
       type, this column contains the (declared or implicit) scale of
       the type for this attribute.  The scale indicates the number of
       significant digits to the right of the decimal point.  It can
       be expressed in decimal (base 10) or binary (base 2) terms, as
       specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datetime_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies a date, time,
       timestamp, or interval type, this column contains the (declared
       or implicit) fractional seconds precision of the type for this
       attribute, that is, the number of decimal digits maintained
       following the decimal point in the seconds value.  For all
       other data types, this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_type</structfield> <type>character_data</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies an interval type,
       this column contains the specification which fields the
       intervals include for this attribute, e.g., <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc.  If no
       field restrictions were specified (that is, the interval
       accepts all fields), and for all other data types, this field
       is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available
       in <productname>PostgreSQL</productname>
       (see <literal>datetime_precision</literal> for the fractional
       seconds precision of interval type attributes)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>attribute_udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the attribute data type is defined in
       (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>attribute_udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that the attribute data type is defined in
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>attribute_udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the attribute data type
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>maximum_cardinality</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       An identifier of the data type descriptor of the column, unique
       among the data type descriptors pertaining to the table.  This
       is mainly useful for joining with other instances of such
       identifiers.  (The specific format of the identifier is not
       defined and not guaranteed to remain the same in future
       versions.)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_derived_reference_attribute</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   See also under <xref linkend="infoschema-columns"/>, a similarly
   structured view, for further information on some of the columns.
  </para>
 </sect1>

 <sect1 id="infoschema-character-sets">
  <title><literal>character_sets</literal></title>

  <para>
   The view <literal>character_sets</literal> identifies the character
   sets available in the current database.  Since PostgreSQL does not
   support multiple character sets within one database, this view only
   shows one, which is the database encoding.
  </para>

  <para>
   Take note of how the following terms are used in the SQL standard:
   <variablelist>
    <varlistentry>
     <term>character repertoire</term>
     <listitem>
      <para>
       An abstract collection of characters, for
       example <literal>UNICODE</literal>, <literal>UCS</literal>, or
       <literal>LATIN1</literal>.  Not exposed as an SQL object, but
       visible in this view.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>character encoding form</term>
     <listitem>
      <para>
       An encoding of some character repertoire.  Most older character
       repertoires only use one encoding form, and so there are no
       separate names for them (e.g., <literal>LATIN1</literal> is an
       encoding form applicable to the <literal>LATIN1</literal>
       repertoire).  But for example Unicode has the encoding forms
       <literal>UTF8</literal>, <literal>UTF16</literal>, etc. (not
       all supported by PostgreSQL).  Encoding forms are not exposed
       as an SQL object, but are visible in this view.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>character set</term>
     <listitem>
      <para>
       A named SQL object that identifies a character repertoire, a
       character encoding, and a default collation.  A predefined
       character set would typically have the same name as an encoding
       form, but users could define other names.  For example, the
       character set <literal>UTF8</literal> would typically identify
       the character repertoire <literal>UCS</literal>, encoding
       form <literal>UTF8</literal>, and some default collation.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   You can think of an <quote>encoding</quote> in PostgreSQL either as
   a character set or a character encoding form.  They will have the
   same name, and there can only be one in one database.
  </para>

  <table>
   <title><structname>character_sets</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Character sets are currently not implemented as schema objects, so this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Character sets are currently not implemented as schema objects, so this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the character set, currently implemented as showing the name of the database encoding
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_repertoire</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Character repertoire, showing <literal>UCS</literal> if the encoding is <literal>UTF8</literal>, else just the encoding name
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>form_of_use</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Character encoding form, same as the database encoding
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>default_collate_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the default collation (always the current database, if any collation is identified)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>default_collate_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the default collation
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>default_collate_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the default collation.  The default collation is
       identified as the collation that matches
       the <literal>COLLATE</literal> and <literal>CTYPE</literal>
       settings of the current database.  If there is no such
       collation, then this column and the associated schema and
       catalog columns are null.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraint-routine-usage">
  <title><literal>check_constraint_routine_usage</literal></title>

  <para>
   The view <literal>check_constraint_routine_usage</literal>
   identifies routines (functions and procedures) that are used by a
   check constraint.  Only those routines are shown that are owned by
   a currently enabled role.
  </para>

  <table>
   <title><structname>check_constraint_routine_usage</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the constraint (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The <quote>specific name</quote> of the function.  See <xref linkend="infoschema-routines"/> for more information.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraints">
  <title><literal>check_constraints</literal></title>

  <para>
   The view <literal>check_constraints</literal> contains all check
   constraints, either defined on a table or on a domain, that are
   owned by a currently enabled role.  (The owner of the table or
   domain is the owner of the constraint.)
  </para>

  <table>
   <title><structname>check_constraints</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the constraint (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>check_clause</structfield> <type>character_data</type>
      </para>
      <para>
       The check expression of the check constraint
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-collations">
  <title><literal>collations</literal></title>

  <para>
   The view <literal>collations</literal> contains the collations
   available in the current database.
  </para>

  <table>
   <title><structname>collations</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the collation (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the collation
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the default collation
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pad_attribute</structfield> <type>character_data</type>
      </para>
      <para>
       Always <literal>NO PAD</literal> (The alternative <literal>PAD
       SPACE</literal> is not supported by PostgreSQL.)
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-collation-character-set-applicab"> <!-- max 44 characters -->
  <title><literal>collation_character_set_&zwsp;applicability</literal></title>

  <para>
   The view <literal>collation_character_set_applicability</literal>
   identifies which character set the available collations are
   applicable to.  In PostgreSQL, there is only one character set per
   database (see explanation
   in <xref linkend="infoschema-character-sets"/>), so this view does
   not provide much useful information.
  </para>

  <table>
   <title><structname>collation_character_set_applicability</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the collation (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the collation
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the default collation
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Character sets are currently not implemented as schema objects, so this column is null
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Character sets are currently not implemented as schema objects, so this column is null
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the character set
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-column-usage">
  <title><literal>column_column_usage</literal></title>

  <para>
   The view <literal>column_column_usage</literal> identifies all generated
   columns that depend on another base column in the same table.  Only tables
   owned by a currently enabled role are included.
  </para>

  <table>
   <title><structname>column_column_usage</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the table (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the base column that a generated column depends on
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dependent_column</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the generated column
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-domain-usage">
  <title><literal>column_domain_usage</literal></title>

  <para>
   The view <literal>column_domain_usage</literal> identifies all
   columns (of a table or a view) that make use of some domain defined
   in the current database and owned by a currently enabled role.
  </para>

  <table>
   <title><structname>column_domain_usage</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the domain (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the domain
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the domain
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the table (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-options">
  <title><literal>column_options</literal></title>

  <para>
   The view <literal>column_options</literal> contains all the
   options defined for foreign table columns in the current database.  Only
   those foreign table columns are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>

  <table>
   <title><structname>column_options</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the foreign table (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the foreign table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the foreign table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>option_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of an option
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>option_value</structfield> <type>character_data</type>
      </para>
      <para>
       Value of the option
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-privileges">
  <title><literal>column_privileges</literal></title>

  <para>
   The view <literal>column_privileges</literal> identifies all
   privileges granted on columns to a currently enabled role or by a
   currently enabled role.  There is one row for each combination of
   column, grantor, and grantee.
  </para>

  <para>
   If a privilege has been granted on an entire table, it will show up in
   this view as a grant for each column, but only for the
   privilege types where column granularity is possible:
   <literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal>, <literal>REFERENCES</literal>.
  </para>

  <table>
   <title><structname>column_privileges</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantor</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that granted the privilege
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantee</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that the privilege was granted to
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table that contains the column (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table that contains the column
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table that contains the column
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>privilege_type</structfield> <type>character_data</type>
      </para>
      <para>
       Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>, or
       <literal>REFERENCES</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_grantable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-udt-usage">
  <title><literal>column_udt_usage</literal></title>

  <para>
   The view <literal>column_udt_usage</literal> identifies all columns
   that use data types owned by a currently enabled role.  Note that in
   <productname>PostgreSQL</productname>, built-in data types behave
   like user-defined types, so they are included here as well.  See
   also <xref linkend="infoschema-columns"/> for details.
  </para>

  <table>
   <title><structname>column_udt_usage</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the column data type (the underlying
       type of the domain, if applicable) is defined in (always the
       current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that the column data type (the underlying
       type of the domain, if applicable) is defined in
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column data type (the underlying type of the
       domain, if applicable)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the table (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-columns">
  <title><literal>columns</literal></title>

  <para>
   The view <literal>columns</literal> contains information about all
   table columns (or view columns) in the database.  System columns
   (<literal>ctid</literal>, etc.) are not included.  Only those columns are
   shown that the current user has access to (by way of being the
   owner or having some privilege).
  </para>

  <table>
   <title><structname>columns</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the table (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ordinal_position</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Ordinal position of the column within the table (count starts at 1)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_default</structfield> <type>character_data</type>
      </para>
      <para>
       Default expression of the column
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_nullable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the column is possibly nullable,
       <literal>NO</literal> if it is known not nullable.  A not-null
       constraint is one way a column can be known not nullable, but
       there can be others.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>data_type</structfield> <type>character_data</type>
      </para>
      <para>
       Data type of the column, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).  If the column is based on a domain, this column
       refers to the type underlying the domain (and the domain is
       identified in <literal>domain_name</literal> and associated
       columns).
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies a character or bit
       string type, the declared maximum length; null for all other
       data types or if no maximum length was declared.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_octet_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies a character type,
       the maximum possible length in octets (bytes) of a datum; null
       for all other data types.  The maximum octet length depends on
       the declared character maximum length (see above) and the
       server encoding.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies a numeric type, this
       column contains the (declared or implicit) precision of the
       type for this column.  The precision indicates the number of
       significant digits.  It can be expressed in decimal (base 10)
       or binary (base 2) terms, as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies a numeric type, this
       column indicates in which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.  For all other data types, this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_scale</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies an exact numeric
       type, this column contains the (declared or implicit) scale of
       the type for this column.  The scale indicates the number of
       significant digits to the right of the decimal point.  It can
       be expressed in decimal (base 10) or binary (base 2) terms, as
       specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datetime_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies a date, time,
       timestamp, or interval type, this column contains the (declared
       or implicit) fractional seconds precision of the type for this
       column, that is, the number of decimal digits maintained
       following the decimal point in the seconds value.  For all
       other data types, this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_type</structfield> <type>character_data</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies an interval type,
       this column contains the specification which fields the
       intervals include for this column, e.g., <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc.  If no
       field restrictions were specified (that is, the interval
       accepts all fields), and for all other data types, this field
       is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available
       in <productname>PostgreSQL</productname>
       (see <literal>datetime_precision</literal> for the fractional
       seconds precision of interval type columns)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the collation of the column
       (always the current database), null if default or the data type
       of the column is not collatable
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the collation of the column, null
       if default or the data type of the column is not collatable
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the collation of the column, null if default or the
       data type of the column is not collatable
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       If the column has a domain type, the name of the database that
       the domain is defined in (always the current database), else
       null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       If the column has a domain type, the name of the schema that
       the domain is defined in, else null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       If the column has a domain type, the name of the domain, else null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the column data type (the underlying
       type of the domain, if applicable) is defined in (always the
       current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that the column data type (the underlying
       type of the domain, if applicable) is defined in
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column data type (the underlying type of the
       domain, if applicable)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>maximum_cardinality</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       An identifier of the data type descriptor of the column, unique
       among the data type descriptors pertaining to the table.  This
       is mainly useful for joining with other instances of such
       identifiers.  (The specific format of the identifier is not
       defined and not guaranteed to remain the same in future
       versions.)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_self_referencing</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_identity</structfield> <type>yes_or_no</type>
      </para>
      <para>
       If the column is an identity column, then <literal>YES</literal>,
       else <literal>NO</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>identity_generation</structfield> <type>character_data</type>
      </para>
      <para>
       If the column is an identity column, then <literal>ALWAYS</literal>
       or <literal>BY DEFAULT</literal>, reflecting the definition of the
       column.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>identity_start</structfield> <type>character_data</type>
      </para>
      <para>
       If the column is an identity column, then the start value of the
       internal sequence, else null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>identity_increment</structfield> <type>character_data</type>
      </para>
      <para>
       If the column is an identity column, then the increment of the internal
       sequence, else null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>identity_maximum</structfield> <type>character_data</type>
      </para>
      <para>
       If the column is an identity column, then the maximum value of the
       internal sequence, else null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>identity_minimum</structfield> <type>character_data</type>
      </para>
      <para>
       If the column is an identity column, then the minimum value of the
       internal sequence, else null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>identity_cycle</structfield> <type>yes_or_no</type>
      </para>
      <para>
       If the column is an identity column, then <literal>YES</literal> if the
       internal sequence cycles or <literal>NO</literal> if it does not;
       otherwise null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_generated</structfield> <type>character_data</type>
      </para>
      <para>
       If the column is a generated column, then <literal>ALWAYS</literal>,
       else <literal>NEVER</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>generation_expression</structfield> <type>character_data</type>
      </para>
      <para>
       If the column is a generated column, then the generation expression,
       else null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_updatable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the column is updatable,
       <literal>NO</literal> if not (Columns in base tables are always
       updatable, columns in views not necessarily)
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Since data types can be defined in a variety of ways in SQL, and
   <productname>PostgreSQL</productname> contains additional ways to
   define data types, their representation in the information schema
   can be somewhat difficult.  The column <literal>data_type</literal>
   is supposed to identify the underlying built-in type of the column.
   In <productname>PostgreSQL</productname>, this means that the type
   is defined in the system catalog schema
   <literal>pg_catalog</literal>.  This column might be useful if the
   application can handle the well-known built-in types specially (for
   example, format the numeric types differently or use the data in
   the precision columns).  The columns <literal>udt_name</literal>,
   <literal>udt_schema</literal>, and <literal>udt_catalog</literal>
   always identify the underlying data type of the column, even if the
   column is based on a domain.  (Since
   <productname>PostgreSQL</productname> treats built-in types like
   user-defined types, built-in types appear here as well.  This is an
   extension of the SQL standard.)  These columns should be used if an
   application wants to process data differently according to the
   type, because in that case it wouldn't matter if the column is
   really based on a domain.  If the column is based on a domain, the
   identity of the domain is stored in the columns
   <literal>domain_name</literal>, <literal>domain_schema</literal>,
   and <literal>domain_catalog</literal>.  If you want to pair up
   columns with their associated data types and treat domains as
   separate types, you could write <literal>coalesce(domain_name,
   udt_name)</literal>, etc.
  </para>
 </sect1>

 <sect1 id="infoschema-constraint-column-usage">
  <title><literal>constraint_column_usage</literal></title>

  <para>
   The view <literal>constraint_column_usage</literal> identifies all
   columns in the current database that are used by some constraint.
   Only those columns are shown that are contained in a table owned by
   a currently enabled role.  For a check constraint, this view
   identifies the columns that are used in the check expression.  For
   a foreign key constraint, this view identifies the columns that the
   foreign key references.  For a unique or primary key constraint,
   this view identifies the constrained columns.
  </para>

  <table>
   <title><structname>constraint_column_usage</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table that contains the
       column that is used by some constraint (always the current
       database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table that contains the
       column that is used by some constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table that contains the column that is used by some
       constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column that is used by some constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the constraint (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the constraint
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-constraint-table-usage">
  <title><literal>constraint_table_usage</literal></title>

  <para>
   The view <literal>constraint_table_usage</literal> identifies all
   tables in the current database that are used by some constraint and
   are owned by a currently enabled role.  (This is different from the
   view <literal>table_constraints</literal>, which identifies all
   table constraints along with the table they are defined on.)  For a
   foreign key constraint, this view identifies the table that the
   foreign key references.  For a unique or primary key constraint,
   this view simply identifies the table the constraint belongs to.
   Check constraints and not-null constraints are not included in this
   view.
  </para>

  <table>
   <title><structname>constraint_table_usage</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table that is used by
       some constraint (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table that is used by some
       constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table that is used by some constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the constraint (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the constraint
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-data-type-privileges">
  <title><literal>data_type_privileges</literal></title>

  <para>
   The view <literal>data_type_privileges</literal> identifies all
   data type descriptors that the current user has access to, by way
   of being the owner of the described object or having some privilege
   for it.  A data type descriptor is generated whenever a data type
   is used in the definition of a table column, a domain, or a
   function (as parameter or return type) and stores some information
   about how the data type is used in that instance (for example, the
   declared maximum length, if applicable).  Each data type
   descriptor is assigned an arbitrary identifier that is unique
   among the data type descriptor identifiers assigned for one object
   (table, domain, function).  This view is probably not useful for
   applications, but it is used to define some other views in the
   information schema.
  </para>

  <table>
   <title><structname>data_type_privileges</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the described object (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the described object
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the described object
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_type</structfield> <type>character_data</type>
      </para>
      <para>
       The type of the described object: one of
       <literal>TABLE</literal> (the data type descriptor pertains to
       a column of that table), <literal>DOMAIN</literal> (the data
       type descriptors pertains to that domain),
       <literal>ROUTINE</literal> (the data type descriptor pertains
       to a parameter or the return data type of that function).
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The identifier of the data type descriptor, which is unique
       among the data type descriptors for that same object.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-constraints">
  <title><literal>domain_constraints</literal></title>

  <para>
   The view <literal>domain_constraints</literal> contains all constraints
   belonging to domains defined in the current database.  Only those domains
   are shown that the current user has access to (by way of being the owner or
   having some privilege).
  </para>

  <table>
   <title><structname>domain_constraints</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the constraint (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the domain (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the domain
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the domain
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_deferrable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the constraint is deferrable, <literal>NO</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>initially_deferred</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the constraint is deferrable and initially deferred, <literal>NO</literal> if not
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-udt-usage">
  <title><literal>domain_udt_usage</literal></title>

  <para>
   The view <literal>domain_udt_usage</literal> identifies all domains
   that are based on data types owned by a currently enabled role.
   Note that in <productname>PostgreSQL</productname>, built-in data
   types behave like user-defined types, so they are included here as
   well.
  </para>

  <table>
   <title><structname>domain_udt_usage</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the domain data type is defined in (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that the domain data type is defined in
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the domain data type
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the domain (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the domain
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the domain
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domains">
  <title><literal>domains</literal></title>

  <para>
   The view <literal>domains</literal> contains all domains defined in the
   current database.  Only those domains are shown that the current user has
   access to (by way of being the owner or having some privilege).
  </para>

  <table>
   <title><structname>domains</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the domain (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the domain
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the domain
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>data_type</structfield> <type>character_data</type>
      </para>
      <para>
       Data type of the domain, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If the domain has a character or bit string type, the declared
       maximum length; null for all other data types or if no maximum
       length was declared.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_octet_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If the domain has a character type, the maximum possible length
       in octets (bytes) of a datum; null for all other data types.
       The maximum octet length depends on the declared character
       maximum length (see above) and the server encoding.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the collation of the domain
       (always the current database), null if default or the data type
       of the domain is not collatable
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the collation of the domain, null
       if default or the data type of the domain is not collatable
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the collation of the domain, null if default or the
       data type of the domain is not collatable
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If the domain has a numeric type, this column contains the
       (declared or implicit) precision of the type for this domain.
       The precision indicates the number of significant digits.  It
       can be expressed in decimal (base 10) or binary (base 2) terms,
       as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If the domain has a numeric type, this column indicates in
       which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.  For all other data types, this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_scale</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If the domain has an exact numeric type, this column contains
       the (declared or implicit) scale of the type for this domain.
       The scale indicates the number of significant digits to the
       right of the decimal point.  It can be expressed in decimal
       (base 10) or binary (base 2) terms, as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datetime_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies a date, time,
       timestamp, or interval type, this column contains the (declared
       or implicit) fractional seconds precision of the type for this
       domain, that is, the number of decimal digits maintained
       following the decimal point in the seconds value.  For all
       other data types, this column is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_type</structfield> <type>character_data</type>
      </para>
      <para>
       If <literal>data_type</literal> identifies an interval type,
       this column contains the specification which fields the
       intervals include for this domain, e.g., <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc.  If no
       field restrictions were specified (that is, the interval
       accepts all fields), and for all other data types, this field
       is null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available
       in <productname>PostgreSQL</productname>
       (see <literal>datetime_precision</literal> for the fractional
       seconds precision of interval type domains)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_default</structfield> <type>character_data</type>
      </para>
      <para>
       Default expression of the domain
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the domain data type is defined in (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that the domain data type is defined in
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the domain data type
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>maximum_cardinality</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       An identifier of the data type descriptor of the domain, unique
       among the data type descriptors pertaining to the domain (which
       is trivial, because a domain only contains one data type
       descriptor).  This is mainly useful for joining with other
       instances of such identifiers.  (The specific format of the
       identifier is not defined and not guaranteed to remain the same
       in future versions.)
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-element-types">
  <title><literal>element_types</literal></title>

  <para>
   The view <literal>element_types</literal> contains the data type
   descriptors of the elements of arrays.  When a table column, composite-type attribute,
   domain, function parameter, or function return value is defined to
   be of an array type, the respective information schema view only
   contains <literal>ARRAY</literal> in the column
   <literal>data_type</literal>.  To obtain information on the element
   type of the array, you can join the respective view with this view.
   For example, to show the columns of a table with data types and
   array element types, if applicable, you could do:
<programlisting>
SELECT c.column_name, c.data_type, e.data_type AS element_type
FROM information_schema.columns c LEFT JOIN information_schema.element_types e
     ON ((c.table_catalog, c.table_schema, c.table_name, 'TABLE', c.dtd_identifier)
       = (e.object_catalog, e.object_schema, e.object_name, e.object_type, e.collection_type_identifier))
WHERE c.table_schema = '...' AND c.table_name = '...'
ORDER BY c.ordinal_position;
</programlisting>
   This view only includes objects that the current user has access
   to, by way of being the owner or having some privilege.
  </para>

  <table>
   <title><structname>element_types</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the object that uses the
       array being described (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the object that uses the array
       being described
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the object that uses the array being described
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_type</structfield> <type>character_data</type>
      </para>
      <para>
       The type of the object that uses the array being described: one
       of <literal>TABLE</literal> (the array is used by a column of
       that table), <literal>USER-DEFINED TYPE</literal> (the array is
       used by an attribute of that composite type),
       <literal>DOMAIN</literal> (the array is used by that domain),
       <literal>ROUTINE</literal> (the array is used by a parameter or
       the return data type of that function).
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collection_type_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The identifier of the data type descriptor of the array being
       described.  Use this to join with the
       <literal>dtd_identifier</literal> columns of other information
       schema views.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>data_type</structfield> <type>character_data</type>
      </para>
      <para>
       Data type of the array elements, if it is a built-in type, else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_octet_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the collation of the element
       type (always the current database), null if default or the data
       type of the element is not collatable
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the collation of the element
       type, null if default or the data type of the element is not
       collatable
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the collation of the element type, null if default or
       the data type of the element is not collatable
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_scale</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datetime_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_type</structfield> <type>character_data</type>
      </para>
      <para>
       Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>domain_default</structfield> <type>character_data</type>
      </para>
      <para>
       Not yet implemented
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the data type of the elements is
       defined in (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that the data type of the elements is
       defined in
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the data type of the elements
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>maximum_cardinality</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       An identifier of the data type descriptor of the element.  This
       is currently not useful.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-enabled-roles">
  <title><literal>enabled_roles</literal></title>

  <para>
   The view <literal>enabled_roles</literal> identifies the currently
   <quote>enabled roles</quote>.  The enabled roles are recursively
   defined as the current user together with all roles that have been
   granted to the enabled roles with automatic inheritance.  In other
   words, these are all roles that the current user has direct or
   indirect, automatically inheriting membership in.
   <indexterm><primary>enabled role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>enabled</secondary></indexterm>
  </para>

  <para>
   For permission checking, the set of <quote>applicable roles</quote>
   is applied, which can be broader than the set of enabled roles.  So
   generally, it is better to use the view
   <literal>applicable_roles</literal> instead of this one; See
   <xref linkend="infoschema-applicable-roles"/> for details on
   <literal>applicable_roles</literal> view.
  </para>

  <table>
   <title><structname>enabled_roles</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>role_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of a role
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrapper-options">
  <title><literal>foreign_data_wrapper_options</literal></title>

  <para>
   The view <literal>foreign_data_wrapper_options</literal> contains
   all the options defined for foreign-data wrappers in the current
   database.  Only those foreign-data wrappers are shown that the
   current user has access to (by way of being the owner or having
   some privilege).
  </para>

  <table>
   <title><structname>foreign_data_wrapper_options</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_data_wrapper_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the foreign-data wrapper is defined in (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_data_wrapper_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the foreign-data wrapper
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>option_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of an option
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>option_value</structfield> <type>character_data</type>
      </para>
      <para>
       Value of the option
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrappers">
  <title><literal>foreign_data_wrappers</literal></title>

  <para>
   The view <literal>foreign_data_wrappers</literal> contains all
   foreign-data wrappers defined in the current database.  Only those
   foreign-data wrappers are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>

  <table>
   <title><structname>foreign_data_wrappers</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_data_wrapper_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the foreign-data
       wrapper (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_data_wrapper_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the foreign-data wrapper
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>authorization_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the owner of the foreign server
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>library_name</structfield> <type>character_data</type>
      </para>
      <para>
       File name of the library that implementing this foreign-data wrapper
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_data_wrapper_language</structfield> <type>character_data</type>
      </para>
      <para>
       Language used to implement this foreign-data wrapper
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-server-options">
  <title><literal>foreign_server_options</literal></title>

  <para>
   The view <literal>foreign_server_options</literal> contains all the
   options defined for foreign servers in the current database.  Only
   those foreign servers are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>

  <table>
   <title><structname>foreign_server_options</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_server_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the foreign server is defined in (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_server_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the foreign server
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>option_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of an option
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>option_value</structfield> <type>character_data</type>
      </para>
      <para>
       Value of the option
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-servers">
  <title><literal>foreign_servers</literal></title>

  <para>
   The view <literal>foreign_servers</literal> contains all foreign
   servers defined in the current database.  Only those foreign
   servers are shown that the current user has access to (by way of
   being the owner or having some privilege).
  </para>

  <table>
   <title><structname>foreign_servers</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_server_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the foreign server is defined in (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_server_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the foreign server
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_data_wrapper_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the foreign-data
       wrapper used by the foreign server (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_data_wrapper_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the foreign-data wrapper used by the foreign server
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_server_type</structfield> <type>character_data</type>
      </para>
      <para>
       Foreign server type information, if specified upon creation
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_server_version</structfield> <type>character_data</type>
      </para>
      <para>
       Foreign server version information, if specified upon creation
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>authorization_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the owner of the foreign server
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-table-options">
  <title><literal>foreign_table_options</literal></title>

  <para>
   The view <literal>foreign_table_options</literal> contains all the
   options defined for foreign tables in the current database.  Only
   those foreign tables are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>

  <table>
   <title><structname>foreign_table_options</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the foreign table (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the foreign table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the foreign table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>option_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of an option
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>option_value</structfield> <type>character_data</type>
      </para>
      <para>
       Value of the option
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-tables">
  <title><literal>foreign_tables</literal></title>

  <para>
   The view <literal>foreign_tables</literal> contains all foreign
   tables defined in the current database.  Only those foreign
   tables are shown that the current user has access to (by way of
   being the owner or having some privilege).
  </para>

  <table>
   <title><structname>foreign_tables</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the foreign table is defined in (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the foreign table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the foreign table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_server_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the foreign server is defined in (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_server_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the foreign server
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-key-column-usage">
  <title><literal>key_column_usage</literal></title>

  <para>
   The view <literal>key_column_usage</literal> identifies all columns
   in the current database that are restricted by some unique, primary
   key, or foreign key constraint.  Check constraints are not included
   in this view.  Only those columns are shown that the current user
   has access to, by way of being the owner or having some privilege.
  </para>

  <table>
   <title><structname>key_column_usage</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the constraint (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table that contains the
       column that is restricted by this constraint (always the
       current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table that contains the
       column that is restricted by this constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table that contains the column that is restricted
       by this constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column that is restricted by this constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ordinal_position</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Ordinal position of the column within the constraint key (count
       starts at 1)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>position_in_unique_constraint</structfield> <type>cardinal_number</type>
      </para>
      <para>
       For a foreign-key constraint, ordinal position of the referenced
       column within its unique constraint (count starts at 1);
       otherwise null
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-parameters">
  <title><literal>parameters</literal></title>

  <para>
   The view <literal>parameters</literal> contains information about
   the parameters (arguments) of all functions in the current database.
   Only those functions are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>

  <table>
   <title><structname>parameters</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The <quote>specific name</quote> of the function.  See <xref linkend="infoschema-routines"/> for more information.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ordinal_position</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Ordinal position of the parameter in the argument list of the
       function (count starts at 1)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>parameter_mode</structfield> <type>character_data</type>
      </para>
      <para>
       <literal>IN</literal> for input parameter,
       <literal>OUT</literal> for output parameter,
       and <literal>INOUT</literal> for input/output parameter.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_result</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>as_locator</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>parameter_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the parameter, or null if the parameter has no name
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>data_type</structfield> <type>character_data</type>
      </para>
      <para>
       Data type of the parameter, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_octet_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_scale</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datetime_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_type</structfield> <type>character_data</type>
      </para>
      <para>
       Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the data type of the parameter is
       defined in (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that the data type of the parameter is
       defined in
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the data type of the parameter
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>maximum_cardinality</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       An identifier of the data type descriptor of the parameter,
       unique among the data type descriptors pertaining to the
       function.  This is mainly useful for joining with other
       instances of such identifiers.  (The specific format of the
       identifier is not defined and not guaranteed to remain the same
       in future versions.)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>parameter_default</structfield> <type>character_data</type>
      </para>
      <para>
       The default expression of the parameter, or null if none or if the
       function is not owned by a currently enabled role.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-referential-constraints">
  <title><literal>referential_constraints</literal></title>

  <para>
   The view <literal>referential_constraints</literal> contains all
   referential (foreign key) constraints in the current database.
   Only those constraints are shown for which the current user has
   write access to the referencing table (by way of being the
   owner or having some privilege other than <literal>SELECT</literal>).
  </para>

  <table>
   <title><structname>referential_constraints</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the constraint (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>unique_constraint_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the unique or primary key
       constraint that the foreign key constraint references (always
       the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>unique_constraint_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the unique or primary key
       constraint that the foreign key constraint references
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>unique_constraint_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the unique or primary key constraint that the foreign
       key constraint references
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>match_option</structfield> <type>character_data</type>
      </para>
      <para>
       Match option of the foreign key constraint:
       <literal>FULL</literal>, <literal>PARTIAL</literal>, or
       <literal>NONE</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>update_rule</structfield> <type>character_data</type>
      </para>
      <para>
       Update rule of the foreign key constraint:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal>, or
       <literal>NO ACTION</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>delete_rule</structfield> <type>character_data</type>
      </para>
      <para>
       Delete rule of the foreign key constraint:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal>, or
       <literal>NO ACTION</literal>.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-role-column-grants">
  <title><literal>role_column_grants</literal></title>

  <para>
   The view <literal>role_column_grants</literal> identifies all
   privileges granted on columns where the grantor or grantee is a
   currently enabled role.  Further information can be found under
   <literal>column_privileges</literal>.  The only effective
   difference between this view
   and <literal>column_privileges</literal> is that this view omits
   columns that have been made accessible to the current user by way
   of a grant to <literal>PUBLIC</literal>.
  </para>

  <table>
   <title><structname>role_column_grants</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantor</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that granted the privilege
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantee</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that the privilege was granted to
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table that contains the column (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table that contains the column
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table that contains the column
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>privilege_type</structfield> <type>character_data</type>
      </para>
      <para>
       Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>, or
       <literal>REFERENCES</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_grantable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-routine-grants">
  <title><literal>role_routine_grants</literal></title>

  <para>
   The view <literal>role_routine_grants</literal> identifies all
   privileges granted on functions where the grantor or grantee is a
   currently enabled role.  Further information can be found under
   <literal>routine_privileges</literal>.  The only effective
   difference between this view
   and <literal>routine_privileges</literal> is that this view omits
   functions that have been made accessible to the current user by way
   of a grant to <literal>PUBLIC</literal>.
  </para>

  <table>
   <title><structname>role_routine_grants</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantor</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that granted the privilege
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantee</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that the privilege was granted to
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The <quote>specific name</quote> of the function.  See <xref linkend="infoschema-routines"/> for more information.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the function (might be duplicated in case of overloading)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>privilege_type</structfield> <type>character_data</type>
      </para>
      <para>
       Always <literal>EXECUTE</literal> (the only privilege type for functions)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_grantable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-table-grants">
  <title><literal>role_table_grants</literal></title>

  <para>
   The view <literal>role_table_grants</literal> identifies all
   privileges granted on tables or views where the grantor or grantee
   is a currently enabled role.  Further information can be found
   under <literal>table_privileges</literal>.  The only effective
   difference between this view
   and <literal>table_privileges</literal> is that this view omits
   tables that have been made accessible to the current user by way of
   a grant to <literal>PUBLIC</literal>.
  </para>

  <table>
   <title><structname>role_table_grants</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantor</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that granted the privilege
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantee</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that the privilege was granted to
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>privilege_type</structfield> <type>character_data</type>
      </para>
      <para>
       Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       <literal>REFERENCES</literal>, or <literal>TRIGGER</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_grantable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>with_hierarchy</structfield> <type>yes_or_no</type>
      </para>
      <para>
       In the SQL standard, <literal>WITH HIERARCHY OPTION</literal>
       is a separate (sub-)privilege allowing certain operations on
       table inheritance hierarchies.  In PostgreSQL, this is included
       in the <literal>SELECT</literal> privilege, so this column
       shows <literal>YES</literal> if the privilege
       is <literal>SELECT</literal>, else <literal>NO</literal>.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-udt-grants">
  <title><literal>role_udt_grants</literal></title>

  <para>
   The view <literal>role_udt_grants</literal> is intended to identify
   <literal>USAGE</literal> privileges granted on user-defined types
   where the grantor or grantee is a currently enabled role.  Further
   information can be found under
   <literal>udt_privileges</literal>.  The only effective difference
   between this view and <literal>udt_privileges</literal> is that
   this view omits objects that have been made accessible to the
   current user by way of a grant to <literal>PUBLIC</literal>.  Since
   data types do not have real privileges in PostgreSQL, but only an
   implicit grant to <literal>PUBLIC</literal>, this view is empty.
  </para>

  <table>
   <title><structname>role_udt_grants</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantor</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The name of the role that granted the privilege
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantee</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The name of the role that the privilege was granted to
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the type (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the type
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the type
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>privilege_type</structfield> <type>character_data</type>
      </para>
      <para>
       Always <literal>TYPE USAGE</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_grantable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-usage-grants">
  <title><literal>role_usage_grants</literal></title>

  <para>
   The view <literal>role_usage_grants</literal> identifies
   <literal>USAGE</literal> privileges granted on various kinds of
   objects where the grantor or grantee is a currently enabled role.
   Further information can be found under
   <literal>usage_privileges</literal>.  The only effective difference
   between this view and <literal>usage_privileges</literal> is that
   this view omits objects that have been made accessible to the
   current user by way of a grant to <literal>PUBLIC</literal>.
  </para>

  <table>
   <title><structname>role_usage_grants</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantor</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The name of the role that granted the privilege
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantee</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The name of the role that the privilege was granted to
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the object (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the object, if applicable,
       else an empty string
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the object
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_type</structfield> <type>character_data</type>
      </para>
      <para>
       <literal>COLLATION</literal> or <literal>DOMAIN</literal> or <literal>FOREIGN DATA WRAPPER</literal> or <literal>FOREIGN SERVER</literal> or <literal>SEQUENCE</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>privilege_type</structfield> <type>character_data</type>
      </para>
      <para>
       Always <literal>USAGE</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_grantable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-column-usage">
  <title><literal>routine_column_usage</literal></title>

  <para>
   The view <literal>routine_column_usage</literal> is meant to identify all
   columns that are used by a function or procedure.  This information is
   currently not tracked by <productname>PostgreSQL</productname>.
  </para>

  <table>
   <title><literal>routine_column_usage</literal> Columns</title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The <quote>specific name</quote> of the function.  See <xref linkend="infoschema-routines"/> for more information.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the function (might be duplicated in case of overloading)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table that is used by the
       function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table that is used by the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table that is used by the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column that is used by the function
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-privileges">
  <title><literal>routine_privileges</literal></title>

  <para>
   The view <literal>routine_privileges</literal> identifies all
   privileges granted on functions to a currently enabled role or by a
   currently enabled role.  There is one row for each combination of function,
   grantor, and grantee.
  </para>

  <table>
   <title><structname>routine_privileges</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantor</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that granted the privilege
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantee</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that the privilege was granted to
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The <quote>specific name</quote> of the function.  See <xref linkend="infoschema-routines"/> for more information.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the function (might be duplicated in case of overloading)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>privilege_type</structfield> <type>character_data</type>
      </para>
      <para>
       Always <literal>EXECUTE</literal> (the only privilege type for functions)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_grantable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-routine-usage">
  <title><literal>routine_routine_usage</literal></title>

  <para>
   The view <literal>routine_routine_usage</literal> is meant to identify all
   functions or procedures that are used by another (or the same) function or
   procedure, either in the body or in parameter default expressions.
   Currently, only functions used in parameter default expressions are
   tracked.  An entry is included here only if the used function is owned by a
   currently enabled role.  (There is no such restriction on the using
   function.)
  </para>

  <para>
   Note that the entries for both functions in the view refer to the
   <quote>specific</quote> name of the routine, even though the column names
   are used in a way that is inconsistent with other information schema views
   about routines.  This is per SQL standard, although it is arguably a
   misdesign.  See <xref linkend="infoschema-routines"/> for more information
   about specific names.
  </para>

  <table>
   <title><literal>routine_routine_usage</literal> Columns</title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the using function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the using function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The <quote>specific name</quote> of the using function.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the function that is used by the
       first function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the function that is used by the first
       function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The <quote>specific name</quote> of the function that is used by the
       first function.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-sequence-usage">
  <title><literal>routine_sequence_usage</literal></title>

  <para>
   The view <literal>routine_sequence_usage</literal> is meant to identify all
   sequences that are used by a function or procedure, either in the body or
   in parameter default expressions.  Currently, only sequences used in
   parameter default expressions are tracked.  A sequence is only included if
   that sequence is owned by a currently enabled role.
  </para>

  <table>
   <title><literal>routine_sequence_usage</literal> Columns</title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The <quote>specific name</quote> of the function.  See <xref linkend="infoschema-routines"/> for more information.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the function (might be duplicated in case of overloading)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schema_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the sequence that is used by the
       function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sequence_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the sequence that is used by the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sequence_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the sequence that is used by the function
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-table-usage">
  <title><literal>routine_table_usage</literal></title>

  <para>
   The view <literal>routine_table_usage</literal> is meant to identify all
   tables that are used by a function or procedure.  This information is
   currently not tracked by <productname>PostgreSQL</productname>.
  </para>

  <table>
   <title><literal>routine_table_usage</literal> Columns</title>

   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The <quote>specific name</quote> of the function.  See <xref linkend="infoschema-routines"/> for more information.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the function (might be duplicated in case of overloading)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table that is used by the
       function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table that is used by the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table that is used by the function
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routines">
  <title><literal>routines</literal></title>

  <para>
   The view <literal>routines</literal> contains all functions and procedures in the
   current database.  Only those functions and procedures are shown that the current
   user has access to (by way of being the owner or having some
   privilege).
  </para>

  <table>
   <title><structname>routines</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The <quote>specific name</quote> of the function.  This is a
       name that uniquely identifies the function in the schema, even
       if the real name of the function is overloaded.  The format of
       the specific name is not defined, it should only be used to
       compare it to other instances of specific routine names.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the function (might be duplicated in case of overloading)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_type</structfield> <type>character_data</type>
      </para>
      <para>
       <literal>FUNCTION</literal> for a
       function, <literal>PROCEDURE</literal> for a procedure
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>module_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>module_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>module_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>data_type</structfield> <type>character_data</type>
      </para>
      <para>
       Return data type of the function, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>type_udt_name</literal> and associated
       columns).  Null for a procedure.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_octet_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_scale</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datetime_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_type</structfield> <type>character_data</type>
      </para>
      <para>
       Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>type_udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the return data type of the function
       is defined in (always the current database).  Null for a procedure.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>type_udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that the return data type of the function is
       defined in.  Null for a procedure.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>type_udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the return data type of the function.  Null for a procedure.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>scope_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>maximum_cardinality</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dtd_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       An identifier of the data type descriptor of the return data
       type of this function, unique among the data type descriptors
       pertaining to the function.  This is mainly useful for joining
       with other instances of such identifiers.  (The specific format
       of the identifier is not defined and not guaranteed to remain
       the same in future versions.)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_body</structfield> <type>character_data</type>
      </para>
      <para>
       If the function is an SQL function, then
       <literal>SQL</literal>, else <literal>EXTERNAL</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>routine_definition</structfield> <type>character_data</type>
      </para>
      <para>
       The source text of the function (null if the function is not
       owned by a currently enabled role).  (According to the SQL
       standard, this column is only applicable if
       <literal>routine_body</literal> is <literal>SQL</literal>, but
       in <productname>PostgreSQL</productname> it will contain
       whatever source text was specified when the function was
       created.)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>external_name</structfield> <type>character_data</type>
      </para>
      <para>
       If this function is a C function, then the external name (link
       symbol) of the function; else null.  (This works out to be the
       same value that is shown in
       <literal>routine_definition</literal>.)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>external_language</structfield> <type>character_data</type>
      </para>
      <para>
       The language the function is written in
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>parameter_style</structfield> <type>character_data</type>
      </para>
      <para>
       Always <literal>GENERAL</literal> (The SQL standard defines
       other parameter styles, which are not available in <productname>PostgreSQL</productname>.)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_deterministic</structfield> <type>yes_or_no</type>
      </para>
      <para>
       If the function is declared immutable (called deterministic in
       the SQL standard), then <literal>YES</literal>, else
       <literal>NO</literal>.  (You cannot query the other volatility
       levels available in <productname>PostgreSQL</productname> through the information schema.)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sql_data_access</structfield> <type>character_data</type>
      </para>
      <para>
       Always <literal>MODIFIES</literal>, meaning that the function
       possibly modifies SQL data.  This information is not useful for
       <productname>PostgreSQL</productname>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_null_call</structfield> <type>yes_or_no</type>
      </para>
      <para>
       If the function automatically returns null if any of its
       arguments are null, then <literal>YES</literal>, else
       <literal>NO</literal>.  Null for a procedure.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sql_path</structfield> <type>character_data</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schema_level_routine</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Always <literal>YES</literal> (The opposite would be a method
       of a user-defined type, which is a feature not available in
       <productname>PostgreSQL</productname>.)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>max_dynamic_result_sets</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_user_defined_cast</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_implicitly_invocable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>security_type</structfield> <type>character_data</type>
      </para>
      <para>
       If the function runs with the privileges of the current user,
       then <literal>INVOKER</literal>, if the function runs with the
       privileges of the user who defined it, then
       <literal>DEFINER</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>to_sql_specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>to_sql_specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>to_sql_specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>as_locator</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>created</structfield> <type>time_stamp</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_altered</structfield> <type>time_stamp</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>new_savepoint_level</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_udt_dependent</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Currently always <literal>NO</literal>.  The alternative
       <literal>YES</literal> applies to a feature not available in
       <productname>PostgreSQL</productname>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_from_data_type</structfield> <type>character_data</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_as_locator</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_char_max_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_char_octet_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_char_set_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_char_set_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_char_set_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_collation_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_collation_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_collation_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_numeric_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_numeric_precision_radix</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_numeric_scale</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_datetime_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_interval_type</structfield> <type>character_data</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_interval_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_type_udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_type_udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_type_udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_scope_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_scope_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_scope_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_maximum_cardinality</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>result_cast_dtd_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-schemata">
  <title><literal>schemata</literal></title>

  <para>
   The view <literal>schemata</literal> contains all schemas in the current
   database that the current user has access to (by way of being the owner or
   having some privilege).
  </para>

  <table>
   <title><structname>schemata</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>catalog_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the schema is contained in (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schema_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schema_owner</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the owner of the schema
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>default_character_set_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>default_character_set_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>default_character_set_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sql_path</structfield> <type>character_data</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sequences">
  <title><literal>sequences</literal></title>

  <para>
   The view <literal>sequences</literal> contains all sequences
   defined in the current database.  Only those sequences are shown
   that the current user has access to (by way of being the owner or
   having some privilege).
  </para>

  <table>
   <title><structname>sequences</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sequence_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the sequence (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sequence_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the sequence
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sequence_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the sequence
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>data_type</structfield> <type>character_data</type>
      </para>
      <para>
       The data type of the sequence.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       This column contains the (declared or implicit) precision of
       the sequence data type (see above).  The precision indicates
       the number of significant digits.  It can be expressed in
       decimal (base 10) or binary (base 2) terms, as specified in the
       column <literal>numeric_precision_radix</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
      </para>
      <para>
       This column indicates in which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_scale</structfield> <type>cardinal_number</type>
      </para>
      <para>
       This column contains the (declared or implicit) scale of the
       sequence data type (see above).  The scale indicates the number
       of significant digits to the right of the decimal point.  It
       can be expressed in decimal (base 10) or binary (base 2) terms,
       as specified in the column
       <literal>numeric_precision_radix</literal>.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>start_value</structfield> <type>character_data</type>
      </para>
      <para>
       The start value of the sequence
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>minimum_value</structfield> <type>character_data</type>
      </para>
      <para>
       The minimum value of the sequence
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>maximum_value</structfield> <type>character_data</type>
      </para>
      <para>
       The maximum value of the sequence
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>increment</structfield> <type>character_data</type>
      </para>
      <para>
       The increment of the sequence
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>cycle_option</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the sequence cycles, else <literal>NO</literal>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Note that in accordance with the SQL standard, the start, minimum,
   maximum, and increment values are returned as character strings.
  </para>
 </sect1>

 <sect1 id="infoschema-sql-features">
  <title><literal>sql_features</literal></title>

  <para>
   The table <literal>sql_features</literal> contains information
   about which formal features defined in the SQL standard are
   supported by <productname>PostgreSQL</productname>.  This is the
   same information that is presented in <xref linkend="features"/>.
   There you can also find some additional background information.
  </para>

  <table>
   <title><structname>sql_features</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>feature_id</structfield> <type>character_data</type>
      </para>
      <para>
       Identifier string of the feature
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>feature_name</structfield> <type>character_data</type>
      </para>
      <para>
       Descriptive name of the feature
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sub_feature_id</structfield> <type>character_data</type>
      </para>
      <para>
       Identifier string of the subfeature, or a zero-length string if not a subfeature
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sub_feature_name</structfield> <type>character_data</type>
      </para>
      <para>
       Descriptive name of the subfeature, or a zero-length string if not a subfeature
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_supported</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the feature is fully supported by the
       current version of <productname>PostgreSQL</productname>, <literal>NO</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_verified_by</structfield> <type>character_data</type>
      </para>
      <para>
       Always null, since the <productname>PostgreSQL</productname> development group does not
       perform formal testing of feature conformance
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>comments</structfield> <type>character_data</type>
      </para>
      <para>
       Possibly a comment about the supported status of the feature
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-implementation-info">
  <title><literal>sql_implementation_info</literal></title>

  <para>
   The table <literal>sql_implementation_info</literal> contains
   information about various aspects that are left
   implementation-defined by the SQL standard.  This information is
   primarily intended for use in the context of the ODBC interface;
   users of other interfaces will probably find this information to be
   of little use.  For this reason, the individual implementation
   information items are not described here; you will find them in the
   description of the ODBC interface.
  </para>

  <table>
   <title><structname>sql_implementation_info</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>implementation_info_id</structfield> <type>character_data</type>
      </para>
      <para>
       Identifier string of the implementation information item
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>implementation_info_name</structfield> <type>character_data</type>
      </para>
      <para>
       Descriptive name of the implementation information item
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>integer_value</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Value of the implementation information item, or null if the
       value is contained in the column
       <literal>character_value</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_value</structfield> <type>character_data</type>
      </para>
      <para>
       Value of the implementation information item, or null if the
       value is contained in the column
       <literal>integer_value</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>comments</structfield> <type>character_data</type>
      </para>
      <para>
       Possibly a comment pertaining to the implementation information item
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-parts">
  <title><literal>sql_parts</literal></title>

  <para>
   The table <literal>sql_parts</literal> contains information about
   which of the several parts of the SQL standard are supported by
   <productname>PostgreSQL</productname>.
  </para>

  <table>
   <title><structname>sql_parts</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>feature_id</structfield> <type>character_data</type>
      </para>
      <para>
       An identifier string containing the number of the part
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>feature_name</structfield> <type>character_data</type>
      </para>
      <para>
       Descriptive name of the part
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_supported</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the part is fully supported by the
       current version of <productname>PostgreSQL</productname>,
       <literal>NO</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_verified_by</structfield> <type>character_data</type>
      </para>
      <para>
       Always null, since the <productname>PostgreSQL</productname> development group does not
       perform formal testing of feature conformance
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>comments</structfield> <type>character_data</type>
      </para>
      <para>
       Possibly a comment about the supported status of the part
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing">
  <title><literal>sql_sizing</literal></title>

  <para>
   The table <literal>sql_sizing</literal> contains information about
   various size limits and maximum values in
   <productname>PostgreSQL</productname>.  This information is
   primarily intended for use in the context of the ODBC interface;
   users of other interfaces will probably find this information to be
   of little use.  For this reason, the individual sizing items are
   not described here; you will find them in the description of the
   ODBC interface.
  </para>

  <table>
   <title><structname>sql_sizing</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sizing_id</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Identifier of the sizing item
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sizing_name</structfield> <type>character_data</type>
      </para>
      <para>
       Descriptive name of the sizing item
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>supported_value</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Value of the sizing item, or 0 if the size is unlimited or
       cannot be determined, or null if the features for which the
       sizing item is applicable are not supported
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>comments</structfield> <type>character_data</type>
      </para>
      <para>
       Possibly a comment pertaining to the sizing item
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-constraints">
  <title><literal>table_constraints</literal></title>

  <para>
   The view <literal>table_constraints</literal> contains all
   constraints belonging to tables that the current user owns or has
   some privilege other than <literal>SELECT</literal> on.
  </para>

  <table>
   <title><structname>table_constraints</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the constraint (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the constraint
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>constraint_type</structfield> <type>character_data</type>
      </para>
      <para>
       Type of the constraint: <literal>CHECK</literal>,
       <literal>FOREIGN KEY</literal>, <literal>PRIMARY KEY</literal>,
       or <literal>UNIQUE</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_deferrable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the constraint is deferrable, <literal>NO</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>initially_deferred</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the constraint is deferrable and initially deferred, <literal>NO</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>enforced</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Applies to a feature not available in
       <productname>PostgreSQL</productname> (currently always
       <literal>YES</literal>)
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-privileges">
  <title><literal>table_privileges</literal></title>

  <para>
   The view <literal>table_privileges</literal> identifies all
   privileges granted on tables or views to a currently enabled role
   or by a currently enabled role.  There is one row for each
   combination of table, grantor, and grantee.
  </para>

  <table>
   <title><structname>table_privileges</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantor</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that granted the privilege
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantee</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that the privilege was granted to
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>privilege_type</structfield> <type>character_data</type>
      </para>
      <para>
       Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       <literal>REFERENCES</literal>, or <literal>TRIGGER</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_grantable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>with_hierarchy</structfield> <type>yes_or_no</type>
      </para>
      <para>
       In the SQL standard, <literal>WITH HIERARCHY OPTION</literal>
       is a separate (sub-)privilege allowing certain operations on
       table inheritance hierarchies.  In PostgreSQL, this is included
       in the <literal>SELECT</literal> privilege, so this column
       shows <literal>YES</literal> if the privilege
       is <literal>SELECT</literal>, else <literal>NO</literal>.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-tables">
  <title><literal>tables</literal></title>

  <para>
   The view <literal>tables</literal> contains all tables and views
   defined in the current database.  Only those tables and views are
   shown that the current user has access to (by way of being the
   owner or having some privilege).
  </para>

  <table>
   <title><structname>tables</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_type</structfield> <type>character_data</type>
      </para>
      <para>
       Type of the table: <literal>BASE TABLE</literal> for a
       persistent base table (the normal table type),
       <literal>VIEW</literal> for a view, <literal>FOREIGN</literal>
       for a foreign table, or
       <literal>LOCAL TEMPORARY</literal> for a temporary table
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>self_referencing_column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>reference_generation</structfield> <type>character_data</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>user_defined_type_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       If the table is a typed table, the name of the database that
       contains the underlying data type (always the current
       database), else null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>user_defined_type_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       If the table is a typed table, the name of the schema that
       contains the underlying data type, else null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>user_defined_type_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       If the table is a typed table, the name of the underlying data
       type, else null.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_insertable_into</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the table is insertable into,
       <literal>NO</literal> if not (Base tables are always insertable
       into, views not necessarily.)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_typed</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the table is a typed table, <literal>NO</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>commit_action</structfield> <type>character_data</type>
      </para>
      <para>
       Not yet implemented
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-transforms">
  <title><literal>transforms</literal></title>

  <para>
   The view <literal>transforms</literal> contains information about the
   transforms defined in the current database.  More precisely, it contains a
   row for each function contained in a transform (the <quote>from SQL</quote>
   or <quote>to SQL</quote> function).
  </para>

  <table>
   <title><structname>transforms</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the type the transform is for (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the type the transform is for
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the type the transform is for
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The <quote>specific name</quote> of the function.  See <xref linkend="infoschema-routines"/> for more information.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>group_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The SQL standard allows defining transforms in <quote>groups</quote>,
       and selecting a group at run time.  PostgreSQL does not support this.
       Instead, transforms are specific to a language.  As a compromise, this
       field contains the language the transform is for.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>transform_type</structfield> <type>character_data</type>
      </para>
      <para>
       <literal>FROM SQL</literal> or <literal>TO SQL</literal>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggered-update-columns">
  <title><literal>triggered_update_columns</literal></title>

  <para>
   For triggers in the current database that specify a column list
   (like <literal>UPDATE OF column1, column2</literal>), the
   view <literal>triggered_update_columns</literal> identifies these
   columns.  Triggers that do not specify a column list are not
   included in this view.  Only those columns are shown that the
   current user owns or has some privilege other than
   <literal>SELECT</literal> on.
  </para>

  <table>
   <title><structname>triggered_update_columns</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>trigger_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the trigger (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>trigger_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the trigger
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>trigger_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the trigger
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>event_object_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table that the trigger
       is defined on (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>event_object_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table that the trigger is defined on
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>event_object_table</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table that the trigger is defined on
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>event_object_column</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column that the trigger is defined on
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggers">
  <title><literal>triggers</literal></title>

  <para>
   The view <literal>triggers</literal> contains all triggers defined
   in the current database on tables and views that the current user owns
   or has some privilege other than <literal>SELECT</literal> on.
  </para>

  <table>
   <title><structname>triggers</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>trigger_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the trigger (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>trigger_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the trigger
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>trigger_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the trigger
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>event_manipulation</structfield> <type>character_data</type>
      </para>
      <para>
       Event that fires the trigger (<literal>INSERT</literal>,
       <literal>UPDATE</literal>, or <literal>DELETE</literal>)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>event_object_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table that the trigger
       is defined on (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>event_object_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table that the trigger is defined on
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>event_object_table</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table that the trigger is defined on
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>action_order</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Firing order among triggers on the same table having the same
       <literal>event_manipulation</literal>,
       <literal>action_timing</literal>, and
       <literal>action_orientation</literal>.  In
       <productname>PostgreSQL</productname>, triggers are fired in name
       order, so this column reflects that.
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>action_condition</structfield> <type>character_data</type>
      </para>
      <para>
       <literal>WHEN</literal> condition of the trigger, null if none
       (also null if the table is not owned by a currently enabled
       role)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>action_statement</structfield> <type>character_data</type>
      </para>
      <para>
       Statement that is executed by the trigger (currently always
       <literal>EXECUTE FUNCTION
       <replaceable>function</replaceable>(...)</literal>)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>action_orientation</structfield> <type>character_data</type>
      </para>
      <para>
       Identifies whether the trigger fires once for each processed
       row or once for each statement (<literal>ROW</literal> or
       <literal>STATEMENT</literal>)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>action_timing</structfield> <type>character_data</type>
      </para>
      <para>
       Time at which the trigger fires (<literal>BEFORE</literal>,
       <literal>AFTER</literal>, or <literal>INSTEAD OF</literal>)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>action_reference_old_table</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the <quote>old</quote> transition table, or null if none
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>action_reference_new_table</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the <quote>new</quote> transition table, or null if none
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>action_reference_old_row</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>action_reference_new_row</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>created</structfield> <type>time_stamp</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   Triggers in <productname>PostgreSQL</productname> have two
   incompatibilities with the SQL standard that affect the
   representation in the information schema.  First, trigger names are
   local to each table in <productname>PostgreSQL</productname>, rather
   than being independent schema objects.  Therefore there can be duplicate
   trigger names defined in one schema, so long as they belong to
   different tables.  (<literal>trigger_catalog</literal> and
   <literal>trigger_schema</literal> are really the values pertaining
   to the table that the trigger is defined on.)  Second, triggers can
   be defined to fire on multiple events in
   <productname>PostgreSQL</productname> (e.g., <literal>ON INSERT OR
   UPDATE</literal>), whereas the SQL standard only allows one.  If a
   trigger is defined to fire on multiple events, it is represented as
   multiple rows in the information schema, one for each type of
   event.  As a consequence of these two issues, the primary key of
   the view <literal>triggers</literal> is really
   <literal>(trigger_catalog, trigger_schema, event_object_table,
   trigger_name, event_manipulation)</literal> instead of
   <literal>(trigger_catalog, trigger_schema, trigger_name)</literal>,
   which is what the SQL standard specifies.  Nonetheless, if you
   define your triggers in a manner that conforms with the SQL
   standard (trigger names unique in the schema and only one event
   type per trigger), this will not affect you.
  </para>

  <note>
   <para>
    Prior to <productname>PostgreSQL</productname> 9.1, this view's columns
    <structfield>action_timing</structfield>,
    <structfield>action_reference_old_table</structfield>,
    <structfield>action_reference_new_table</structfield>,
    <structfield>action_reference_old_row</structfield>, and
    <structfield>action_reference_new_row</structfield>
    were named
    <structfield>condition_timing</structfield>,
    <structfield>condition_reference_old_table</structfield>,
    <structfield>condition_reference_new_table</structfield>,
    <structfield>condition_reference_old_row</structfield>, and
    <structfield>condition_reference_new_row</structfield>
    respectively.
    That was how they were named in the SQL:1999 standard.
    The new naming conforms to SQL:2003 and later.
   </para>
  </note>
 </sect1>

 <sect1 id="infoschema-udt-privileges">
  <title><literal>udt_privileges</literal></title>

  <para>
   The view <literal>udt_privileges</literal> identifies
   <literal>USAGE</literal> privileges granted on user-defined types to a
   currently enabled role or by a currently enabled role.  There is one row for
   each combination of type, grantor, and grantee.  This view shows only
   composite types (see under <xref linkend="infoschema-user-defined-types"/>
   for why); see
   <xref linkend="infoschema-usage-privileges"/> for domain privileges.
  </para>

  <table>
   <title><structname>udt_privileges</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantor</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that granted the privilege
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantee</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that the privilege was granted to
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the type (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the type
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>udt_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the type
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>privilege_type</structfield> <type>character_data</type>
      </para>
      <para>
       Always <literal>TYPE USAGE</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_grantable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-usage-privileges">
  <title><literal>usage_privileges</literal></title>

  <para>
   The view <literal>usage_privileges</literal> identifies
   <literal>USAGE</literal> privileges granted on various kinds of
   objects to a currently enabled role or by a currently enabled role.
   In <productname>PostgreSQL</productname>, this currently applies to
   collations, domains, foreign-data wrappers, foreign servers, and sequences.  There is one
   row for each combination of object, grantor, and grantee.
  </para>

  <para>
   Since collations do not have real privileges
   in <productname>PostgreSQL</productname>, this view shows implicit
   non-grantable <literal>USAGE</literal> privileges granted by the
   owner to <literal>PUBLIC</literal> for all collations.  The other
   object types, however, show real privileges.
  </para>

  <para>
   In PostgreSQL, sequences also support <literal>SELECT</literal>
   and <literal>UPDATE</literal> privileges in addition to
   the <literal>USAGE</literal> privilege.  These are nonstandard and therefore
   not visible in the information schema.
  </para>

  <table>
   <title><structname>usage_privileges</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantor</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that granted the privilege
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>grantee</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the role that the privilege was granted to
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the object (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the object, if applicable,
       else an empty string
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the object
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>object_type</structfield> <type>character_data</type>
      </para>
      <para>
       <literal>COLLATION</literal> or <literal>DOMAIN</literal> or <literal>FOREIGN DATA WRAPPER</literal> or <literal>FOREIGN SERVER</literal> or <literal>SEQUENCE</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>privilege_type</structfield> <type>character_data</type>
      </para>
      <para>
       Always <literal>USAGE</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_grantable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-defined-types">
  <title><literal>user_defined_types</literal></title>

  <para>
   The view <literal>user_defined_types</literal> currently contains
   all composite types defined in the current database.
   Only those types are shown that the current user has access to (by way
   of being the owner or having some privilege).
  </para>

  <para>
   SQL knows about two kinds of user-defined types: structured types
   (also known as composite types
   in <productname>PostgreSQL</productname>) and distinct types (not
   implemented in <productname>PostgreSQL</productname>).  To be
   future-proof, use the
   column <literal>user_defined_type_category</literal> to
   differentiate between these.  Other user-defined types such as base
   types and enums, which are <productname>PostgreSQL</productname>
   extensions, are not shown here.  For domains,
   see <xref linkend="infoschema-domains"/> instead.
  </para>

  <table>
   <title><structname>user_defined_types</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>user_defined_type_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the type (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>user_defined_type_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the type
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>user_defined_type_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the type
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>user_defined_type_category</structfield> <type>character_data</type>
      </para>
      <para>
       Currently always <literal>STRUCTURED</literal>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_instantiable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_final</structfield> <type>yes_or_no</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ordering_form</structfield> <type>character_data</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ordering_category</structfield> <type>character_data</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ordering_routine_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ordering_routine_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ordering_routine_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>reference_type</structfield> <type>character_data</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>data_type</structfield> <type>character_data</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_maximum_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_octet_length</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>character_set_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>collation_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_precision_radix</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numeric_scale</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datetime_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_type</structfield> <type>character_data</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>interval_precision</structfield> <type>cardinal_number</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>source_dtd_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ref_dtd_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Applies to a feature not available in <productname>PostgreSQL</productname>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mapping-options">
  <title><literal>user_mapping_options</literal></title>

  <para>
   The view <literal>user_mapping_options</literal> contains all the
   options defined for user mappings in the current database.  Only
   those user mappings are shown where the current user has access to
   the corresponding foreign server (by way of being the owner or
   having some privilege).
  </para>

  <table>
   <title><structname>user_mapping_options</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>authorization_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the user being mapped,
       or <literal>PUBLIC</literal> if the mapping is public
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_server_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the foreign server used by this
       mapping is defined in (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_server_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the foreign server used by this mapping
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>option_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of an option
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>option_value</structfield> <type>character_data</type>
      </para>
      <para>
       Value of the option.  This column will show as null
       unless the current user is the user being mapped, or the mapping
       is for <literal>PUBLIC</literal> and the current user is the
       server owner, or the current user is a superuser.  The intent is
       to protect password information stored as user mapping
       option.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mappings">
  <title><literal>user_mappings</literal></title>

  <para>
   The view <literal>user_mappings</literal> contains all user
   mappings defined in the current database.  Only those user mappings
   are shown where the current user has access to the corresponding
   foreign server (by way of being the owner or having some
   privilege).
  </para>

  <table>
   <title><structname>user_mappings</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>authorization_identifier</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the user being mapped,
       or <literal>PUBLIC</literal> if the mapping is public
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_server_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that the foreign server used by this
       mapping is defined in (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>foreign_server_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the foreign server used by this mapping
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-column-usage">
  <title><literal>view_column_usage</literal></title>

  <para>
   The view <literal>view_column_usage</literal> identifies all
   columns that are used in the query expression of a view (the
   <command>SELECT</command> statement that defines the view).  A
   column is only included if the table that contains the column is
   owned by a currently enabled role.
  </para>

  <note>
   <para>
    Columns of system tables are not included.  This should be fixed
    sometime.
   </para>
  </note>

  <table>
   <title><structname>view_column_usage</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>view_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the view (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>view_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the view
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>view_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the view
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table that contains the
       column that is used by the view (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table that contains the
       column that is used by the view
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table that contains the column that is used by the
       view
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>column_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the column that is used by the view
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-routine-usage">
  <title><literal>view_routine_usage</literal></title>

  <para>
   The view <literal>view_routine_usage</literal> identifies all
   routines (functions and procedures) that are used in the query
   expression of a view (the <command>SELECT</command> statement that
   defines the view).  A routine is only included if that routine is
   owned by a currently enabled role.
  </para>

  <table>
   <title><structname>view_routine_usage</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the view (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the view
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the view
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database containing the function (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema containing the function
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>specific_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       The <quote>specific name</quote> of the function.  See <xref linkend="infoschema-routines"/> for more information.
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-table-usage">
  <title><literal>view_table_usage</literal></title>

  <para>
   The view <literal>view_table_usage</literal> identifies all tables
   that are used in the query expression of a view (the
   <command>SELECT</command> statement that defines the view).  A
   table is only included if that table is owned by a currently
   enabled role.
  </para>

  <note>
   <para>
    System tables are not included.  This should be fixed sometime.
   </para>
  </note>

  <table>
   <title><structname>view_table_usage</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>view_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the view (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>view_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the view
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>view_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the view
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the table that is
       used by the view (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the table that is used by the
       view
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the table that is used by the view
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-views">
  <title><literal>views</literal></title>

  <para>
   The view <literal>views</literal> contains all views defined in the
   current database.  Only those views are shown that the current user
   has access to (by way of being the owner or having some privilege).
  </para>

  <table>
   <title><structname>views</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_catalog</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the database that contains the view (always the current database)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_schema</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the schema that contains the view
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>table_name</structfield> <type>sql_identifier</type>
      </para>
      <para>
       Name of the view
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>view_definition</structfield> <type>character_data</type>
      </para>
      <para>
       Query expression defining the view (null if the view is not
       owned by a currently enabled role)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>check_option</structfield> <type>character_data</type>
      </para>
      <para>
       <literal>CASCADED</literal> or <literal>LOCAL</literal> if the view
       has a <literal>CHECK OPTION</literal> defined on it,
       <literal>NONE</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_updatable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the view is updatable (allows
       <command>UPDATE</command> and <command>DELETE</command>),
       <literal>NO</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_insertable_into</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the view is insertable into (allows
       <command>INSERT</command>), <literal>NO</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_trigger_updatable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the view has an <literal>INSTEAD OF</literal>
       <command>UPDATE</command> trigger defined on it, <literal>NO</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_trigger_deletable</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the view has an <literal>INSTEAD OF</literal>
       <command>DELETE</command> trigger defined on it, <literal>NO</literal> if not
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>is_trigger_insertable_into</structfield> <type>yes_or_no</type>
      </para>
      <para>
       <literal>YES</literal> if the view has an <literal>INSTEAD OF</literal>
       <command>INSERT</command> trigger defined on it, <literal>NO</literal> if not
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

</chapter>
